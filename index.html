<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRASSFALL</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ðŸŽ®</text></svg>">
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.7); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            transition: width 0.1s, height 0.1s, opacity 0.2s;
        }
        #hitmarker {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            transform: translate(-50%, -50%); pointer-events: none;
            opacity: 0; transition: opacity 0.05s;
        }
        #hitmarker.show {
            opacity: 1;
        }
        #hitmarker.headshot .hm-line {
            background: rgba(255, 0, 0, 1);
            width: 28px; height: 3px;
            box-shadow: 0 0 10px #f00, 0 0 20px #f00;
        }
        .hm-line {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 2px;
            background: rgba(180, 180, 180, 0.5);
            transform-origin: center;
        }
        .hm-line:first-child {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        .hm-line:last-child {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        /* ============ MICRO-ANIMATION POLISHES ============ */
        @keyframes pulse-glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        @keyframes score-pop {
            0% {
                transform: translateX(-50%) scale(1);
                filter: brightness(1);
            }
            30% {
                transform: translateX(-50%) scale(1.25) translateY(-3px);
                filter: brightness(1.8);
                text-shadow: 0 0 15px #ff0, 0 0 30px #ff8800, 0 0 45px #ff4400;
            }
            60% {
                transform: translateX(-50%) scale(1.1) translateY(-1px);
                filter: brightness(1.3);
            }
            100% {
                transform: translateX(-50%) scale(1);
                filter: brightness(1);
            }
        }
        @keyframes score-mega-pop {
            0% {
                transform: translateX(-50%) scale(1);
                filter: brightness(1) hue-rotate(0deg);
            }
            20% {
                transform: translateX(-50%) scale(1.4) translateY(-5px);
                filter: brightness(2) hue-rotate(10deg);
                text-shadow: 0 0 20px #fff, 0 0 40px #ff0, 0 0 60px #ff4400, 0 0 80px #ff0000;
            }
            40% {
                transform: translateX(-50%) scale(1.15) translateY(-2px) rotate(1deg);
                filter: brightness(1.5) hue-rotate(5deg);
            }
            60% {
                transform: translateX(-50%) scale(1.2) translateY(-3px) rotate(-1deg);
                filter: brightness(1.4);
            }
            80% {
                transform: translateX(-50%) scale(1.05);
                filter: brightness(1.1);
            }
            100% {
                transform: translateX(-50%) scale(1);
                filter: brightness(1) hue-rotate(0deg);
            }
        }
        @keyframes score-counting {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.85; }
        }
        @keyframes ammo-shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-2px); }
            40% { transform: translateX(2px); }
            60% { transform: translateX(-1px); }
            80% { transform: translateX(1px); }
        }
        @keyframes wave-entrance {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes health-critical {
            0%, 100% { box-shadow: 0 0 5px #f00; }
            50% { box-shadow: 0 0 15px #f00, 0 0 25px #f00; }
        }
        @keyframes kill-flash {
            0% { color: #fff; text-shadow: 0 0 10px #fff; }
            100% { color: #888; text-shadow: none; }
        }
        @keyframes reload-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #ammo-display {
            position: absolute; bottom: 20px; right: 20px; color: #0f0;
            font-size: 28px; pointer-events: none; user-select: none;
            text-shadow: 0 0 5px #0f0;
            transition: all 0.15s ease-out;
        }
        #ammo-display.low-ammo {
            color: #f80; text-shadow: 0 0 8px #f80;
            animation: ammo-shake 0.3s ease-in-out;
        }
        #ammo-display.empty {
            color: #f00; text-shadow: 0 0 10px #f00;
            animation: pulse-glow 0.5s ease-in-out infinite;
        }
        #ammo-display.reloading {
            animation: reload-pulse 0.4s ease-in-out infinite;
        }
        #blocker, #game-over {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; cursor: pointer; z-index: 10;
        }
        #top-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center;
            pointer-events: none; user-select: none;
        }
        #wave-display {
            font-size: 32px; color: #f00; text-shadow: 0 0 10px #f00;
            letter-spacing: 4px;
            transition: all 0.3s ease-out;
        }
        #wave-display.new-wave {
            animation: wave-entrance 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #zombie-count {
            font-size: 16px; color: #888; margin-top: 5px;
            transition: color 0.2s;
        }
        #zombie-count.kill-flash {
            animation: kill-flash 0.3s ease-out;
        }
        #score-display {
            font-size: 22px;
            font-weight: 700;
            color: #ff0;
            text-shadow: 0 0 5px #ff0, 0 0 10px rgba(255, 200, 0, 0.3);
            margin-top: 10px;
            letter-spacing: 3px;
            font-family: 'Courier New', monospace;
            transition: all 0.2s ease-out;
            position: relative;
        }
        #score-display.score-bump {
            animation: score-pop 0.35s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #score-display.score-mega-bump {
            animation: score-mega-pop 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #score-display.counting {
            animation: score-counting 0.08s ease-in-out infinite;
        }
        /* Floating score bonus indicator */
        .score-bonus-float {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: 900;
            font-family: 'Impact', 'Arial Black', sans-serif;
            color: #fff;
            text-shadow: 0 0 20px #ff0, 0 0 40px #ff8800, 0 4px 8px rgba(0,0,0,0.8);
            pointer-events: none;
            z-index: 200;
            animation: score-bonus-animate 1s ease-out forwards;
            letter-spacing: 2px;
        }
        @keyframes score-bonus-animate {
            0% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(0.5);
            }
            20% {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1.2);
            }
            40% {
                opacity: 1;
                transform: translate(-50%, -60%) scale(1);
            }
            100% {
                opacity: 0;
                transform: translate(-50%, -150%) scale(0.8);
            }
        }
        /* === KILL MULTIPLIER === */
        #multiplier-container {
            position: fixed;
            top: 50%;
            right: 30px;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s ease;
            z-index: 100;
        }
        #multiplier-container.active {
            opacity: 1;
        }
        #multiplier-value {
            font-size: 72px;
            font-weight: 900;
            color: #fff;
            text-shadow:
                0 0 20px rgba(255, 200, 0, 0.8),
                0 0 40px rgba(255, 100, 0, 0.6),
                0 4px 8px rgba(0, 0, 0, 0.8);
            font-family: 'Impact', 'Arial Black', sans-serif;
            letter-spacing: -2px;
            line-height: 1;
            transition: all 0.15s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #multiplier-value.bump {
            animation: multiplier-pop 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        @keyframes multiplier-pop {
            0% { transform: scale(1); }
            50% { transform: scale(1.4); }
            100% { transform: scale(1); }
        }
        #multiplier-label {
            font-size: 14px;
            color: rgba(255, 200, 0, 0.9);
            text-transform: uppercase;
            letter-spacing: 3px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
            margin-top: -5px;
        }
        #multiplier-timer {
            width: 80px;
            height: 4px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        #multiplier-timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffcc00);
            border-radius: 2px;
            transition: width 0.1s linear;
            box-shadow: 0 0 10px rgba(255, 150, 0, 0.6);
        }
        /* Multiplier color tiers */
        #multiplier-container[data-tier="1"] #multiplier-value { color: #ffffff; }
        #multiplier-container[data-tier="2"] #multiplier-value { color: #ffee00; }
        #multiplier-container[data-tier="3"] #multiplier-value { color: #ffaa00; }
        #multiplier-container[data-tier="4"] #multiplier-value { color: #ff6600; }
        #multiplier-container[data-tier="5"] #multiplier-value { color: #ff0000; text-shadow: 0 0 30px rgba(255, 0, 0, 0.9), 0 0 60px rgba(255, 0, 0, 0.6), 0 4px 8px rgba(0, 0, 0, 0.8); }
        /* Decay warning pulse */
        #multiplier-container.warning #multiplier-value {
            animation: multiplier-warning 0.3s ease infinite alternate;
        }
        @keyframes multiplier-warning {
            0% { opacity: 1; }
            100% { opacity: 0.5; }
        }
        /* Multiplier lost animation */
        #multiplier-container.lost {
            animation: multiplier-lost 0.5s ease forwards;
        }
        @keyframes multiplier-lost {
            0% { transform: translateY(-50%) scale(1); opacity: 1; }
            100% { transform: translateY(-50%) scale(0.5); opacity: 0; }
        }
        @keyframes multiplier-score-float {
            0% { opacity: 1; transform: translateX(-50%) translateY(0) scale(1); }
            100% { opacity: 0; transform: translateX(-50%) translateY(-40px) scale(0.8); }
        }
        #health-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
            pointer-events: none; user-select: none;
        }
        #health-bar {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #0f0;
            overflow: hidden;
            transition: border-color 0.3s;
        }
        #health-bar.critical {
            border-color: #f00;
            animation: health-critical 0.8s ease-in-out infinite;
        }
        #health-fill {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0);
            transition: width 0.25s ease-out, background 0.3s;
        }
        #health-fill.damaged {
            background: linear-gradient(90deg, #f80, #a50);
        }
        #health-fill.critical {
            background: linear-gradient(90deg, #f00, #800);
        }
        #health-text {
            font-size: 24px; color: #0f0; text-shadow: 0 0 5px #0f0;
            min-width: 40px;
            transition: all 0.2s;
        }
        #health-text.critical {
            color: #f00; text-shadow: 0 0 8px #f00;
        }
        #health-fill.regenerating {
            background: linear-gradient(90deg, #00ff88, #00cc66);
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6), inset 0 0 10px rgba(255, 255, 255, 0.3);
            animation: health-regen-pulse 0.8s ease-in-out infinite;
        }
        @keyframes health-regen-pulse {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        #health-text.regenerating {
            color: #00ff88;
            text-shadow: 0 0 8px #00ff88, 0 0 15px #00ff88;
            animation: health-text-pulse 0.5s ease-in-out infinite;
        }
        @keyframes health-text-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        #health-bar.regenerating {
            border-color: #00ff88;
            box-shadow: 0 0 10px rgba(0, 255, 136, 0.5);
        }
        /* Health regen indicator */
        #regen-indicator {
            position: absolute;
            bottom: 45px;
            left: 20px;
            font-size: 14px;
            color: #00ff88;
            text-shadow: 0 0 5px #00ff88;
            opacity: 0;
            transition: opacity 0.3s ease;
            pointer-events: none;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        #regen-indicator.active {
            opacity: 1;
            animation: regen-text-glow 1s ease-in-out infinite;
        }
        @keyframes regen-text-glow {
            0%, 100% { text-shadow: 0 0 5px #00ff88, 0 0 10px #00ff88; }
            50% { text-shadow: 0 0 10px #00ff88, 0 0 20px #00ff88, 0 0 30px #00ff88; }
        }

        /* === POWER-UP HUD STYLES === */
        .powerup-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 10px;
            margin: 3px 0;
            font-size: 14px;
            font-weight: bold;
            letter-spacing: 1px;
            border-radius: 4px;
            background: rgba(0, 0, 0, 0.4);
            border-left: 3px solid currentColor;
            animation: powerup-pulse 0.8s ease-in-out infinite alternate;
        }
        .powerup-icon {
            font-size: 16px;
        }
        @keyframes powerup-pulse {
            0% { opacity: 0.85; transform: scale(1); }
            100% { opacity: 1; transform: scale(1.02); }
        }
        .shield-active { color: #4488ff; text-shadow: 0 0 10px #4488ff; }
        .speed-active { color: #00ffff; text-shadow: 0 0 10px #00ffff; }
        .damage-active { color: #ff4444; text-shadow: 0 0 10px #ff4444; }
        .rapid-active { color: #ff8800; text-shadow: 0 0 10px #ff8800; }
        .infinite-active { color: #ffdd00; text-shadow: 0 0 10px #ffdd00; }
        .explosive-active { color: #ff4400; text-shadow: 0 0 10px #ff4400; }
        .penetrating-active { color: #8844ff; text-shadow: 0 0 10px #8844ff; }

        /* Shield active visual effect on screen edges */
        @keyframes shield-border-glow {
            0%, 100% { box-shadow: inset 0 0 30px rgba(68, 136, 255, 0.2); }
            50% { box-shadow: inset 0 0 50px rgba(68, 136, 255, 0.35); }
        }

        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%);
            pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }
        /* === DAMAGE DIRECTION INDICATOR === */
        #damage-direction {
            position: absolute; top: 50%; left: 50%; width: 300px; height: 300px;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 50;
        }
        .damage-arrow {
            position: absolute; width: 80px; height: 40px;
            background: linear-gradient(90deg, transparent 0%, rgba(255,0,0,0.8) 50%, transparent 100%);
            opacity: 0; transition: opacity 0.1s;
            filter: blur(2px);
        }
        .damage-arrow.top { top: 0; left: 50%; transform: translateX(-50%) rotate(-90deg); }
        .damage-arrow.bottom { bottom: 0; left: 50%; transform: translateX(-50%) rotate(90deg); }
        .damage-arrow.left { left: 0; top: 50%; transform: translateY(-50%) rotate(180deg); }
        .damage-arrow.right { right: 0; top: 50%; transform: translateY(-50%); }
        .damage-arrow.top-left { top: 15%; left: 15%; transform: rotate(-135deg); }
        .damage-arrow.top-right { top: 15%; right: 15%; transform: rotate(-45deg); }
        .damage-arrow.bottom-left { bottom: 15%; left: 15%; transform: rotate(135deg); }
        .damage-arrow.bottom-right { bottom: 15%; right: 15%; transform: rotate(45deg); }
        /* === LOW HEALTH VIGNETTE === */
        #low-health-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; z-index: 45;
            box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.6);
            transition: opacity 0.3s;
        }
        #low-health-vignette.pulse {
            animation: lowHealthPulse 1s ease-in-out infinite;
        }
        @keyframes lowHealthPulse {
            0%, 100% { box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: inset 0 0 180px rgba(255, 0, 0, 0.7); }
        }
        /* === DYNAMIC CROSSHAIR === */
        #crosshair {
            transition: width 0.08s ease-out, height 0.08s ease-out, opacity 0.2s, border-color 0.15s;
        }
        #crosshair.firing {
            border-color: rgba(255, 200, 0, 0.9);
        }
        #crosshair.moving {
            border-color: rgba(0, 200, 255, 0.7);
        }
        #restart-btn {
            transition: all 0.3s ease-out;
        }
        #restart-btn:hover {
            background: rgba(255, 0, 0, 0.1);
            border-color: #f00;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4), inset 0 0 20px rgba(255, 0, 0, 0.1);
            transform: scale(1.02);
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
        }
        #restart-btn:active {
            transform: scale(0.98);
        }
        /* === WEAPON INDICATOR === */
        #weapon-indicator {
            position: absolute;
            bottom: 60px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            user-select: none;
        }
        .weapon-slot {
            padding: 6px 12px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.15s ease-out;
        }
        .weapon-slot.active {
            background: rgba(0, 255, 0, 0.15);
            border-color: #0f0;
            color: #0f0;
            text-shadow: 0 0 5px #0f0;
        }
        /* === SCOPE OVERLAY === */
        #scope-overlay {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            opacity: 0;
            transform: scale(1.1);
            transition: opacity 0.2s ease-out, transform 0.25s cubic-bezier(0.15, 0.85, 0.35, 1.2);
            z-index: 60;
        }
        #scope-overlay.active {
            opacity: 1;
            transform: scale(1);
        }
        .scope-vignette {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(
                circle at center,
                transparent 0%,
                transparent 28%,
                rgba(0, 0, 0, 0.4) 32%,
                rgba(0, 0, 0, 0.98) 38%,
                #000 45%
            );
            box-shadow: inset 0 0 200px rgba(0,0,0,1);
        }
        /* Add a lens dirt/glass effect */
        .scope-vignette::after {
            content: '';
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.03) 0%, transparent 20%);
            pointer-events: none;
        }
        .scope-reticle {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 400px; height: 400px;
        }
        .reticle-cross-h {
            position: absolute;
            top: 50%; left: 0;
            width: 100%; height: 1px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(0,0,0,0.8) 30%,
                transparent 45%,
                transparent 55%,
                rgba(0,0,0,0.8) 70%,
                transparent 100%
            );
            transform: translateY(-50%);
        }
        .reticle-cross-h::after {
            content: '';
            position: absolute;
            top: -0.5px; left: 0;
            width: 100%; height: 2px;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(255,0,0,0.6) 30%,
                transparent 45%,
                transparent 55%,
                rgba(255,0,0,0.6) 70%,
                transparent 100%
            );
        }
        .reticle-cross-v {
            position: absolute;
            top: 0; left: 50%;
            width: 1px; height: 100%;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(0,0,0,0.8) 30%,
                transparent 45%,
                transparent 55%,
                rgba(0,0,0,0.8) 70%,
                transparent 100%
            );
            transform: translateX(-50%);
        }
        .reticle-cross-v::after {
            content: '';
            position: absolute;
            top: 0; left: -0.5px;
            width: 2px; height: 100%;
            background: linear-gradient(180deg,
                transparent 0%,
                rgba(255,0,0,0.6) 30%,
                transparent 45%,
                transparent 55%,
                rgba(255,0,0,0.6) 70%,
                transparent 100%
            );
        }
        .reticle-dot {
            position: absolute;
            top: 50%; left: 50%;
            width: 4px; height: 4px;
            background: rgba(255, 0, 0, 0.9);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 4px rgba(255, 0, 0, 0.8);
        }
        .reticle-mil {
            position: absolute;
            left: 50%;
            width: 8px; height: 1px;
            background: rgba(0, 0, 0, 0.7);
            transform: translateX(-50%);
        }
        .reticle-mil::after {
            content: '';
            position: absolute;
            width: 100%; height: 2px;
            background: rgba(255, 0, 0, 0.4);
            top: -0.5px;
        }
        .mil-1 { top: calc(50% + 30px); }
        .mil-2 { top: calc(50% + 60px); }
        .mil-3 { top: calc(50% + 90px); }
        .mil-4 { top: calc(50% + 120px); }
        /* === BOLT ACTION INDICATOR === */
        #bolt-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 60px);
            padding: 8px 16px;
            background: rgba(255, 150, 0, 0.2);
            border: 1px solid rgba(255, 150, 0, 0.6);
            color: #f90;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 2px;
            text-shadow: 0 0 5px #f90;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }
        #bolt-indicator.show {
            opacity: 1;
            animation: bolt-pulse 0.5s ease-in-out infinite alternate;
        }
        @keyframes bolt-pulse {
            0% { box-shadow: 0 0 5px rgba(255, 150, 0, 0.3); }
            100% { box-shadow: 0 0 15px rgba(255, 150, 0, 0.6); }
        }
        /* === PUMP ACTION INDICATOR === */
        #pump-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, 100px);
            padding: 5px 12px;
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid rgba(255, 50, 50, 0.6);
            color: #ff4444;
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 5px #ff4444;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            z-index: 100;
        }
        #pump-indicator.show {
            opacity: 1;
            animation: pump-pulse 0.4s ease-in-out infinite alternate;
        }
        @keyframes pump-pulse {
            0% { box-shadow: 0 0 5px rgba(255, 50, 50, 0.3); }
            100% { box-shadow: 0 0 15px rgba(255, 50, 50, 0.6); }
        }

        /* ============ MAIN MENU - BRASSFALL ============ */
        #main-menu {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: linear-gradient(180deg, #0a0a0a 0%, #050505 50%, #080505 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            overflow: hidden;
        }

        /* Animated background grid */
        .menu-grid {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-image:
                linear-gradient(rgba(255, 0, 0, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 0, 0, 0.03) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: gridPulse 4s ease-in-out infinite;
        }

        @keyframes gridPulse {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 0.6; }
        }

        /* Floating particles */
        .menu-particles {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .particle {
            position: absolute;
            width: 2px; height: 2px;
            background: rgba(255, 50, 50, 0.6);
            border-radius: 50%;
            animation: floatUp 8s linear infinite;
        }

        @keyframes floatUp {
            0% { transform: translateY(100vh) scale(1); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-10vh) scale(0.5); opacity: 0; }
        }

        /* Biohazard scanlines */
        .menu-scanlines {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: repeating-linear-gradient(
                0deg,
                transparent,
                transparent 2px,
                rgba(0, 0, 0, 0.15) 2px,
                rgba(0, 0, 0, 0.15) 4px
            );
            pointer-events: none;
            animation: scanlineMove 0.1s linear infinite;
        }

        @keyframes scanlineMove {
            0% { transform: translateY(0); }
            100% { transform: translateY(4px); }
        }

        /* Vignette overlay */
        .menu-vignette {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, transparent 40%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
        }

        /* Warning stripes */
        .warning-stripe {
            position: absolute;
            height: 30px;
            width: 150%;
            left: -25%;
            background: repeating-linear-gradient(
                -45deg,
                #1a1a00,
                #1a1a00 20px,
                #0a0a00 20px,
                #0a0a00 40px
            );
            opacity: 0.4;
        }
        .warning-stripe.top { top: 60px; }
        .warning-stripe.bottom { bottom: 60px; }

        /* Title container */
        .title-container {
            position: relative;
            margin-bottom: 60px;
            text-align: center;
        }

        /* Classification badge */
        .classification {
            font-size: 12px;
            letter-spacing: 8px;
            color: #f00;
            text-transform: uppercase;
            margin-bottom: 15px;
            opacity: 0.8;
            animation: blink 2s step-end infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 0.4; }
        }

        /* Main title */
        .menu-title {
            font-size: 120px;
            font-weight: bold;
            color: #fff;
            text-shadow:
                0 0 10px rgba(255, 0, 0, 0.8),
                0 0 20px rgba(255, 0, 0, 0.6),
                0 0 40px rgba(255, 0, 0, 0.4),
                0 0 80px rgba(255, 0, 0, 0.2);
            letter-spacing: 15px;
            position: relative;
            animation: titleGlow 3s ease-in-out infinite;
        }

        @keyframes titleGlow {
            0%, 100% {
                text-shadow:
                    0 0 10px rgba(255, 0, 0, 0.8),
                    0 0 20px rgba(255, 0, 0, 0.6),
                    0 0 40px rgba(255, 0, 0, 0.4),
                    0 0 80px rgba(255, 0, 0, 0.2);
            }
            50% {
                text-shadow:
                    0 0 15px rgba(255, 50, 50, 1),
                    0 0 30px rgba(255, 0, 0, 0.8),
                    0 0 60px rgba(255, 0, 0, 0.5),
                    0 0 100px rgba(255, 0, 0, 0.3);
            }
        }

        /* Glitch effect layers */
        .menu-title::before,
        .menu-title::after {
            content: 'BRASSFALL';
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            overflow: hidden;
        }

        .menu-title::before {
            color: #0ff;
            animation: glitch1 3s infinite linear alternate-reverse;
            clip-path: inset(0 0 70% 0);
        }

        .menu-title::after {
            color: #f0f;
            animation: glitch2 2s infinite linear alternate-reverse;
            clip-path: inset(70% 0 0 0);
        }

        @keyframes glitch1 {
            0%, 90%, 100% { transform: translate(0); }
            92% { transform: translate(-5px, 2px); }
            94% { transform: translate(5px, -2px); }
            96% { transform: translate(-3px, 0); }
            98% { transform: translate(3px, 0); }
        }

        @keyframes glitch2 {
            0%, 85%, 100% { transform: translate(0); }
            87% { transform: translate(5px, -2px); }
            89% { transform: translate(-5px, 2px); }
            91% { transform: translate(2px, 0); }
            93% { transform: translate(-2px, 0); }
        }

        /* Subtitle */
        .menu-subtitle {
            font-size: 14px;
            letter-spacing: 12px;
            color: #666;
            margin-top: 20px;
            text-transform: uppercase;
        }

        /* Menu buttons container */
        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 15px;
            margin-bottom: 50px;
        }

        /* Play button */
        .menu-btn {
            position: relative;
            padding: 20px 80px;
            font-family: 'Courier New', monospace;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 8px;
            text-transform: uppercase;
            color: #fff;
            background: transparent;
            border: 2px solid rgba(255, 0, 0, 0.6);
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .menu-btn::before {
            content: '';
            position: absolute;
            top: 0; left: -100%;
            width: 100%; height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 0, 0, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .menu-btn:hover {
            border-color: #f00;
            color: #f00;
            text-shadow: 0 0 10px rgba(255, 0, 0, 0.8);
            box-shadow:
                0 0 20px rgba(255, 0, 0, 0.3),
                inset 0 0 20px rgba(255, 0, 0, 0.1);
        }

        .menu-btn:hover::before {
            left: 100%;
        }

        .menu-btn:active {
            transform: scale(0.98);
            box-shadow:
                0 0 30px rgba(255, 0, 0, 0.5),
                inset 0 0 30px rgba(255, 0, 0, 0.2);
        }

        /* Corner brackets on button */
        .menu-btn .corner {
            position: absolute;
            width: 15px; height: 15px;
            border-color: #f00;
            border-style: solid;
            transition: all 0.3s ease;
        }
        .menu-btn .corner.tl { top: 5px; left: 5px; border-width: 2px 0 0 2px; }
        .menu-btn .corner.tr { top: 5px; right: 5px; border-width: 2px 2px 0 0; }
        .menu-btn .corner.bl { bottom: 5px; left: 5px; border-width: 0 0 2px 2px; }
        .menu-btn .corner.br { bottom: 5px; right: 5px; border-width: 0 2px 2px 0; }

        .menu-btn:hover .corner {
            width: 20px; height: 20px;
        }

        /* Controls panel */
        .controls-panel {
            position: relative;
            padding: 25px 40px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 0, 0, 0.2);
            text-align: center;
        }

        .controls-title {
            font-size: 12px;
            letter-spacing: 6px;
            color: #f00;
            margin-bottom: 15px;
            text-transform: uppercase;
        }

        .controls-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px 40px;
            font-size: 13px;
            color: #888;
        }

        .control-item {
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .control-key {
            color: #0f0;
            font-weight: bold;
        }

        .control-action {
            color: #666;
        }

        /* Weapons info */
        .weapons-info {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid rgba(255, 0, 0, 0.2);
            font-size: 12px;
            color: #f90;
            letter-spacing: 2px;
        }

        /* Version/Credits */
        .menu-footer {
            position: absolute;
            bottom: 20px;
            font-size: 11px;
            color: #333;
            letter-spacing: 4px;
        }

        /* Hide old blocker, show new menu */
        #blocker {
            display: none !important;
        }

        /* ============ AUDIO SETTINGS ============ */
        .audio-settings {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 0, 0, 0.3);
            z-index: 101;
        }

        .audio-settings-title {
            font-size: 10px;
            letter-spacing: 4px;
            color: #f00;
            text-transform: uppercase;
            margin-bottom: 5px;
        }

        .audio-control {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .audio-label {
            font-size: 11px;
            color: #888;
            width: 50px;
            letter-spacing: 1px;
        }

        .audio-slider {
            -webkit-appearance: none;
            appearance: none;
            width: 100px;
            height: 4px;
            background: #333;
            border-radius: 2px;
            outline: none;
            cursor: pointer;
        }

        .audio-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 14px;
            height: 14px;
            background: #f00;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
            transition: all 0.2s ease;
        }

        .audio-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }

        .audio-slider::-moz-range-thumb {
            width: 14px;
            height: 14px;
            background: #f00;
            border: none;
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 8px rgba(255, 0, 0, 0.5);
        }

        .audio-value {
            font-size: 11px;
            color: #0f0;
            width: 35px;
            text-align: right;
        }

        /* In-game audio toggle */
        #audio-toggle {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 10px;
            pointer-events: auto;
            z-index: 80;
        }

        .audio-btn {
            width: 36px;
            height: 36px;
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #888;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
        }

        .audio-btn:hover {
            border-color: #0f0;
            color: #0f0;
        }

        .audio-btn.muted {
            color: #f00;
            border-color: rgba(255, 0, 0, 0.4);
        }

        .audio-btn.muted:hover {
            border-color: #f00;
        }

        /* ============ SLOW-MOTION EFFECT ============ */
        #slowmo-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 70;
            opacity: 0;
            transition: opacity 0.15s ease-out;
            background: radial-gradient(ellipse at center,
                transparent 0%,
                transparent 30%,
                rgba(0, 0, 0, 0.3) 100%
            );
            box-shadow: inset 0 0 100px rgba(255, 100, 0, 0.2);
        }

        #slowmo-overlay.active {
            opacity: 1;
        }

        #slowmo-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px;
            font-weight: bold;
            color: #fff;
            text-shadow:
                0 0 20px rgba(255, 50, 0, 0.8),
                0 0 40px rgba(255, 50, 0, 0.5),
                0 0 60px rgba(255, 50, 0, 0.3);
            letter-spacing: 15px;
            opacity: 0;
            pointer-events: none;
            z-index: 71;
            transition: opacity 0.2s ease-out;
        }

        #slowmo-text.show {
            opacity: 1;
            animation: slowmoTextPulse 0.5s ease-out;
        }

        @keyframes slowmoTextPulse {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }

        /* ============ PAUSE MENU ============ */
        #pause-overlay {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.85);
            backdrop-filter: blur(8px);
            z-index: 500;
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
        }
        #pause-overlay.active {
            display: flex;
        }
        #pause-title {
            font-size: 72px;
            font-weight: 900;
            color: #fff;
            text-shadow: 0 0 30px rgba(255, 100, 0, 0.8), 0 4px 8px rgba(0,0,0,0.8);
            letter-spacing: 10px;
            margin-bottom: 40px;
            font-family: 'Impact', 'Arial Black', sans-serif;
        }
        .pause-menu-btn {
            background: linear-gradient(180deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0.05) 100%);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            color: #fff;
            font-size: 24px;
            font-weight: 600;
            padding: 15px 60px;
            margin: 10px;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 3px;
            min-width: 280px;
        }
        .pause-menu-btn:hover {
            background: linear-gradient(180deg, rgba(255,150,0,0.3) 0%, rgba(255,100,0,0.2) 100%);
            border-color: rgba(255, 150, 0, 0.8);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(255, 100, 0, 0.4);
        }
        .pause-menu-btn:active {
            transform: scale(0.98);
        }
        #pause-hint {
            position: absolute;
            bottom: 40px;
            color: rgba(255,255,255,0.5);
            font-size: 16px;
            letter-spacing: 2px;
        }
    </style>
</head>
<body>

<!-- Background Music -->
<audio id="bg-music" loop preload="auto">
    <source src="assets/audio/Tumor.mp3" type="audio/mpeg">
</audio>

<!-- ============ MAIN MENU - BRASSFALL ============ -->
<div id="main-menu">
    <!-- Atmospheric background layers -->
    <div class="menu-grid"></div>
    <div class="menu-particles" id="menu-particles"></div>
    <div class="menu-scanlines"></div>
    <div class="menu-vignette"></div>

    <!-- Warning stripes -->
    <div class="warning-stripe top"></div>
    <div class="warning-stripe bottom"></div>

    <!-- Audio Settings Panel -->
    <div class="audio-settings" id="audio-settings">
        <div class="audio-settings-title">// Audio //</div>
        <div class="audio-control">
            <span class="audio-label">MUSIC</span>
            <input type="range" class="audio-slider" id="music-volume" min="0" max="100" value="50">
            <span class="audio-value" id="music-value">50%</span>
        </div>
        <div class="audio-control">
            <span class="audio-label">SFX</span>
            <input type="range" class="audio-slider" id="sfx-volume" min="0" max="100" value="70">
            <span class="audio-value" id="sfx-value">70%</span>
        </div>
    </div>

    <!-- Title section -->
    <div class="title-container">
        <div class="classification">/// CLASSIFIED - CONTAINMENT BREACH ///</div>
        <h1 class="menu-title">BRASSFALL</h1>
        <div class="menu-subtitle">Survival Protocol Initiated</div>
    </div>

    <!-- Play button -->
    <div class="menu-buttons">
        <button class="menu-btn" id="play-btn">
            <span class="corner tl"></span>
            <span class="corner tr"></span>
            <span class="corner bl"></span>
            <span class="corner br"></span>
            ENGAGE
        </button>
    </div>

    <!-- Controls panel -->
    <div class="controls-panel">
        <div class="controls-title">// Combat Systems //</div>
        <div class="controls-grid">
            <div class="control-item">
                <span class="control-key">WASD</span>
                <span class="control-action">Movement</span>
            </div>
            <div class="control-item">
                <span class="control-key">SHIFT</span>
                <span class="control-action">Sprint</span>
            </div>
            <div class="control-item">
                <span class="control-key">SPACE</span>
                <span class="control-action">Jump</span>
            </div>
            <div class="control-item">
                <span class="control-key">R</span>
                <span class="control-action">Reload</span>
            </div>
            <div class="control-item">
                <span class="control-key">LMB</span>
                <span class="control-action">Fire</span>
            </div>
            <div class="control-item">
                <span class="control-key">RMB</span>
                <span class="control-action">Aim</span>
            </div>
        </div>
        <div class="weapons-info">
            [1] AK-47 &nbsp;&nbsp;|&nbsp;&nbsp; [2] SNIPER &nbsp;&nbsp;|&nbsp;&nbsp; [SCROLL] Switch
        </div>
    </div>

    <!-- Footer -->
    <div class="menu-footer">v1.0 // CONTAINMENT FACILITY</div>
</div>

<!-- Legacy blocker (hidden, kept for pointer lock) -->
<div id="blocker" style="display: none;">
    <h1>BRASSFALL</h1>
    <p>Click to continue</p>
</div>

<div id="game-over" style="display: none;">
    <div style="font-size: 12px; letter-spacing: 6px; color: #f00; margin-bottom: 10px; opacity: 0.8;">/// CONTAINMENT FAILURE ///</div>
    <h1 style="color: #f00; text-shadow: 0 0 20px #f00, 0 0 40px #f00; font-size: 80px; letter-spacing: 10px; margin: 0;">TERMINATED</h1>
    <div style="font-size: 14px; color: #666; letter-spacing: 4px; margin-top: 10px;">OPERATIVE STATUS: DECEASED</div>
    <p style="font-size: 28px; color: #ff0; text-shadow: 0 0 10px #ff0; margin-top: 30px;">SCORE: <span id="final-score">0</span></p>
    <p style="font-size: 16px; color: #888;">Survived to Wave <span id="final-wave" style="color: #f00;">1</span></p>
    <button id="restart-btn" onclick="restartGame()" style="margin-top: 30px; padding: 18px 60px; font-size: 20px; background: transparent; color: #f00; border: 2px solid rgba(255,0,0,0.6); cursor: pointer; font-family: inherit; letter-spacing: 6px; transition: all 0.3s ease;">REINITIALIZE</button>
</div>

<div id="crosshair"></div>
<div id="hitmarker">
    <div class="hm-line"></div>
    <div class="hm-line"></div>
</div>

<div id="damage-flash"></div>

<!-- Slow-Motion Effect Overlay -->
<div id="slowmo-overlay"></div>

<!-- Pause Menu -->
<div id="pause-overlay">
    <div id="pause-title">PAUSED</div>
    <button class="pause-menu-btn" id="resume-btn">Resume</button>
    <button class="pause-menu-btn" id="restart-btn">Restart</button>
    <div id="pause-hint">Press ESC to resume</div>
</div>
<div id="slowmo-text">BREACH CLEARED</div>

<!-- Damage Direction Indicator -->
<div id="damage-direction">
    <div class="damage-arrow top"></div>
    <div class="damage-arrow bottom"></div>
    <div class="damage-arrow left"></div>
    <div class="damage-arrow right"></div>
    <div class="damage-arrow top-left"></div>
    <div class="damage-arrow top-right"></div>
    <div class="damage-arrow bottom-left"></div>
    <div class="damage-arrow bottom-right"></div>
</div>

<!-- Low Health Vignette -->
<div id="low-health-vignette"></div>

<!-- Top HUD - Wave and Score -->
<div id="top-hud">
    <div id="wave-display">INITIALIZING...</div>
    <div id="zombie-count">0 HOSTILES</div>
    <div id="score-display">00000000</div>
</div>

<!-- Kill Multiplier Display -->
<div id="multiplier-container" data-tier="1">
    <div id="multiplier-value">1x</div>
    <div id="multiplier-label">COMBO</div>
    <div id="multiplier-timer">
        <div id="multiplier-timer-fill"></div>
    </div>
</div>

<!-- In-Game Audio Toggle -->
<div id="audio-toggle">
    <button class="audio-btn" id="toggle-music" title="Toggle Music">&#9835;</button>
    <button class="audio-btn" id="toggle-sfx" title="Toggle SFX">&#128266;</button>
</div>

<!-- Bottom Left - Health -->
<div id="regen-indicator">+ REGENERATING</div>
<div id="health-container">
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    <div id="health-text">100</div>
</div>

<!-- Bottom Right - Ammo -->
<div id="ammo-display">30 / 90</div>

<!-- Weapon Indicator -->
<div id="weapon-indicator">
    <div class="weapon-slot active" data-weapon="ak">1: AK-47</div>
    <div class="weapon-slot" data-weapon="sniper">2: SNIPER</div>
    <div class="weapon-slot" data-weapon="shotgun">3: SHOTGUN</div>
</div>

<!-- Scope Overlay (for sniper ADS) -->
<div id="scope-overlay">
    <div class="scope-vignette"></div>
    <div class="scope-reticle">
        <div class="reticle-cross-h"></div>
        <div class="reticle-cross-v"></div>
        <div class="reticle-dot"></div>
        <div class="reticle-mil mil-1"></div>
        <div class="reticle-mil mil-2"></div>
        <div class="reticle-mil mil-3"></div>
        <div class="reticle-mil mil-4"></div>
    </div>
</div>

<!-- Bolt Action Indicator -->
<div id="bolt-indicator">CYCLE BOLT [LMB]</div>
<!-- Pump Action Indicator -->
<div id="pump-indicator">PUMP [R]</div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Post-processing -->
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
<!-- TWEEN.js for complex curves -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * MAIN MENU - BRASSFALL
 * Atmospheric menu system with audio controls
 */
(function initMainMenu() {
    // Audio elements
    const bgMusic = document.getElementById('bg-music');
    const musicSlider = document.getElementById('music-volume');
    const sfxSlider = document.getElementById('sfx-volume');
    const musicValueDisplay = document.getElementById('music-value');
    const sfxValueDisplay = document.getElementById('sfx-value');
    const toggleMusicBtn = document.getElementById('toggle-music');
    const toggleSfxBtn = document.getElementById('toggle-sfx');

    // Audio state
    let musicVol = 0.5;
    let sfxVol = 0.7;
    let isMusicMuted = false;
    let isSfxMuted = false;

    // Spatial audio context for "rooftop speaker" effect
    let musicAudioCtx = null;
    let musicGainNode = null;
    let spatialInitialized = false;

    function initSpatialAudio() {
        if (spatialInitialized || !bgMusic) return;

        // Skip spatial audio for file:// protocol (CORS restrictions)
        if (window.location.protocol === 'file:') {
            console.log('Running from file://, using simple audio (no spatial effects)');
            spatialInitialized = false;
            return;
        }

        try {
            musicAudioCtx = new (window.AudioContext || window.webkitAudioContext)();

            // Create source from audio element
            const musicSource = musicAudioCtx.createMediaElementSource(bgMusic);

            // Low-pass filter - muffles highs like distant speakers
            const lowpass = musicAudioCtx.createBiquadFilter();
            lowpass.type = 'lowpass';
            lowpass.frequency.value = 3500; // Cut harsh highs
            lowpass.Q.value = 0.5;

            // High-pass filter - remove sub bass (small speakers)
            const highpass = musicAudioCtx.createBiquadFilter();
            highpass.type = 'highpass';
            highpass.frequency.value = 80; // Subtle tinny effect
            highpass.Q.value = 0.5;

            // Resonant mid boost - cheap speaker character
            const midBoost = musicAudioCtx.createBiquadFilter();
            midBoost.type = 'peaking';
            midBoost.frequency.value = 800;
            midBoost.Q.value = 1.0;
            midBoost.gain.value = 2;

            // Convolver for room reverb (large industrial space)
            const convolver = musicAudioCtx.createConvolver();
            const reverbLength = musicAudioCtx.sampleRate * 1.5; // 1.5 second reverb
            const impulse = musicAudioCtx.createBuffer(2, reverbLength, musicAudioCtx.sampleRate);

            for (let channel = 0; channel < 2; channel++) {
                const data = impulse.getChannelData(channel);
                for (let i = 0; i < reverbLength; i++) {
                    const t = i / reverbLength;
                    const decay = Math.pow(1 - t, 3);
                    data[i] = (Math.random() * 2 - 1) * decay * 0.5;
                }
            }
            convolver.buffer = impulse;

            // Dry/wet mix for reverb
            const dryGain = musicAudioCtx.createGain();
            const wetGain = musicAudioCtx.createGain();
            dryGain.gain.value = 0.7; // Direct sound
            wetGain.gain.value = 0.3; // Reverb

            // Master gain
            musicGainNode = musicAudioCtx.createGain();
            musicGainNode.gain.value = musicVol;

            // Connect: Source -> highpass -> lowpass -> midBoost -> split to dry/wet -> master
            musicSource.connect(highpass);
            highpass.connect(lowpass);
            lowpass.connect(midBoost);

            // Dry path
            midBoost.connect(dryGain);
            dryGain.connect(musicGainNode);

            // Wet path (reverb)
            midBoost.connect(convolver);
            convolver.connect(wetGain);
            wetGain.connect(musicGainNode);

            // Output
            musicGainNode.connect(musicAudioCtx.destination);

            spatialInitialized = true;
            console.log('Spatial audio initialized for rooftop speaker effect');

        } catch (e) {
            console.error('Spatial audio init failed:', e);
            // Fallback - just play normally
            spatialInitialized = false;
        }
    }

    // Initialize music - setup spatial audio BEFORE playing
    if (bgMusic) {
        let audioStarted = false;

        // First click/interaction initializes everything
        const startMusic = () => {
            if (audioStarted) return;

            // Try spatial audio first
            if (!spatialInitialized) {
                try {
                    initSpatialAudio();
                } catch (e) {
                    console.error('Spatial audio failed:', e);
                }
            }

            // Resume audio context if needed
            if (musicAudioCtx && musicAudioCtx.state === 'suspended') {
                musicAudioCtx.resume().catch(e => console.log('Resume failed:', e));
            }

            // Set volume based on whether spatial audio is active
            if (spatialInitialized && musicGainNode) {
                bgMusic.volume = 1.0; // Full volume to spatial processor
                musicGainNode.gain.value = isMusicMuted ? 0 : musicVol;
            } else {
                bgMusic.volume = isMusicMuted ? 0 : musicVol;
            }

            // Play the music
            bgMusic.play().then(() => {
                audioStarted = true;
                console.log('Music playing, spatial audio:', spatialInitialized);
            }).catch(e => {
                console.log('Music autoplay blocked, waiting for interaction');
            });
        };

        // Initial volume (will be adjusted when spatial audio initializes)
        bgMusic.volume = musicVol;

        // Try to start immediately
        startMusic();

        // Also try on any user interaction
        const onFirstInteraction = () => {
            startMusic();
        };
        document.addEventListener('click', onFirstInteraction, { once: true });
        document.addEventListener('keydown', onFirstInteraction, { once: true });

        // Debug: log audio element state
        bgMusic.addEventListener('error', (e) => {
            console.error('Audio error:', bgMusic.error);
        });
        bgMusic.addEventListener('canplay', () => {
            console.log('Audio can play');
        });
    }

    // Function to update music volume (used by slider)
    window.updateMusicVolume = function(vol, muted) {
        if (spatialInitialized && musicGainNode) {
            musicGainNode.gain.value = muted ? 0 : vol;
        } else if (bgMusic) {
            bgMusic.volume = muted ? 0 : vol;
        }
    };

    // Music volume slider
    if (musicSlider) {
        musicSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            musicVol = e.target.value / 100;
            window.updateMusicVolume(musicVol, isMusicMuted);
            if (musicValueDisplay) musicValueDisplay.textContent = e.target.value + '%';
            // Store for global access
            window.musicVolume = musicVol;
        });
        musicSlider.addEventListener('mousedown', (e) => e.stopPropagation());
        musicSlider.addEventListener('click', (e) => e.stopPropagation());
    }

    // SFX volume slider
    if (sfxSlider) {
        sfxSlider.addEventListener('input', (e) => {
            e.stopPropagation();
            sfxVol = e.target.value / 100;
            if (sfxValueDisplay) sfxValueDisplay.textContent = e.target.value + '%';
            // Store for global access - will be picked up by audio engine
            window.sfxVolume = sfxVol;
            window.sfxMuted = isSfxMuted;
        });
        sfxSlider.addEventListener('mousedown', (e) => e.stopPropagation());
        sfxSlider.addEventListener('click', (e) => e.stopPropagation());
    }

    // Stop propagation on entire audio settings panel
    const audioSettings = document.getElementById('audio-settings');
    if (audioSettings) {
        audioSettings.addEventListener('mousedown', (e) => e.stopPropagation());
        audioSettings.addEventListener('click', (e) => e.stopPropagation());
    }

    // In-game toggle buttons
    if (toggleMusicBtn) {
        toggleMusicBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            isMusicMuted = !isMusicMuted;
            window.updateMusicVolume(musicVol, isMusicMuted);
            toggleMusicBtn.classList.toggle('muted', isMusicMuted);
            toggleMusicBtn.innerHTML = isMusicMuted ? '&#128263;' : '&#9835;';
        });
    }

    if (toggleSfxBtn) {
        toggleSfxBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            isSfxMuted = !isSfxMuted;
            window.sfxMuted = isSfxMuted;
            toggleSfxBtn.classList.toggle('muted', isSfxMuted);
            toggleSfxBtn.innerHTML = isSfxMuted ? '&#128263;' : '&#128266;';
        });
    }

    // Store initial values globally
    window.musicVolume = musicVol;
    window.sfxVolume = sfxVol;
    window.sfxMuted = false;

    // Spawn floating particles
    const particleContainer = document.getElementById('menu-particles');
    if (particleContainer) {
        for (let i = 0; i < 30; i++) {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = Math.random() * 100 + '%';
            particle.style.animationDelay = Math.random() * 8 + 's';
            particle.style.animationDuration = (6 + Math.random() * 4) + 's';
            particleContainer.appendChild(particle);
        }
    }

    // Play button handler
    const playBtn = document.getElementById('play-btn');
    const mainMenu = document.getElementById('main-menu');

    function startGame() {
        if (mainMenu) {
            mainMenu.style.opacity = '0';
            mainMenu.style.transition = 'opacity 0.5s ease-out';
            setTimeout(() => {
                mainMenu.style.display = 'none';
            }, 500);
        }
        // Make sure music is playing
        if (bgMusic) bgMusic.play();
        document.body.requestPointerLock();
    }

    if (playBtn) {
        playBtn.addEventListener('click', startGame);
    }

    // Also start on any click when menu is visible (but not on controls)
    if (mainMenu) {
        mainMenu.addEventListener('click', (e) => {
            // Don't start if clicking audio controls
            if (e.target.closest('.audio-settings')) return;
            if (e.target.closest('.menu-btn')) return;
            if (e.target === mainMenu || e.target.closest('.menu-vignette') || e.target.closest('.menu-grid')) {
                startGame();
            }
        });
    }
})();

/**
 * MOTION DESIGN UTILS
 * Spring physics for procedural weight.
 */
// Enhanced Spring class with better physics simulation
class Spring {
    constructor(stiffness, damping, mass) {
        this.stiffness = stiffness;
        this.damping = damping;
        this.mass = mass;
        this.position = 0;
        this.velocity = 0;
        this.target = 0;
    }

    // Semi-implicit Euler for more stable, organic motion
    update(dt) {
        // Sub-step for stability if dt is too large (prevents explosion)
        const MAX_DT = 0.016; 
        let remainingDt = Math.min(dt, 0.1); // Cap input dt at 100ms

        while (remainingDt > 0) {
            const step = Math.min(remainingDt, MAX_DT);
            
            const displacement = this.position - this.target;
            const springForce = -this.stiffness * displacement;
            const dampingForce = -this.damping * this.velocity;
            const acceleration = (springForce + dampingForce) / this.mass;

            this.velocity += acceleration * step;
            this.position += this.velocity * step;
            
            remainingDt -= step;
        }

        // Safety clamp to prevent NaN propagation
        if (!Number.isFinite(this.position)) {
            this.position = this.target || 0;
            this.velocity = 0;
        }

        return this.position;
    }

    impulse(force) {
        this.velocity += force / this.mass;
    }

    // Smooth impulse over time for more organic feel
    softImpulse(force, smoothness = 0.5) {
        this.velocity += (force / this.mass) * smoothness;
        this.target += (force / this.mass) * (1 - smoothness) * 0.1;
    }
}

// Dual-spring system for extra organic lag
class DualSpring {
    constructor(primaryStiffness, primaryDamping, secondaryStiffness, secondaryDamping, mass) {
        this.primary = new Spring(primaryStiffness, primaryDamping, mass);
        this.secondary = new Spring(secondaryStiffness, secondaryDamping, mass * 1.5);
    }

    update(dt) {
        const primaryPos = this.primary.update(dt);
        this.secondary.target = primaryPos;
        return this.secondary.update(dt);
    }

    set target(val) { this.primary.target = val; }
    get target() { return this.primary.target; }

    impulse(force) {
        this.primary.impulse(force * 0.7);
        this.secondary.impulse(force * 0.3);
    }
}

// Separate springs for different axes - ULTRA FLUID & ORGANIC feel
const Springs = {
    // Gun sway - multi-layered for organic feel
    swayX: new Spring(65, 5, 1.4),       // Softer, more floaty
    swayY: new Spring(65, 5, 1.4),
    swayLagX: new Spring(30, 3.5, 1.8),  // More lag for fluidity
    swayLagY: new Spring(30, 3.5, 1.8),
    swayLag2X: new Spring(18, 2.5, 2.2), // Third layer of lag
    swayLag2Y: new Spring(18, 2.5, 2.2),

    // Recoil - snappy initial kick with soft follow-through
    recoilZ: new Spring(280, 14, 0.9),   // Quick snap back
    recoilX: new Spring(180, 9, 1.1),    // Muzzle climb - softer
    recoilY: new Spring(140, 8, 1.2),    // Vertical rise
    recoilRoll: new Spring(200, 12, 1),  // Rotational recoil

    // Recoil recovery (slower return to neutral)
    recoilRecoverZ: new Spring(40, 4, 2),
    recoilRecoverX: new Spring(35, 3.5, 2),

    // Movement feel - very organic
    bobY: new Spring(50, 4, 1.4),        // Floatier vertical bob
    bobX: new Spring(40, 3.5, 1.5),      // Side-to-side sway
    bobZ: new Spring(35, 3, 1.6),        // Forward/back bob (new)
    roll: new Spring(45, 4, 1.3),        // Hip roll
    tilt: new Spring(30, 3, 1.5),        // Forward lean

    // Momentum/inertia
    momentumX: new Spring(25, 2.5, 2),   // Weapon trails behind movement
    momentumZ: new Spring(25, 2.5, 2),

    // Breathing/idle - very subtle organic motion
    breathe: new Spring(15, 1.5, 2.5),   // Slow breathing
    idleSway: new Spring(8, 1, 3),       // Ultra slow idle drift
    heartbeat: new Spring(100, 8, 0.5),  // Subtle pulse

    // Screen shake - responsive but not jarring
    shakeX: new Spring(250, 16, 1),
    shakeY: new Spring(250, 16, 1),
    shakeRoll: new Spring(200, 14, 1),   // Rotational shake

    // Camera smoothing - cinematic lag
    camLagX: new Spring(80, 6, 1.2),
    camLagY: new Spring(80, 6, 1.2),

    // ADS transition smoothing
    adsTransition: new Spring(120, 10, 1),
    adsFov: new Spring(120, 22, 1.0), // Dedicated spring for FOV transitions - Damped for smoothness

    // Landing impact
    landing: new Spring(200, 15, 1),
    landingTilt: new Spring(150, 12, 1),

    // Sprinting effects
    sprintBob: new Spring(70, 5, 1.2),
    sprintTilt: new Spring(50, 4, 1.3),
    sprintRoll: new Spring(60, 4.5, 1.2),

    // === NEW: Attention to Detail Springs ===
    // Strafe lean - weapon and camera tilt when strafing
    strafeTilt: new Spring(80, 6, 1.2),
    strafeRoll: new Spring(60, 5, 1.3),

    // Velocity-based weapon drag (trails behind fast movements)
    velocityDragX: new Spring(40, 4, 1.5),
    velocityDragY: new Spring(40, 4, 1.5),

    // Turn inertia - weapon lags when spinning camera fast
    turnLagX: new Spring(50, 4.5, 1.4),
    turnLagY: new Spring(50, 4.5, 1.4),

    // Weapon inspection sway
    inspectRotX: new Spring(25, 3, 2),
    inspectRotY: new Spring(25, 3, 2),
    inspectRotZ: new Spring(20, 2.5, 2),

    // Bolt carrier
    boltZ: new Spring(400, 18, 0.8),

    // Dynamic crosshair
    crosshairSpread: new Spring(120, 10, 1)
};

// Velocity tracking for inertia effects
let lastCamYaw = 0;
let lastCamPitch = 0;
let camVelX = 0;
let camVelY = 0;
let moveVelSmooth = 0;
let moveVelX = 0;
let moveVelZ = 0;

// === NEW: Attention to Detail State ===
let lastStrafeInput = 0;
let idleTime = 0;                    // Time since last movement/action
let isInspecting = false;            // Weapon inspection mode
let inspectPhase = 0;                // Phase of inspection animation
let lastFireTime = 0;                // For muzzle smoke timing
let consecutiveShots = 0;            // For heat buildup
let crosshairBaseSize = 20;          // Base crosshair size
let crosshairCurrentSize = 20;       // Current crosshair size
let lastDamageDir = null;            // Direction of last damage taken
let damageIndicatorAlpha = 0;        // Fade for damage indicator
let lowHealthPulse = 0;              // Pulse phase for low health effects

// Organic noise for idle animations
function organicNoise(time, frequency, octaves = 3) {
    let value = 0;
    let amplitude = 1;
    let freq = frequency;
    for (let i = 0; i < octaves; i++) {
        value += Math.sin(time * freq) * amplitude;
        value += Math.cos(time * freq * 1.3) * amplitude * 0.5;
        freq *= 2.1;
        amplitude *= 0.5;
    }
    return value;
}

/**
 * CUSTOM POST-PROCESSING SHADERS
 */
const VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        intensity: { value: 0.4 },
        smoothness: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float intensity;
        uniform float smoothness;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 center = vUv - 0.5;
            float dist = length(center);
            float vignette = smoothstep(0.5, 0.5 - smoothness, dist * (intensity + 0.5));
            color.rgb *= vignette;
            gl_FragColor = color;
        }
    `
};

const ChromaticAberrationShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
    `
};

const FilmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.03 },
        speed: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        varying vec2 vUv;

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float grain = random(vUv + time) * 2.0 - 1.0;
            color.rgb += grain * intensity;
            gl_FragColor = color;
        }
    `
};

const MotionBlurShader = {
    uniforms: {
        tDiffuse: { value: null },
        velocityX: { value: 0.0 },
        velocityY: { value: 0.0 },
        samples: { value: 4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float velocityX;
        uniform float velocityY;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 velocity = vec2(velocityX, velocityY);
            float speed = length(velocity);

            if (speed < 0.001) {
                gl_FragColor = texture2D(tDiffuse, vUv);
                return;
            }

            vec2 dir = velocity / speed;
            vec4 color = vec4(0.0);
            float total = 0.0;

            for (float i = 0.0; i < 16.0; i++) {
                if (i >= samples) break;
                float t = (i / (samples - 1.0)) - 0.5;
                vec2 offset = dir * t * speed;
                float weight = 1.0 - abs(t * 2.0);
                color += texture2D(tDiffuse, vUv + offset) * weight;
                total += weight;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ SSAO (Screen Space Ambient Occlusion) ============
const SSAOShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        radius: { value: 0.5 },
        aoStrength: { value: 1.2 },
        falloff: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float radius;
        uniform float aoStrength;
        uniform float falloff;
        varying vec2 vUv;

        float readDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = (cameraNear * cameraFar) / ((cameraFar - cameraNear) * fragCoordZ - cameraFar);
            return viewZ;
        }

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = readDepth(vUv);

            if (depth > -1.0) {
                gl_FragColor = color;
                return;
            }

            float ao = 0.0;
            float sampleRadius = radius / abs(depth);

            const int samples = 16;
            for (int i = 0; i < samples; i++) {
                float angle = float(i) * 2.39996322973;
                float r = sampleRadius * (float(i + 1) / float(samples));
                vec2 offset = vec2(cos(angle), sin(angle)) * r;
                offset += (vec2(random(vUv + float(i)), random(vUv - float(i))) - 0.5) * sampleRadius * 0.25;

                float sampleDepth = readDepth(vUv + offset);
                float rangeCheck = smoothstep(0.0, 1.0, falloff / abs(depth - sampleDepth));
                ao += (sampleDepth > depth + 0.01 ? 1.0 : 0.0) * rangeCheck;
            }

            ao = 1.0 - (ao / float(samples)) * aoStrength;
            ao = clamp(ao, 0.0, 1.0);

            color.rgb *= ao;
            gl_FragColor = color;
        }
    `
};

// ============ VOLUMETRIC GOD RAYS ============
const GodRaysShader = {
    uniforms: {
        tDiffuse: { value: null },
        lightPositionOnScreen: { value: new THREE.Vector2(0.3, 0.7) },
        exposure: { value: 0.35 },
        decay: { value: 0.96 },
        density: { value: 0.8 },
        weight: { value: 0.6 },
        samples: { value: 60 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPositionOnScreen;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 texCoord = vUv;
            vec2 deltaTexCoord = texCoord - lightPositionOnScreen;
            deltaTexCoord *= 1.0 / samples * density;

            vec4 color = texture2D(tDiffuse, texCoord);
            float illuminationDecay = 1.0;
            vec4 accumulatedColor = vec4(0.0);

            for (int i = 0; i < 100; i++) {
                if (float(i) >= samples) break;
                texCoord -= deltaTexCoord;
                vec4 sampleColor = texture2D(tDiffuse, texCoord);
                float luminance = dot(sampleColor.rgb, vec3(0.299, 0.587, 0.114));
                sampleColor *= illuminationDecay * weight * luminance;
                accumulatedColor += sampleColor;
                illuminationDecay *= decay;
            }

            accumulatedColor *= exposure;
            accumulatedColor.rgb = clamp(accumulatedColor.rgb, 0.0, 1.0);

            gl_FragColor = color + accumulatedColor * vec4(1.0, 0.9, 0.7, 1.0);
        }
    `
};

// ============ DEPTH OF FIELD (Bokeh) ============
const DepthOfFieldShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        focusDistance: { value: 10.0 },
        focusRange: { value: 5.0 },
        bokehStrength: { value: 2.0 },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float focusDistance;
        uniform float focusRange;
        uniform float bokehStrength;
        uniform float cameraNear;
        uniform float cameraFar;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            float depth = getDepth(vUv);
            float blur = abs(depth - focusDistance) / focusRange;
            blur = clamp(blur * bokehStrength, 0.0, 1.0);

            vec2 texelSize = 1.0 / resolution;
            vec4 color = vec4(0.0);
            float total = 0.0;

            // Hexagonal bokeh pattern
            const int SAMPLES = 36;
            for (int i = 0; i < SAMPLES; i++) {
                float angle = float(i) * 6.28318530718 / float(SAMPLES);
                float dist = blur * 8.0 * (0.5 + 0.5 * fract(float(i) * 0.618));
                vec2 offset = vec2(cos(angle), sin(angle)) * texelSize * dist;
                color += texture2D(tDiffuse, vUv + offset);
                total += 1.0;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ LENS FLARE SHADER ============
const LensFlareShader = {
    uniforms: {
        tDiffuse: { value: null },
        sunPosition: { value: new THREE.Vector2(0.3, 0.7) },
        sunVisible: { value: 1.0 },
        flareStrength: { value: 0.4 },
        ghostStrength: { value: 0.3 },
        haloStrength: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 sunPosition;
        uniform float sunVisible;
        uniform float flareStrength;
        uniform float ghostStrength;
        uniform float haloStrength;
        varying vec2 vUv;

        vec3 flareColor(float t) {
            return mix(vec3(1.0, 0.6, 0.3), vec3(1.0, 0.9, 0.6), t);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            if (sunVisible < 0.01) {
                gl_FragColor = color;
                return;
            }

            vec2 sunToCenter = vec2(0.5) - sunPosition;
            vec2 flareVector = sunToCenter;

            // Main sun glow
            float distToSun = length(vUv - sunPosition);
            float glow = exp(-distToSun * 4.0) * flareStrength * sunVisible;
            color.rgb += flareColor(0.0) * glow;

            // Ghost flares (reflections along the flare vector)
            for (int i = 1; i < 6; i++) {
                float t = float(i) / 6.0;
                vec2 ghostPos = sunPosition + flareVector * (0.3 + t * 1.4);
                float ghostDist = length(vUv - ghostPos);
                float ghostSize = 0.05 + t * 0.03;
                float ghost = smoothstep(ghostSize, 0.0, ghostDist) * ghostStrength * sunVisible;
                ghost *= (1.0 - t * 0.5);
                color.rgb += flareColor(t) * ghost * 0.5;
            }

            // Halo ring
            float haloDist = abs(length(vUv - sunPosition) - 0.25);
            float halo = smoothstep(0.02, 0.0, haloDist) * haloStrength * sunVisible * 0.3;
            color.rgb += vec3(1.0, 0.8, 0.5) * halo;

            // Anamorphic streak
            float streakX = exp(-abs(vUv.y - sunPosition.y) * 30.0) * exp(-abs(vUv.x - sunPosition.x) * 2.0);
            color.rgb += vec3(1.0, 0.7, 0.4) * streakX * flareStrength * sunVisible * 0.3;

            gl_FragColor = color;
        }
    `
};

// ============ HEAT DISTORTION / HAZE ============
const HeatDistortionShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        distortionStrength: { value: 0.003 },
        heatLine: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float distortionStrength;
        uniform float heatLine;
        varying vec2 vUv;

        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);

            float a = noise(i);
            float b = noise(i + vec2(1.0, 0.0));
            float c = noise(i + vec2(0.0, 1.0));
            float d = noise(i + vec2(1.0, 1.0));

            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        void main() {
            // Heat distortion strongest near bottom of screen (ground level)
            float heatMask = smoothstep(heatLine + 0.15, heatLine, vUv.y);

            // Multi-octave noise for realistic heat waves
            float n1 = smoothNoise(vUv * 20.0 + vec2(time * 0.5, time * 0.3));
            float n2 = smoothNoise(vUv * 40.0 + vec2(-time * 0.3, time * 0.5));
            float n3 = smoothNoise(vUv * 80.0 + vec2(time * 0.4, -time * 0.2));

            float distortion = (n1 * 0.5 + n2 * 0.3 + n3 * 0.2) * 2.0 - 1.0;

            vec2 offset = vec2(distortion, distortion * 0.5) * distortionStrength * heatMask;

            vec4 color = texture2D(tDiffuse, vUv + offset);

            gl_FragColor = color;
        }
    `
};

// ============ COLOR GRADING / LUT ============
const ColorGradingShader = {
    uniforms: {
        tDiffuse: { value: null },
        contrast: { value: 1.15 },
        saturation: { value: 1.2 },
        brightness: { value: 1.0 },
        // Shadows, midtones, highlights color adjustments
        shadowColor: { value: new THREE.Vector3(0.1, 0.05, 0.15) },
        midtoneColor: { value: new THREE.Vector3(1.0, 0.95, 0.9) },
        highlightColor: { value: new THREE.Vector3(1.0, 0.9, 0.8) },
        // Lift, gamma, gain (standard color grading)
        lift: { value: new THREE.Vector3(0.0, 0.0, 0.02) },
        gamma: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
        gain: { value: new THREE.Vector3(1.0, 0.98, 0.95) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float contrast;
        uniform float saturation;
        uniform float brightness;
        uniform vec3 shadowColor;
        uniform vec3 midtoneColor;
        uniform vec3 highlightColor;
        uniform vec3 lift;
        uniform vec3 gamma;
        uniform vec3 gain;
        varying vec2 vUv;

        vec3 adjustSaturation(vec3 color, float sat) {
            float luma = dot(color, vec3(0.299, 0.587, 0.114));
            return mix(vec3(luma), color, sat);
        }

        vec3 adjustContrast(vec3 color, float con) {
            return (color - 0.5) * con + 0.5;
        }

        vec3 liftGammaGain(vec3 color, vec3 lift, vec3 gamma, vec3 gain) {
            vec3 lerpV = clamp(pow(color, 1.0 / gamma), 0.0, 1.0);
            return gain * lerpV + lift * (1.0 - lerpV);
        }

        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            vec3 color = texel.rgb;

            // Brightness
            color *= brightness;

            // Contrast
            color = adjustContrast(color, contrast);

            // Saturation
            color = adjustSaturation(color, saturation);

            // Lift/Gamma/Gain
            color = liftGammaGain(color, lift, gamma, gain);

            // Color tinting based on luminance
            float luma = dot(color, vec3(0.299, 0.587, 0.114));

            // Shadow tint (dark areas get cool/purple tint)
            float shadowMask = 1.0 - smoothstep(0.0, 0.3, luma);
            color = mix(color, color * shadowColor * 3.0, shadowMask * 0.3);

            // Highlight tint (bright areas get warm tint)
            float highlightMask = smoothstep(0.6, 1.0, luma);
            color = mix(color, color * highlightColor, highlightMask * 0.4);

            // Midtone tint
            float midtoneMask = 1.0 - abs(luma - 0.5) * 2.0;
            color *= mix(vec3(1.0), midtoneColor, midtoneMask * 0.2);

            gl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);
        }
    `
};

// ============ SCREEN SPACE REFLECTIONS (Simplified) ============
const SSRShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        reflectionStrength: { value: 0.3 },
        groundLevel: { value: 0.25 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float reflectionStrength;
        uniform float groundLevel;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Only apply reflections near ground level (bottom portion of screen)
            float reflectionMask = smoothstep(groundLevel + 0.1, groundLevel, vUv.y);

            if (reflectionMask > 0.01) {
                // Mirror UV for reflection
                vec2 reflectedUv = vec2(vUv.x, groundLevel + (groundLevel - vUv.y));

                if (reflectedUv.y >= 0.0 && reflectedUv.y <= 1.0) {
                    vec4 reflectedColor = texture2D(tDiffuse, reflectedUv);

                    // Fade reflection based on distance from ground
                    float fadeFactor = 1.0 - abs(vUv.y - groundLevel) * 4.0;
                    fadeFactor = clamp(fadeFactor, 0.0, 1.0);

                    // Blend with roughness simulation (blur)
                    float blur = (groundLevel - vUv.y) * 0.05;
                    vec4 blurredReflection = vec4(0.0);
                    float total = 0.0;
                    for (int i = -2; i <= 2; i++) {
                        for (int j = -2; j <= 2; j++) {
                            vec2 offset = vec2(float(i), float(j)) * blur;
                            blurredReflection += texture2D(tDiffuse, reflectedUv + offset);
                            total += 1.0;
                        }
                    }
                    reflectedColor = blurredReflection / total;

                    color.rgb = mix(color.rgb, reflectedColor.rgb, reflectionMask * reflectionStrength * fadeFactor);
                }
            }

            gl_FragColor = color;
        }
    `
};

// ============ ATMOSPHERIC SCATTERING ============
const AtmosphericScatteringShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        fogColor: { value: new THREE.Vector3(0.4, 0.2, 0.15) },
        fogDensity: { value: 0.015 },
        sunDirection: { value: new THREE.Vector3(-0.5, 0.2, -0.8) },
        sunColor: { value: new THREE.Vector3(1.0, 0.7, 0.4) },
        scatteringStrength: { value: 0.4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform vec3 fogColor;
        uniform float fogDensity;
        uniform vec3 sunDirection;
        uniform vec3 sunColor;
        uniform float scatteringStrength;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = getDepth(vUv);

            // Exponential fog
            float fogAmount = 1.0 - exp(-depth * fogDensity);
            fogAmount = clamp(fogAmount, 0.0, 1.0);

            // Add sun scattering based on view direction approximation
            vec2 screenCenter = vUv - 0.5;
            float viewSunDot = dot(normalize(vec3(screenCenter, 1.0)), normalize(sunDirection));
            viewSunDot = max(viewSunDot, 0.0);

            // Mie scattering (forward scattering from sun)
            float mie = pow(viewSunDot, 8.0) * scatteringStrength;

            vec3 scatterColor = mix(fogColor, sunColor, mie);

            color.rgb = mix(color.rgb, scatterColor, fogAmount);
            color.rgb += sunColor * mie * 0.2 * (1.0 - fogAmount);

            gl_FragColor = color;
        }
    `
};

// ============ CEL SHADING (Borderlands Style) ============
const CelShadingShader = {
    uniforms: {
        tDiffuse: { value: null },
        levels: { value: 4.0 },        // Number of color bands
        edgeIntensity: { value: 0.3 }, // How much to darken edges
        saturationBoost: { value: 1.2 } // Boost colors slightly
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float levels;
        uniform float edgeIntensity;
        uniform float saturationBoost;
        varying vec2 vUv;

        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Convert to HSV for better banding
            vec3 hsv = rgb2hsv(color.rgb);

            // Quantize value (brightness) into discrete levels
            float quantized = floor(hsv.z * levels + 0.5) / levels;

            // Boost saturation for that Borderlands pop
            hsv.y = min(hsv.y * saturationBoost, 1.0);
            hsv.z = quantized;

            // Convert back to RGB
            vec3 cel = hsv2rgb(hsv);

            gl_FragColor = vec4(cel, color.a);
        }
    `
};

const OutlineShader = {
    uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        outlineColor: { value: new THREE.Vector3(0.0, 0.0, 0.0) },
        thickness: { value: 1.0 },
        threshold: { value: 0.15 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform vec3 outlineColor;
        uniform float thickness;
        uniform float threshold;
        varying vec2 vUv;

        float luminance(vec3 color) {
            return dot(color, vec3(0.299, 0.587, 0.114));
        }

        void main() {
            vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y) * thickness;

            // Sample surrounding pixels (Sobel operator)
            float tl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, texel.y)).rgb);
            float t  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, texel.y)).rgb);
            float tr = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, texel.y)).rgb);
            float l  = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, 0.0)).rgb);
            float r  = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, 0.0)).rgb);
            float bl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, -texel.y)).rgb);
            float b  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, -texel.y)).rgb);
            float br = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, -texel.y)).rgb);

            // Sobel edge detection
            float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
            float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
            float edge = sqrt(gx*gx + gy*gy);

            vec4 color = texture2D(tDiffuse, vUv);

            // Apply outline where edges are detected
            if (edge > threshold) {
                // Blend toward outline color based on edge strength
                float blend = smoothstep(threshold, threshold + 0.1, edge);
                color.rgb = mix(color.rgb, outlineColor, blend * 0.9);
            }

            gl_FragColor = color;
        }
    `
};

// Dynamic post-processing values
let bloomIntensity = 0.15; // Warm sunset glow
let chromaticAmount = 0.0005;
let motionBlurX = 0.0;
let motionBlurY = 0.0;

// ============ PERFORMANCE: OBJECT POOLING ============
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = [];
        // Pre-allocate
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
        }
    }

    get() {
        let obj = this.pool.pop() || this.createFn();
        this.active.push(obj);
        return obj;
    }

    release(obj) {
        const idx = this.active.indexOf(obj);
        if (idx > -1) {
            this.active.splice(idx, 1);
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }

    releaseAll() {
        while (this.active.length > 0) {
            const obj = this.active.pop();
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }
}

// ============ INSTANCED PARTICLE SYSTEM ============
const MAX_BLOOD_PARTICLES = 120; // Reduced for performance
const MAX_SPARKS = 60; // Reduced for performance
const MAX_DEBRIS = 40; // Reduced for performance

// Reusable matrix and vectors for instanced updates
const _instanceMatrix = new THREE.Matrix4();
const _instancePos = new THREE.Vector3();
const _instanceQuat = new THREE.Quaternion();
const _instanceScale = new THREE.Vector3(1, 1, 1);
const _tempVec3 = new THREE.Vector3();

// Frame throttling for expensive operations
let frameCount = 0;
const SHADOW_UPDATE_INTERVAL = 3; // Update shadows every 3 frames
const HUD_UPDATE_INTERVAL = 2; // Update HUD every 2 frames
let lastHUDValues = { ammo: -1, reserve: -1, health: -1, score: -1, wave: -1 };

// Cached DOM references
let cachedDOM = null;
function getCachedDOM() {
    if (!cachedDOM) {
        cachedDOM = {
            ammoDisplay: document.getElementById('ammo-display'),
            healthFill: document.getElementById('health-fill'),
            healthText: document.getElementById('health-text'),
            waveDisplay: document.getElementById('wave-display'),
            zombieCount: document.getElementById('zombie-count'),
            scoreDisplay: document.getElementById('score-display'),
            damageFlash: document.getElementById('damage-flash')
        };
    }
    return cachedDOM;
}

/**
 * TEXTURE FACTORY
 */
const TextureFactory = {
    createCanvas: (size) => {
        const c = document.createElement('canvas');
        c.width = c.height = size;
        return { c, ctx: c.getContext('2d') };
    },
    
    noise: (ctx, w, h, opacity) => {
        const idata = ctx.getImageData(0,0,w,h);
        const data = idata.data;
        for(let i=0; i<data.length; i+=4) {
            const v = Math.random() * 255 * opacity;
            data[i] += v; data[i+1] += v; data[i+2] += v;
        }
        ctx.putImageData(idata, 0, 0);
    },

    wood: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.3;
        for(let i=0; i<150; i++) {
            ctx.strokeStyle = i%2===0 ? '#5d4037' : '#281a14';
            ctx.lineWidth = 1 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(0, Math.random()*size);
            ctx.bezierCurveTo(size/3, Math.random()*size, size*2/3, Math.random()*size, size, Math.random()*size);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.1);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    metal: (isDark) => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = isDark ? '#1a1a1a' : '#555555'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.1; ctx.strokeStyle = '#ffffff';
        for(let i=0; i<400; i++) {
            ctx.lineWidth = 0.5; ctx.beginPath();
            const x = Math.random()*size; const y = Math.random()*size;
            ctx.moveTo(x, y); ctx.lineTo(x + (Math.random()-0.5)*50, y + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.05);
        return new THREE.CanvasTexture(c);
    },

    concrete: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#888888'; ctx.fillRect(0,0,size,size);
        //Heavy noise for aggregate
        TextureFactory.noise(ctx, size, size, 0.4); 
        // Cracks
        ctx.strokeStyle = '#444444'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        for(let i=0; i<20; i++) {
             ctx.beginPath(); ctx.moveTo(Math.random()*size, Math.random()*size);
             for(let j=0; j<5; j++) ctx.lineTo(Math.random()*size, Math.random()*size);
             ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 20);
        return tex;
    },

    brick: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#301510'; ctx.fillRect(0,0,size,size); // Grout
        ctx.fillStyle = '#56302a'; // Brick color
        const brickW = 64; const brickH = 32;
        for(let y=0; y<size; y+=brickH+2) {
            const offset = (y/(brickH+2))%2 === 0 ? 0 : brickW/2;
            for(let x=-brickW; x<size; x+=brickW+2) {
                ctx.fillRect(x+offset, y, brickW, brickH);
            }
        }
        TextureFactory.noise(ctx, size, size, 0.2);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 5);
        return tex;
    },

    grid: () => {
        const size = 1024;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#080808'; ctx.fillRect(0,0,size,size); // Darker floor
        TextureFactory.noise(ctx, size, size, 0.2);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.globalAlpha = 1.0;
        const step = 128; // Bigger grid
        for(let i=0; i<=size; i+=step) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(size,i); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(50, 50);
        return tex;
    },

    // Procedural Bullet Hole
    impact: () => {
        const size = 128;
        const { c, ctx } = TextureFactory.createCanvas(size);
        // Alpha mask
        ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.clearRect(0,0,size,size);
        
        // Cracks
        ctx.beginPath();
        ctx.arc(64,64, 20, 0, Math.PI*2);
        ctx.fillStyle = '#050505'; ctx.fill();
        
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        for(let i=0; i<12; i++) {
            ctx.beginPath(); ctx.moveTo(64,64);
            ctx.lineTo(64 + Math.cos(i)*40 + (Math.random()-0.5)*10, 64 + Math.sin(i)*40 + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(c);
    }
};

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

// Master SFX volume control
const masterSfxGain = actx.createGain();
masterSfxGain.gain.value = 0.7; // Default 70%
masterSfxGain.connect(actx.destination);

// Improved Reverb
const convolver = actx.createConvolver();
const dryGain = actx.createGain();
const wetGain = actx.createGain();
dryGain.connect(masterSfxGain);
wetGain.connect(masterSfxGain);
wetGain.gain.value = 0.3; // Tighter reverb

// Global audio settings
let sfxVolume = 0.7;
let musicVolume = 0.5;
let sfxMuted = false;
let musicMuted = false;

/**
 * SLOW-MOTION SYSTEM
 * Cinematic slowmo for last kills of each wave
 */
let timeScale = 1.0;
let targetTimeScale = 1.0;
let slowmoActive = false;
let slowmoTimer = 0;
const SLOWMO_DURATION = 1.5; // How long slowmo lasts
const SLOWMO_MIN = 0.15; // Minimum time scale (0.15 = 15% speed)
const SLOWMO_RAMP_SPEED = 3.0; // How fast to return to normal

// Music pitch control for slowmo
let currentMusicPitch = 1.0;
let targetMusicPitch = 1.0;
const MUSIC_PITCH_MIN = 0.5; // Drop to 50% pitch in slowmo (one octave down-ish)
const MUSIC_PITCH_DOWN_SPEED = 8.0; // Fast drop into slowmo
const MUSIC_PITCH_UP_SPEED = 2.5; // Slower recovery for dramatic effect

function triggerSlowmo() {
    if (slowmoActive) return;
    slowmoActive = true;
    slowmoTimer = SLOWMO_DURATION;
    targetTimeScale = SLOWMO_MIN;
    timeScale = SLOWMO_MIN; // Instant slowdown for impact

    // Visual effects
    const overlay = document.getElementById('slowmo-overlay');
    const text = document.getElementById('slowmo-text');
    if (overlay) overlay.classList.add('active');
    if (text) text.classList.add('show');

    // Set target music pitch for smooth transition
    targetMusicPitch = MUSIC_PITCH_MIN;

    playSound('waveComplete');
}

// Extended bullet time from power-up (longer duration, different text)
function triggerPowerupSlowmo() {
    slowmoActive = true;
    slowmoTimer = 5.0; // 5 seconds of bullet time
    targetTimeScale = 0.2; // Slightly faster than wave-end slowmo
    timeScale = 0.2;

    // Visual effects
    const overlay = document.getElementById('slowmo-overlay');
    const text = document.getElementById('slowmo-text');
    if (overlay) overlay.classList.add('active');
    if (text) {
        text.textContent = 'BULLET TIME';
        text.classList.add('show');
    }

    // Set target music pitch
    targetMusicPitch = MUSIC_PITCH_MIN;

    playSound('waveComplete');
}

function updateSlowmo(realDt) {
    // Always update music pitch smoothly (even when not in slowmo for recovery)
    const bgMusic = document.getElementById('bg-music');
    if (bgMusic) {
        if (currentMusicPitch !== targetMusicPitch) {
            const pitchSpeed = targetMusicPitch < currentMusicPitch ? MUSIC_PITCH_DOWN_SPEED : MUSIC_PITCH_UP_SPEED;
            const pitchDiff = targetMusicPitch - currentMusicPitch;
            const pitchStep = pitchSpeed * realDt;

            if (Math.abs(pitchDiff) <= pitchStep) {
                currentMusicPitch = targetMusicPitch;
            } else {
                currentMusicPitch += Math.sign(pitchDiff) * pitchStep;
            }

            // Apply with slight smoothing to avoid audio artifacts
            bgMusic.playbackRate = currentMusicPitch;
        }
    }

    if (!slowmoActive) return;

    slowmoTimer -= realDt;

    if (slowmoTimer <= 0) {
        // Ramp back to normal speed
        targetTimeScale = 1.0;
        timeScale += SLOWMO_RAMP_SPEED * realDt;

        // Start ramping music pitch back up
        targetMusicPitch = 1.0;

        if (timeScale >= 1.0) {
            timeScale = 1.0;
            slowmoActive = false;

            // Remove visual effects
            const overlay = document.getElementById('slowmo-overlay');
            const text = document.getElementById('slowmo-text');
            if (overlay) overlay.classList.remove('active');
            if (text) text.classList.remove('show');
        }
    }
}

function isLastZombieOfWave() {
    // Check if we just killed the last zombie of the current wave
    return zombiesKilledThisWave >= zombiesThisWave && zombiesThisWave > 0 && waveInProgress;
}

const sampleRate = actx.sampleRate;
const length = sampleRate * 1.0; // Short, slap-back reverb
const impulse = actx.createBuffer(2, length, sampleRate);
for (let channel = 0; channel < 2; channel++) {
    const data = impulse.getChannelData(channel);
    for (let i = 0; i < length; i++) {
        // Exponential decay for metallic room sound
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 6);
    }
}
convolver.buffer = impulse;
convolver.connect(wetGain);

function playSound(type) {
    // Check if SFX is muted
    if (window.sfxMuted) return;

    // Update master volume from global setting
    if (typeof window.sfxVolume === 'number') {
        masterSfxGain.gain.value = window.sfxVolume;
    }

    if (actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(dryGain);
    gain.connect(convolver);

    const now = actx.currentTime;

    if (type === 'shoot') {
        // BEEFY AK-47 SOUND - Maximum oomph

        // Layer 1: DEEP bass thump (chest punch)
        const bassOsc = actx.createOscillator();
        const bassGain = actx.createGain();
        const bassFilter = actx.createBiquadFilter();
        bassOsc.connect(bassFilter);
        bassFilter.connect(bassGain);
        bassGain.connect(dryGain);
        bassOsc.type = 'sine';
        bassOsc.frequency.setValueAtTime(60, now);
        bassOsc.frequency.exponentialRampToValueAtTime(25, now + 0.12);
        bassFilter.type = 'lowpass';
        bassFilter.frequency.value = 150;
        bassGain.gain.setValueAtTime(1.2, now);
        bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        bassOsc.start(now); bassOsc.stop(now + 0.2);

        // Layer 2: Mid punch (body of the shot)
        const midOsc = actx.createOscillator();
        const midGain = actx.createGain();
        midOsc.connect(midGain);
        midGain.connect(dryGain);
        midGain.connect(convolver);
        midOsc.type = 'sawtooth';
        midOsc.frequency.setValueAtTime(120, now);
        midOsc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        midGain.gain.setValueAtTime(0.7, now);
        midGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        midOsc.start(now); midOsc.stop(now + 0.15);

        // Layer 3: Sharp transient crack (the snap)
        const crackBuf = actx.createBuffer(1, actx.sampleRate * 0.05, actx.sampleRate);
        const crackData = crackBuf.getChannelData(0);
        for (let i = 0; i < crackBuf.length; i++) {
            const t = i / actx.sampleRate;
            crackData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 80) * 1.5;
        }
        const crackSrc = actx.createBufferSource();
        crackSrc.buffer = crackBuf;
        const crackFilter = actx.createBiquadFilter();
        crackFilter.type = 'highpass';
        crackFilter.frequency.value = 2000;
        const crackGain = actx.createGain();
        crackGain.gain.value = 0.9;
        crackSrc.connect(crackFilter);
        crackFilter.connect(crackGain);
        crackGain.connect(dryGain);
        crackSrc.start(now);

        // Layer 4: Explosion noise (the boom)
        const boomBuf = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const boomData = boomBuf.getChannelData(0);
        for (let i = 0; i < boomBuf.length; i++) {
            const t = i / actx.sampleRate;
            boomData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * 0.8;
        }
        const boomSrc = actx.createBufferSource();
        boomSrc.buffer = boomBuf;
        const boomFilter = actx.createBiquadFilter();
        boomFilter.type = 'bandpass';
        boomFilter.frequency.value = 800;
        boomFilter.Q.value = 0.5;
        const boomGain = actx.createGain();
        boomGain.gain.setValueAtTime(1.0, now);
        boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        boomSrc.connect(boomFilter);
        boomFilter.connect(boomGain);
        boomGain.connect(dryGain);
        boomGain.connect(convolver);
        boomSrc.start(now);

        // Layer 5: Mechanical clack (bolt action)
        const clackOsc = actx.createOscillator();
        const clackGain = actx.createGain();
        clackOsc.connect(clackGain);
        clackGain.connect(dryGain);
        clackOsc.type = 'square';
        clackOsc.frequency.setValueAtTime(1500, now + 0.015);
        clackOsc.frequency.exponentialRampToValueAtTime(800, now + 0.03);
        clackGain.gain.setValueAtTime(0.2, now + 0.015);
        clackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
        clackOsc.start(now + 0.015); clackOsc.stop(now + 0.05);

        // Layer 6: Sub-bass rumble (feel it in your chest)
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(35, now);
        subOsc.frequency.exponentialRampToValueAtTime(20, now + 0.1);
        subGain.gain.setValueAtTime(0.8, now);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        subOsc.start(now); subOsc.stop(now + 0.15);

        return;

    } else if (type === 'targetHit') {
        // Metallic ping/clang for hitting target
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1000, now);
        filter.Q.value = 5;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add metallic noise
        const hitBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const hitOut = hitBuf.getChannelData(0);
        for (let i = 0; i < hitBuf.length; i++) hitOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.02));
        const hitN = actx.createBufferSource(); hitN.buffer = hitBuf;
        const hitG = actx.createGain();
        hitG.gain.setValueAtTime(0.3, now);
        hitG.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        hitN.connect(hitG); hitG.connect(dryGain);
        hitN.start(now);

    } else if (type === 'zombieHit') {
        // Fleshy impact sound for zombie hits
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.1);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Thwack noise layer
        const thwackBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const thwackOut = thwackBuf.getChannelData(0);
        for (let i = 0; i < thwackBuf.length; i++) {
            thwackOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.015));
        }
        const thwackN = actx.createBufferSource(); thwackN.buffer = thwackBuf;
        const thwackFilter = actx.createBiquadFilter();
        thwackFilter.type = 'bandpass'; thwackFilter.frequency.value = 800; thwackFilter.Q.value = 1;
        const thwackG = actx.createGain();
        thwackG.gain.setValueAtTime(0.4, now);
        thwackN.connect(thwackFilter); thwackFilter.connect(thwackG);
        thwackG.connect(dryGain);
        thwackN.start(now);

    } else if (type === 'zombieDeath') {
        // Zombie death groan
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
        filter.type = 'lowpass';
        filter.frequency.value = 250;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.start(now); osc.stop(now + 0.5);

        // Body fall thud
        const thudOsc = actx.createOscillator();
        const thudGain = actx.createGain();
        thudOsc.connect(thudGain); thudGain.connect(dryGain); thudGain.connect(convolver);
        thudOsc.type = 'sine';
        thudOsc.frequency.setValueAtTime(80, now + 0.2);
        thudOsc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
        thudGain.gain.setValueAtTime(0.6, now + 0.2);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        thudOsc.start(now + 0.2); thudOsc.stop(now + 0.55);

    } else if (type === 'zombieAttack') {
        // Zombie growl/bite sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.25);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add snarl noise
        const snarlBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const snarlOut = snarlBuf.getChannelData(0);
        for (let i = 0; i < snarlBuf.length; i++) {
            snarlOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.05)) * 0.5;
        }
        const snarlN = actx.createBufferSource(); snarlN.buffer = snarlBuf;
        const snarlFilter = actx.createBiquadFilter();
        snarlFilter.type = 'bandpass'; snarlFilter.frequency.value = 300; snarlFilter.Q.value = 2;
        const snarlG = actx.createGain();
        snarlG.gain.setValueAtTime(0.3, now);
        snarlN.connect(snarlFilter); snarlFilter.connect(snarlG);
        snarlG.connect(dryGain);
        snarlN.start(now);

    } else if (type === 'headshot') {
        // SATISFYING head explosion sound - wet pop + crunch
        // Initial pop
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Wet splatter noise
        const splatBuf = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const splatOut = splatBuf.getChannelData(0);
        for (let i = 0; i < splatBuf.length; i++) {
            const t = i / actx.sampleRate;
            splatOut[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * 0.8;
        }
        const splatN = actx.createBufferSource(); splatN.buffer = splatBuf;
        const splatFilter = actx.createBiquadFilter();
        splatFilter.type = 'lowpass'; splatFilter.frequency.value = 1500;
        const splatG = actx.createGain();
        splatG.gain.setValueAtTime(0.7, now);
        splatN.connect(splatFilter); splatFilter.connect(splatG);
        splatG.connect(dryGain); splatG.connect(convolver);
        splatN.start(now);

        // Bone crunch
        const crunchBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const crunchOut = crunchBuf.getChannelData(0);
        for (let i = 0; i < crunchBuf.length; i++) {
            const t = i / actx.sampleRate;
            // Crispy crackling sound
            crunchOut[i] = (Math.random() > 0.5 ? 1 : -1) * Math.random() * Math.exp(-t * 20) * 0.5;
        }
        const crunchN = actx.createBufferSource(); crunchN.buffer = crunchBuf;
        const crunchFilter = actx.createBiquadFilter();
        crunchFilter.type = 'highpass'; crunchFilter.frequency.value = 2000;
        const crunchG = actx.createGain();
        crunchG.gain.setValueAtTime(0.4, now + 0.02);
        crunchN.connect(crunchFilter); crunchFilter.connect(crunchG);
        crunchG.connect(dryGain);
        crunchN.start(now + 0.02);

    } else if (type === 'playerHurt') {
        // Pain sound - sharp impact
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.25);

        // Heartbeat thump
        const heartOsc = actx.createOscillator();
        const heartGain = actx.createGain();
        heartOsc.connect(heartGain); heartGain.connect(dryGain);
        heartOsc.type = 'sine';
        heartOsc.frequency.value = 40;
        heartGain.gain.setValueAtTime(0.4, now + 0.1);
        heartGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        heartOsc.start(now + 0.1); heartOsc.stop(now + 0.3);

    } else if (type === 'waveComplete') {
        // Victory fanfare - rising tones
        const freqs = [400, 500, 600, 800];
        freqs.forEach((freq, i) => {
            const victoryOsc = actx.createOscillator();
            const victoryGain = actx.createGain();
            victoryOsc.connect(victoryGain); victoryGain.connect(dryGain); victoryGain.connect(convolver);
            victoryOsc.type = 'sine';
            victoryOsc.frequency.value = freq;
            victoryGain.gain.setValueAtTime(0.2, now + i * 0.1);
            victoryGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
            victoryOsc.start(now + i * 0.1); victoryOsc.stop(now + i * 0.1 + 0.35);
        });
        // Don't start the main osc for this sound type
        return;

    } else if (type === 'doorOpen') {
        // Heavy metal door sliding open - industrial/horror vibe

        // Layer 1: Deep mechanical grind (servo motor)
        const grindOsc = actx.createOscillator();
        const grindGain = actx.createGain();
        const grindFilter = actx.createBiquadFilter();
        grindOsc.connect(grindFilter);
        grindFilter.connect(grindGain);
        grindGain.connect(dryGain);
        grindOsc.type = 'sawtooth';
        grindOsc.frequency.setValueAtTime(50, now);
        grindOsc.frequency.linearRampToValueAtTime(80, now + 0.3);
        grindFilter.type = 'lowpass';
        grindFilter.frequency.value = 200;
        grindGain.gain.setValueAtTime(0.4, now);
        grindGain.gain.linearRampToValueAtTime(0.3, now + 0.15);
        grindGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        grindOsc.start(now); grindOsc.stop(now + 0.4);

        // Layer 2: Metal scraping (high frequency noise)
        const scrapeBuffer = actx.createBuffer(1, actx.sampleRate * 0.3, actx.sampleRate);
        const scrapeData = scrapeBuffer.getChannelData(0);
        for (let i = 0; i < scrapeData.length; i++) {
            scrapeData[i] = (Math.random() * 2 - 1) * (1 - i / scrapeData.length) * 0.5;
        }
        const scrapeSource = actx.createBufferSource();
        scrapeSource.buffer = scrapeBuffer;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass';
        scrapeFilter.frequency.value = 3000;
        scrapeFilter.Q.value = 3;
        const scrapeGain = actx.createGain();
        scrapeSource.connect(scrapeFilter);
        scrapeFilter.connect(scrapeGain);
        scrapeGain.connect(dryGain);
        scrapeGain.gain.setValueAtTime(0.15, now);
        scrapeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        scrapeSource.start(now);

        // Layer 3: Heavy thunk at the end (door hitting stop)
        const thunkOsc = actx.createOscillator();
        const thunkGain = actx.createGain();
        thunkOsc.connect(thunkGain);
        thunkGain.connect(dryGain);
        thunkGain.connect(convolver);
        thunkOsc.type = 'sine';
        thunkOsc.frequency.setValueAtTime(80, now + 0.25);
        thunkOsc.frequency.exponentialRampToValueAtTime(30, now + 0.35);
        thunkGain.gain.setValueAtTime(0, now);
        thunkGain.gain.setValueAtTime(0.5, now + 0.25);
        thunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        thunkOsc.start(now + 0.25); thunkOsc.stop(now + 0.45);

        // Layer 4: Hiss/pneumatic (air escaping)
        const hissBuffer = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const hissData = hissBuffer.getChannelData(0);
        for (let i = 0; i < hissData.length; i++) {
            hissData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / hissData.length, 2);
        }
        const hissSource = actx.createBufferSource();
        hissSource.buffer = hissBuffer;
        const hissFilter = actx.createBiquadFilter();
        hissFilter.type = 'highpass';
        hissFilter.frequency.value = 4000;
        const hissGain = actx.createGain();
        hissSource.connect(hissFilter);
        hissFilter.connect(hissGain);
        hissGain.connect(dryGain);
        hissGain.gain.setValueAtTime(0.1, now);
        hissGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        hissSource.start(now);

        return;

    } else if (type === 'zoomIn') {
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.connect(gain);
        gain.connect(dryGain);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.15);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.15);
    } else if (type === 'zoomOut') {
        const osc = actx.createOscillator();
        const gain = actx.createGain();
        osc.connect(gain);
        gain.connect(dryGain);
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.12);
        gain.gain.setValueAtTime(0.03, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.12);
    } else if (type === 'empty') {
        osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    } else if (type === 'mag_out') {
        // BEEFY MAG RELEASE - Heavy mechanical clunk

        // Layer 1: Deep thunk (weight of mag releasing)
        const thunkOsc = actx.createOscillator();
        const thunkGain = actx.createGain();
        thunkOsc.connect(thunkGain);
        thunkGain.connect(dryGain);
        thunkOsc.type = 'sine';
        thunkOsc.frequency.setValueAtTime(100, now);
        thunkOsc.frequency.exponentialRampToValueAtTime(40, now + 0.08);
        thunkGain.gain.setValueAtTime(0.7, now);
        thunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        thunkOsc.start(now); thunkOsc.stop(now + 0.12);

        // Layer 2: Sharp release click
        osc.type = 'square';
        osc.frequency.setValueAtTime(3500, now);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.015);
        filter.type = 'highpass';
        filter.frequency.value = 1500;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.025);
        osc.start(now); osc.stop(now + 0.03);

        // Layer 3: Metal slide/scrape
        const slideOsc = actx.createOscillator();
        const slideGain = actx.createGain();
        const slideFilter = actx.createBiquadFilter();
        slideOsc.connect(slideFilter); slideFilter.connect(slideGain);
        slideGain.connect(dryGain); slideGain.connect(convolver);
        slideOsc.type = 'sawtooth';
        slideOsc.frequency.setValueAtTime(500, now + 0.01);
        slideOsc.frequency.linearRampToValueAtTime(150, now + 0.15);
        slideFilter.type = 'bandpass';
        slideFilter.frequency.value = 1000;
        slideFilter.Q.value = 3;
        slideGain.gain.setValueAtTime(0.4, now + 0.01);
        slideGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        slideOsc.start(now + 0.01); slideOsc.stop(now + 0.18);

        // Layer 4: Metallic rattle (mag sliding out)
        const rattleBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const rattleOut = rattleBuf.getChannelData(0);
        for (let i = 0; i < rattleBuf.length; i++) {
            const t = i / actx.sampleRate;
            rattleOut[i] = (Math.random() * 2 - 1) * Math.exp(-t * 12) * Math.sin(i * 0.4) * 0.8;
        }
        const rattleN = actx.createBufferSource(); rattleN.buffer = rattleBuf;
        const rattleFilter = actx.createBiquadFilter();
        rattleFilter.type = 'bandpass';
        rattleFilter.frequency.value = 2500;
        rattleFilter.Q.value = 1;
        const rattleG = actx.createGain();
        rattleG.gain.setValueAtTime(0.35, now + 0.02);
        rattleN.connect(rattleFilter); rattleFilter.connect(rattleG);
        rattleG.connect(dryGain); rattleG.connect(convolver);
        rattleN.start(now + 0.02);

        // Layer 5: Low resonance (gun body vibration)
        const resOsc = actx.createOscillator();
        const resGain = actx.createGain();
        resOsc.connect(resGain);
        resGain.connect(dryGain);
        resOsc.type = 'triangle';
        resOsc.frequency.value = 80;
        resGain.gain.setValueAtTime(0.3, now);
        resGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        resOsc.start(now); resOsc.stop(now + 0.15);
        return;

    } else if (type === 'mag_in') {
        // BEEFY MAG INSERT - Satisfying heavy slam

        // Layer 1: Deep impact thump (mag slamming home)
        const impactOsc = actx.createOscillator();
        const impactGain = actx.createGain();
        const impactFilter = actx.createBiquadFilter();
        impactOsc.connect(impactFilter);
        impactFilter.connect(impactGain);
        impactGain.connect(dryGain);
        impactOsc.type = 'sine';
        impactOsc.frequency.setValueAtTime(80, now);
        impactOsc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        impactFilter.type = 'lowpass';
        impactFilter.frequency.value = 200;
        impactGain.gain.setValueAtTime(1.0, now);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        impactOsc.start(now); impactOsc.stop(now + 0.15);

        // Layer 2: Sharp latch click
        osc.type = 'square';
        osc.frequency.setValueAtTime(4000, now);
        osc.frequency.exponentialRampToValueAtTime(1500, now + 0.01);
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        gain.gain.setValueAtTime(0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
        osc.start(now); osc.stop(now + 0.025);

        // Layer 3: Metal-on-metal clunk
        const clunkOsc = actx.createOscillator();
        const clunkGain = actx.createGain();
        clunkOsc.connect(clunkGain);
        clunkGain.connect(dryGain);
        clunkGain.connect(convolver);
        clunkOsc.type = 'sawtooth';
        clunkOsc.frequency.setValueAtTime(200, now);
        clunkOsc.frequency.exponentialRampToValueAtTime(80, now + 0.06);
        clunkGain.gain.setValueAtTime(0.6, now);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        clunkOsc.start(now); clunkOsc.stop(now + 0.1);

        // Layer 4: Metallic ring/resonance
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(600, now);
        ringOsc.frequency.exponentialRampToValueAtTime(400, now + 0.2);
        ringFilter.type = 'bandpass';
        ringFilter.frequency.value = 500;
        ringFilter.Q.value = 12;
        ringGain.gain.setValueAtTime(0.25, now + 0.01);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        ringOsc.start(now); ringOsc.stop(now + 0.3);

        // Layer 5: Snap transient
        const snapBuf = actx.createBuffer(1, actx.sampleRate * 0.02, actx.sampleRate);
        const snapOut = snapBuf.getChannelData(0);
        for (let i = 0; i < snapBuf.length; i++) {
            snapOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.003)) * 1.2;
        }
        const snapN = actx.createBufferSource(); snapN.buffer = snapBuf;
        const snapFilter = actx.createBiquadFilter();
        snapFilter.type = 'highpass'; snapFilter.frequency.value = 3500;
        const snapG = actx.createGain();
        snapG.gain.setValueAtTime(0.5, now);
        snapN.connect(snapFilter); snapFilter.connect(snapG); snapG.connect(dryGain);
        snapN.start(now);

        // Layer 6: Sub-bass punch
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(50, now);
        subOsc.frequency.exponentialRampToValueAtTime(25, now + 0.08);
        subGain.gain.setValueAtTime(0.6, now);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        subOsc.start(now); subOsc.stop(now + 0.12);
        return;

    } else if (type === 'rack') {
        // BEEFY BOLT RACK - Aggressive charging handle slam

        // Layer 1: Pull back - heavy metal scrape
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(500, now + 0.1);
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.14);

        // Layer 2: Aggressive scrape noise
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.12, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const t = i / actx.sampleRate;
            const env = Math.exp(-t * 10);
            scrapeOut[i] = (Math.random() * 2 - 1) * env * (0.6 + 0.4 * Math.sin(i * 0.08));
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 3000; scrapeFilter.Q.value = 1.5;
        const scrapeG = actx.createGain();
        scrapeG.gain.setValueAtTime(0.45, now);
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain); scrapeG.connect(convolver);
        scrapeN.start(now);

        // Layer 3: HEAVY bolt slam forward
        const slamOsc = actx.createOscillator();
        const slamGain = actx.createGain();
        slamOsc.connect(slamGain); slamGain.connect(dryGain); slamGain.connect(convolver);
        slamOsc.type = 'sine';
        slamOsc.frequency.setValueAtTime(100, now + 0.12);
        slamOsc.frequency.exponentialRampToValueAtTime(35, now + 0.22);
        slamGain.gain.setValueAtTime(0.9, now + 0.12);
        slamGain.gain.exponentialRampToValueAtTime(0.01, now + 0.24);
        slamOsc.start(now + 0.12); slamOsc.stop(now + 0.28);

        // Layer 4: Sharp metal impact
        const impOsc = actx.createOscillator();
        const impGain = actx.createGain();
        impOsc.connect(impGain); impGain.connect(dryGain);
        impOsc.type = 'square';
        impOsc.frequency.setValueAtTime(5000, now + 0.12);
        impOsc.frequency.exponentialRampToValueAtTime(1200, now + 0.14);
        impGain.gain.setValueAtTime(0.5, now + 0.12);
        impGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        impOsc.start(now + 0.12); impOsc.stop(now + 0.17);

        // Layer 5: Metal clunk body
        const clunkOsc = actx.createOscillator();
        const clunkGain = actx.createGain();
        clunkOsc.connect(clunkGain); clunkGain.connect(dryGain);
        clunkOsc.type = 'sawtooth';
        clunkOsc.frequency.setValueAtTime(150, now + 0.12);
        clunkOsc.frequency.exponentialRampToValueAtTime(60, now + 0.18);
        clunkGain.gain.setValueAtTime(0.5, now + 0.12);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        clunkOsc.start(now + 0.12); clunkOsc.stop(now + 0.22);

        // Layer 6: Resonant metal ring
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(900, now + 0.13);
        ringFilter.type = 'bandpass'; ringFilter.frequency.value = 900; ringFilter.Q.value = 20;
        ringGain.gain.setValueAtTime(0.2, now + 0.13);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        ringOsc.start(now + 0.13); ringOsc.stop(now + 0.5);

        // Layer 7: Sub-bass slam punch
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(45, now + 0.12);
        subOsc.frequency.exponentialRampToValueAtTime(20, now + 0.2);
        subGain.gain.setValueAtTime(0.7, now + 0.12);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.22);
        subOsc.start(now + 0.12); subOsc.stop(now + 0.25);

        // Layer 8: Spring tension release noise
        const springBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const springOut = springBuf.getChannelData(0);
        for (let i = 0; i < springBuf.length; i++) {
            const t = i / actx.sampleRate;
            springOut[i] = Math.sin(i * 0.15) * Math.exp(-t * 30) * 0.4;
        }
        const springN = actx.createBufferSource(); springN.buffer = springBuf;
        const springFilter = actx.createBiquadFilter();
        springFilter.type = 'highpass'; springFilter.frequency.value = 1500;
        const springG = actx.createGain();
        springG.gain.value = 0.3;
        springN.connect(springFilter); springFilter.connect(springG);
        springG.connect(dryGain);
        springN.start(now + 0.12);
        return;

    } else if (type === 'pickup') {
        // Satisfying pickup chime
        const freqs = [600, 800, 1000];
        freqs.forEach((freq, i) => {
            const chimeOsc = actx.createOscillator();
            const chimeGain = actx.createGain();
            chimeOsc.connect(chimeGain); chimeGain.connect(dryGain); chimeGain.connect(convolver);
            chimeOsc.type = 'sine';
            chimeOsc.frequency.value = freq;
            chimeGain.gain.setValueAtTime(0.2, now + i * 0.05);
            chimeGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.2);
            chimeOsc.start(now + i * 0.05); chimeOsc.stop(now + i * 0.05 + 0.25);
        });
        return;

    } else if (type === 'doubleJump') {
        // Whooshy air burst for double jump
        const whooshBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const whooshData = whooshBuf.getChannelData(0);
        for (let i = 0; i < whooshBuf.length; i++) {
            const t = i / actx.sampleRate;
            whooshData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 20) * 0.4;
        }
        const whooshSrc = actx.createBufferSource();
        whooshSrc.buffer = whooshBuf;
        const whooshFilter = actx.createBiquadFilter();
        whooshFilter.type = 'bandpass';
        whooshFilter.frequency.setValueAtTime(400, now);
        whooshFilter.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        whooshFilter.Q.value = 1.0;
        const whooshGain = actx.createGain();
        whooshGain.gain.setValueAtTime(0.5, now);
        whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        whooshSrc.connect(whooshFilter);
        whooshFilter.connect(whooshGain);
        whooshGain.connect(dryGain);
        whooshSrc.start(now);

        // Quick upward tone for lift feel
        const liftOsc = actx.createOscillator();
        const liftGain = actx.createGain();
        liftOsc.connect(liftGain);
        liftGain.connect(dryGain);
        liftOsc.type = 'sine';
        liftOsc.frequency.setValueAtTime(200, now);
        liftOsc.frequency.exponentialRampToValueAtTime(400, now + 0.08);
        liftGain.gain.setValueAtTime(0.15, now);
        liftGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        liftOsc.start(now);
        liftOsc.stop(now + 0.12);
        return;

    } else if (type === 'nuke') {
        // Massive explosion
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, now);
        osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, now);
        filter.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
        osc.start(now); osc.stop(now + 1.2);

        // Massive noise burst
        const nukeBuf = actx.createBuffer(1, actx.sampleRate * 0.5, actx.sampleRate);
        const nukeOut = nukeBuf.getChannelData(0);
        for (let i = 0; i < nukeBuf.length; i++) {
            nukeOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.2));
        }
        const nukeN = actx.createBufferSource(); nukeN.buffer = nukeBuf;
        const nukeFilter = actx.createBiquadFilter();
        nukeFilter.type = 'lowpass'; nukeFilter.frequency.value = 600;
        const nukeG = actx.createGain();
        nukeG.gain.setValueAtTime(0.7, now);
        nukeG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        nukeN.connect(nukeFilter); nukeFilter.connect(nukeG);
        nukeG.connect(dryGain); nukeG.connect(convolver);
        nukeN.start(now);

        // High frequency sizzle
        const sizzleOsc = actx.createOscillator();
        const sizzleGain = actx.createGain();
        sizzleOsc.connect(sizzleGain); sizzleGain.connect(dryGain);
        sizzleOsc.type = 'sawtooth';
        sizzleOsc.frequency.setValueAtTime(2000, now);
        sizzleOsc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        sizzleGain.gain.setValueAtTime(0.3, now);
        sizzleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        sizzleOsc.start(now); sizzleOsc.stop(now + 0.4);

    } else if (type === 'explosion') {
        // Explosive rounds smaller explosion - punchy but not overwhelming
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(25, now + 0.25);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, now);
        filter.frequency.exponentialRampToValueAtTime(80, now + 0.2);
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Quick blast noise
        const blastBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const blastOut = blastBuf.getChannelData(0);
        for (let i = 0; i < blastBuf.length; i++) {
            blastOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.04));
        }
        const blastN = actx.createBufferSource(); blastN.buffer = blastBuf;
        const blastFilter = actx.createBiquadFilter();
        blastFilter.type = 'bandpass'; blastFilter.frequency.value = 800; blastFilter.Q.value = 0.8;
        const blastG = actx.createGain();
        blastG.gain.setValueAtTime(0.4, now);
        blastG.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        blastN.connect(blastFilter); blastFilter.connect(blastG);
        blastG.connect(dryGain); blastG.connect(convolver);
        blastN.start(now);

    } else if (type === 'sniperShoot') {
        // === ABSOLUTELY MASSIVE .50 BMG ANTI-MATERIEL RIFLE SOUND ===
        // This needs to SHAKE THE ROOM. 10+ layered audio components.

        // LAYER 1: SUB-BASS EARTHQUAKE (15-30Hz - feel it in your chest)
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        const subFilter = actx.createBiquadFilter();
        subOsc.connect(subFilter);
        subFilter.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(25, now);
        subOsc.frequency.exponentialRampToValueAtTime(12, now + 0.4);
        subFilter.type = 'lowpass';
        subFilter.frequency.value = 60;
        subFilter.Q.value = 1.5;
        subGain.gain.setValueAtTime(2.0, now); // CRANKED
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        subOsc.start(now); subOsc.stop(now + 0.55);

        // LAYER 2: CHEST PUNCH - Low frequency impact
        const chestOsc = actx.createOscillator();
        const chestGain = actx.createGain();
        chestOsc.connect(chestGain);
        chestGain.connect(dryGain);
        chestGain.connect(convolver);
        chestOsc.type = 'sine';
        chestOsc.frequency.setValueAtTime(50, now);
        chestOsc.frequency.exponentialRampToValueAtTime(20, now + 0.25);
        chestGain.gain.setValueAtTime(1.8, now);
        chestGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        chestOsc.start(now); chestOsc.stop(now + 0.4);

        // LAYER 3: CANNON BOOM - The main explosion body
        const boomOsc = actx.createOscillator();
        const boomGain = actx.createGain();
        const boomFilter = actx.createBiquadFilter();
        boomOsc.connect(boomFilter);
        boomFilter.connect(boomGain);
        boomGain.connect(dryGain);
        boomGain.connect(convolver);
        boomOsc.type = 'sawtooth';
        boomOsc.frequency.setValueAtTime(100, now);
        boomOsc.frequency.exponentialRampToValueAtTime(30, now + 0.2);
        boomFilter.type = 'lowpass';
        boomFilter.frequency.setValueAtTime(500, now);
        boomFilter.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        boomGain.gain.setValueAtTime(1.2, now);
        boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        boomOsc.start(now); boomOsc.stop(now + 0.4);

        // LAYER 4: SUPERSONIC CRACK - Sharp transient (bullet breaking sound barrier)
        const crackBuf = actx.createBuffer(1, actx.sampleRate * 0.03, actx.sampleRate);
        const crackData = crackBuf.getChannelData(0);
        for (let i = 0; i < crackBuf.length; i++) {
            const t = i / actx.sampleRate;
            // Sharp attack, fast decay
            crackData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 150) * 2.5;
        }
        const crackSrc = actx.createBufferSource();
        crackSrc.buffer = crackBuf;
        const crackFilter = actx.createBiquadFilter();
        crackFilter.type = 'highpass';
        crackFilter.frequency.value = 4000;
        const crackGain = actx.createGain();
        crackGain.gain.value = 1.4;
        crackSrc.connect(crackFilter);
        crackFilter.connect(crackGain);
        crackGain.connect(dryGain);
        crackSrc.start(now);

        // LAYER 5: SECONDARY CRACK - Slightly delayed echo crack
        const crack2Buf = actx.createBuffer(1, actx.sampleRate * 0.025, actx.sampleRate);
        const crack2Data = crack2Buf.getChannelData(0);
        for (let i = 0; i < crack2Buf.length; i++) {
            const t = i / actx.sampleRate;
            crack2Data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 120) * 1.5;
        }
        const crack2Src = actx.createBufferSource();
        crack2Src.buffer = crack2Buf;
        const crack2Filter = actx.createBiquadFilter();
        crack2Filter.type = 'bandpass';
        crack2Filter.frequency.value = 6000;
        crack2Filter.Q.value = 0.5;
        const crack2Gain = actx.createGain();
        crack2Gain.gain.value = 0.8;
        crack2Src.connect(crack2Filter);
        crack2Filter.connect(crack2Gain);
        crack2Gain.connect(dryGain);
        crack2Src.start(now + 0.008); // Slight delay for echo effect

        // LAYER 6: EXPLOSION NOISE - Chaotic burst
        const explosionBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const explosionData = explosionBuf.getChannelData(0);
        for (let i = 0; i < explosionBuf.length; i++) {
            const t = i / actx.sampleRate;
            explosionData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 20) * 1.2;
        }
        const explosionSrc = actx.createBufferSource();
        explosionSrc.buffer = explosionBuf;
        const explosionFilter = actx.createBiquadFilter();
        explosionFilter.type = 'bandpass';
        explosionFilter.frequency.value = 400;
        explosionFilter.Q.value = 0.3;
        const explosionGain = actx.createGain();
        explosionGain.gain.setValueAtTime(1.5, now);
        explosionGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        explosionSrc.connect(explosionFilter);
        explosionFilter.connect(explosionGain);
        explosionGain.connect(dryGain);
        explosionGain.connect(convolver);
        explosionSrc.start(now);

        // LAYER 7: MID-RANGE PUNCH - Body of the shot
        const midOsc = actx.createOscillator();
        const midGain = actx.createGain();
        midOsc.connect(midGain);
        midGain.connect(dryGain);
        midOsc.type = 'triangle';
        midOsc.frequency.setValueAtTime(180, now);
        midOsc.frequency.exponentialRampToValueAtTime(60, now + 0.15);
        midGain.gain.setValueAtTime(0.9, now);
        midGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        midOsc.start(now); midOsc.stop(now + 0.25);

        // LAYER 8: MECHANICAL CLUNK - Bolt/action resonance
        const mechOsc = actx.createOscillator();
        const mechGain = actx.createGain();
        mechOsc.connect(mechGain);
        mechGain.connect(dryGain);
        mechOsc.type = 'square';
        mechOsc.frequency.setValueAtTime(800, now + 0.01);
        mechOsc.frequency.exponentialRampToValueAtTime(300, now + 0.04);
        mechGain.gain.setValueAtTime(0.35, now + 0.01);
        mechGain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
        mechOsc.start(now + 0.01); mechOsc.stop(now + 0.08);

        // LAYER 9: AIR DISPLACEMENT WHOOSH
        const whooshBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const whooshData = whooshBuf.getChannelData(0);
        for (let i = 0; i < whooshBuf.length; i++) {
            const t = i / actx.sampleRate;
            whooshData[i] = (Math.random() * 2 - 1) * Math.sin(t * 50) * Math.exp(-t * 25) * 0.6;
        }
        const whooshSrc = actx.createBufferSource();
        whooshSrc.buffer = whooshBuf;
        const whooshFilter = actx.createBiquadFilter();
        whooshFilter.type = 'bandpass';
        whooshFilter.frequency.value = 1200;
        whooshFilter.Q.value = 0.8;
        const whooshGain = actx.createGain();
        whooshGain.gain.value = 0.5;
        whooshSrc.connect(whooshFilter);
        whooshFilter.connect(whooshGain);
        whooshGain.connect(dryGain);
        whooshSrc.start(now);

        // LAYER 10: LONG REVERB TAIL - Echoing across the battlefield
        const tailBuf = actx.createBuffer(1, actx.sampleRate * 0.8, actx.sampleRate);
        const tailData = tailBuf.getChannelData(0);
        for (let i = 0; i < tailBuf.length; i++) {
            const t = i / actx.sampleRate;
            // Multiple decay stages for realistic echo
            const decay1 = Math.exp(-t * 4);
            const decay2 = Math.exp(-t * 2) * 0.3;
            tailData[i] = (Math.random() * 2 - 1) * (decay1 + decay2) * 0.7;
        }
        const tailSrc = actx.createBufferSource();
        tailSrc.buffer = tailBuf;
        const tailFilter = actx.createBiquadFilter();
        tailFilter.type = 'lowpass';
        tailFilter.frequency.setValueAtTime(1200, now);
        tailFilter.frequency.exponentialRampToValueAtTime(300, now + 0.6);
        const tailGain = actx.createGain();
        tailGain.gain.setValueAtTime(0.8, now);
        tailGain.gain.exponentialRampToValueAtTime(0.01, now + 0.9);
        tailSrc.connect(tailFilter);
        tailFilter.connect(tailGain);
        tailGain.connect(convolver);
        tailSrc.start(now);

        // LAYER 11: DISTANT THUNDER RUMBLE - The shot echoing off terrain
        const thunderOsc = actx.createOscillator();
        const thunderGain = actx.createGain();
        const thunderFilter = actx.createBiquadFilter();
        thunderOsc.connect(thunderFilter);
        thunderFilter.connect(thunderGain);
        thunderGain.connect(convolver);
        thunderOsc.type = 'sine';
        thunderOsc.frequency.setValueAtTime(35, now + 0.15);
        thunderOsc.frequency.exponentialRampToValueAtTime(18, now + 0.6);
        thunderFilter.type = 'lowpass';
        thunderFilter.frequency.value = 80;
        thunderGain.gain.setValueAtTime(0.01, now);
        thunderGain.gain.linearRampToValueAtTime(0.6, now + 0.2);
        thunderGain.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
        thunderOsc.start(now + 0.15); thunderOsc.stop(now + 0.85);

        // LAYER 12: MUZZLE BRAKE HISS - High frequency gas escape
        const hissBuf = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const hissData = hissBuf.getChannelData(0);
        for (let i = 0; i < hissBuf.length; i++) {
            const t = i / actx.sampleRate;
            hissData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * 0.4;
        }
        const hissSrc = actx.createBufferSource();
        hissSrc.buffer = hissBuf;
        const hissFilter = actx.createBiquadFilter();
        hissFilter.type = 'highpass';
        hissFilter.frequency.value = 5000;
        const hissGain = actx.createGain();
        hissGain.gain.setValueAtTime(0.4, now);
        hissGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        hissSrc.connect(hissFilter);
        hissFilter.connect(hissGain);
        hissGain.connect(dryGain);
        hissSrc.start(now);

        return;

    } else if (type === 'shotgunShoot') {
        // === DEVASTATING 12-GAUGE PUMP SHOTGUN BLAST ===
        // Wide, punchy, room-filling explosion with that iconic shotgun "thump"

        // LAYER 1: DEEP BODY SLAM - The chest-punch low end
        const bodyOsc = actx.createOscillator();
        const bodyGain = actx.createGain();
        const bodyFilter = actx.createBiquadFilter();
        bodyOsc.connect(bodyFilter);
        bodyFilter.connect(bodyGain);
        bodyGain.connect(dryGain);
        bodyGain.connect(convolver);
        bodyOsc.type = 'sine';
        bodyOsc.frequency.setValueAtTime(60, now);
        bodyOsc.frequency.exponentialRampToValueAtTime(25, now + 0.25);
        bodyFilter.type = 'lowpass';
        bodyFilter.frequency.value = 120;
        bodyGain.gain.setValueAtTime(1.4, now);
        bodyGain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        bodyOsc.start(now); bodyOsc.stop(now + 0.35);

        // LAYER 2: MID PUNCH - The "thump" signature
        const thumpOsc = actx.createOscillator();
        const thumpGain = actx.createGain();
        thumpOsc.connect(thumpGain);
        thumpGain.connect(dryGain);
        thumpGain.connect(convolver);
        thumpOsc.type = 'triangle';
        thumpOsc.frequency.setValueAtTime(120, now);
        thumpOsc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
        thumpGain.gain.setValueAtTime(1.2, now);
        thumpGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        thumpOsc.start(now); thumpOsc.stop(now + 0.25);

        // LAYER 3: EXPLOSIVE CRACK - Sharp initial transient
        const crackBuf = actx.createBuffer(1, actx.sampleRate * 0.04, actx.sampleRate);
        const crackData = crackBuf.getChannelData(0);
        for (let i = 0; i < crackBuf.length; i++) {
            const t = i / actx.sampleRate;
            crackData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 100) * 2.0;
        }
        const crackSrc = actx.createBufferSource();
        crackSrc.buffer = crackBuf;
        const crackFilter = actx.createBiquadFilter();
        crackFilter.type = 'bandpass';
        crackFilter.frequency.value = 3000;
        crackFilter.Q.value = 0.5;
        const crackGain = actx.createGain();
        crackGain.gain.value = 1.0;
        crackSrc.connect(crackFilter);
        crackFilter.connect(crackGain);
        crackGain.connect(dryGain);
        crackSrc.start(now);

        // LAYER 4: PELLET SPREAD NOISE - Wide frequency scatter
        const spreadBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const spreadData = spreadBuf.getChannelData(0);
        for (let i = 0; i < spreadBuf.length; i++) {
            const t = i / actx.sampleRate;
            // Multiple frequency components for pellet scatter feel
            spreadData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.8 +
                           Math.sin(i * 0.3) * Math.exp(-t * 60) * 0.3;
        }
        const spreadSrc = actx.createBufferSource();
        spreadSrc.buffer = spreadBuf;
        const spreadFilter = actx.createBiquadFilter();
        spreadFilter.type = 'bandpass';
        spreadFilter.frequency.value = 2000;
        spreadFilter.Q.value = 0.3;
        const spreadGain = actx.createGain();
        spreadGain.gain.setValueAtTime(0.9, now);
        spreadGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        spreadSrc.connect(spreadFilter);
        spreadFilter.connect(spreadGain);
        spreadGain.connect(dryGain);
        spreadSrc.start(now);

        // LAYER 5: BARREL RESONANCE - Hollow tube sound
        const barrelOsc = actx.createOscillator();
        const barrelGain = actx.createGain();
        const barrelFilter = actx.createBiquadFilter();
        barrelOsc.connect(barrelFilter);
        barrelFilter.connect(barrelGain);
        barrelGain.connect(dryGain);
        barrelOsc.type = 'sawtooth';
        barrelOsc.frequency.setValueAtTime(180, now);
        barrelOsc.frequency.exponentialRampToValueAtTime(80, now + 0.1);
        barrelFilter.type = 'bandpass';
        barrelFilter.frequency.setValueAtTime(600, now);
        barrelFilter.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        barrelFilter.Q.value = 2;
        barrelGain.gain.setValueAtTime(0.6, now);
        barrelGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        barrelOsc.start(now); barrelOsc.stop(now + 0.2);

        // LAYER 6: GAS EXPULSION - Wide "whoosh"
        const gasBuf = actx.createBuffer(1, actx.sampleRate * 0.12, actx.sampleRate);
        const gasData = gasBuf.getChannelData(0);
        for (let i = 0; i < gasBuf.length; i++) {
            const t = i / actx.sampleRate;
            gasData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 25) * 0.5;
        }
        const gasSrc = actx.createBufferSource();
        gasSrc.buffer = gasBuf;
        const gasFilter = actx.createBiquadFilter();
        gasFilter.type = 'lowpass';
        gasFilter.frequency.setValueAtTime(4000, now);
        gasFilter.frequency.exponentialRampToValueAtTime(500, now + 0.15);
        const gasGain = actx.createGain();
        gasGain.gain.setValueAtTime(0.7, now);
        gasGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        gasSrc.connect(gasFilter);
        gasFilter.connect(gasGain);
        gasGain.connect(dryGain);
        gasGain.connect(convolver);
        gasSrc.start(now);

        // LAYER 7: REVERB TAIL - Room echo
        const tailBuf = actx.createBuffer(1, actx.sampleRate * 0.5, actx.sampleRate);
        const tailData = tailBuf.getChannelData(0);
        for (let i = 0; i < tailBuf.length; i++) {
            const t = i / actx.sampleRate;
            tailData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 5) * 0.5;
        }
        const tailSrc = actx.createBufferSource();
        tailSrc.buffer = tailBuf;
        const tailFilter = actx.createBiquadFilter();
        tailFilter.type = 'lowpass';
        tailFilter.frequency.setValueAtTime(800, now);
        tailFilter.frequency.exponentialRampToValueAtTime(200, now + 0.4);
        const tailGain = actx.createGain();
        tailGain.gain.setValueAtTime(0.5, now);
        tailGain.gain.exponentialRampToValueAtTime(0.01, now + 0.55);
        tailSrc.connect(tailFilter);
        tailFilter.connect(tailGain);
        tailGain.connect(convolver);
        tailSrc.start(now);

        return;

    } else if (type === 'pumpPull') {
        // Pump pull back - distinctive "chk" sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.1);
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Metal slide scrape
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const t = i / actx.sampleRate;
            scrapeOut[i] = (Math.random() * 2 - 1) * (0.4 + 0.6 * Math.sin(i * 0.15)) * (1 - t * 8);
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 3000; scrapeFilter.Q.value = 1.5;
        const scrapeG = actx.createGain();
        scrapeG.gain.value = 0.45;
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain);
        scrapeN.start(now);

        // Shell eject clatter
        const shellOsc = actx.createOscillator();
        const shellGain = actx.createGain();
        shellOsc.connect(shellGain); shellGain.connect(dryGain);
        shellOsc.type = 'sine';
        shellOsc.frequency.setValueAtTime(2000, now + 0.05);
        shellOsc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        shellGain.gain.setValueAtTime(0.25, now + 0.05);
        shellGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        shellOsc.start(now + 0.05); shellOsc.stop(now + 0.15);

    } else if (type === 'pumpPush') {
        // Pump push forward - "chak" chambering sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.linearRampToValueAtTime(300, now + 0.08);
        filter.type = 'bandpass';
        filter.frequency.value = 1200;
        filter.Q.value = 1.5;
        gain.gain.setValueAtTime(0.55, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Heavy slam at end - shell locks in
        const slamOsc = actx.createOscillator();
        const slamGain = actx.createGain();
        slamOsc.connect(slamGain); slamGain.connect(dryGain); slamGain.connect(convolver);
        slamOsc.type = 'sine';
        slamOsc.frequency.setValueAtTime(150, now + 0.06);
        slamOsc.frequency.exponentialRampToValueAtTime(60, now + 0.12);
        slamGain.gain.setValueAtTime(0.7, now + 0.06);
        slamGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        slamOsc.start(now + 0.06); slamOsc.stop(now + 0.18);

        // Metallic click lock
        const lockOsc = actx.createOscillator();
        const lockGain = actx.createGain();
        lockOsc.connect(lockGain); lockGain.connect(dryGain);
        lockOsc.type = 'square';
        lockOsc.frequency.setValueAtTime(2200, now + 0.08);
        lockOsc.frequency.exponentialRampToValueAtTime(1600, now + 0.1);
        lockGain.gain.setValueAtTime(0.35, now + 0.08);
        lockGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        lockOsc.start(now + 0.08); lockOsc.stop(now + 0.14);

    } else if (type === 'shellLoad') {
        // Single shell being loaded into tube
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.04);
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.35, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.1);

        // Click of shell seating
        const clickOsc = actx.createOscillator();
        const clickGain = actx.createGain();
        clickOsc.connect(clickGain); clickGain.connect(dryGain);
        clickOsc.type = 'square';
        clickOsc.frequency.setValueAtTime(1800, now + 0.03);
        clickOsc.frequency.exponentialRampToValueAtTime(1200, now + 0.06);
        clickGain.gain.setValueAtTime(0.3, now + 0.03);
        clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        clickOsc.start(now + 0.03); clickOsc.stop(now + 0.1);

    } else if (type === 'boltLift') {
        // Bolt handle lift - metallic click up
        osc.type = 'sine';
        osc.frequency.setValueAtTime(1200, now);
        osc.frequency.exponentialRampToValueAtTime(600, now + 0.05);
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 3;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc.start(now); osc.stop(now + 0.1);

        // Metallic click
        const clickOsc = actx.createOscillator();
        const clickGain = actx.createGain();
        clickOsc.connect(clickGain); clickGain.connect(dryGain);
        clickOsc.type = 'square';
        clickOsc.frequency.setValueAtTime(3000, now);
        clickOsc.frequency.exponentialRampToValueAtTime(1500, now + 0.02);
        clickGain.gain.setValueAtTime(0.25, now);
        clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
        clickOsc.start(now); clickOsc.stop(now + 0.04);

    } else if (type === 'boltPull') {
        // Bolt pull back - heavy scrape
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.15);
        filter.type = 'bandpass';
        filter.frequency.value = 1200;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        osc.start(now); osc.stop(now + 0.2);

        // Metal scrape noise
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const t = i / actx.sampleRate;
            scrapeOut[i] = (Math.random() * 2 - 1) * (0.3 + 0.7 * Math.sin(i * 0.1)) * (1 - t * 4);
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 2500; scrapeFilter.Q.value = 2;
        const scrapeG = actx.createGain();
        scrapeG.gain.value = 0.4;
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain);
        scrapeN.start(now);

    } else if (type === 'boltPush') {
        // Bolt push forward - chamber round, heavy slam
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.linearRampToValueAtTime(200, now + 0.12);
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 1.5;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.18);

        // Heavy thunk at end
        const thunkOsc = actx.createOscillator();
        const thunkGain = actx.createGain();
        thunkOsc.connect(thunkGain); thunkGain.connect(dryGain); thunkGain.connect(convolver);
        thunkOsc.type = 'sine';
        thunkOsc.frequency.setValueAtTime(120, now + 0.1);
        thunkOsc.frequency.exponentialRampToValueAtTime(50, now + 0.18);
        thunkGain.gain.setValueAtTime(0.6, now + 0.1);
        thunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        thunkOsc.start(now + 0.1); thunkOsc.stop(now + 0.22);

    } else if (type === 'boltDown') {
        // Bolt handle lock down - solid click
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.03);
        filter.type = 'highpass';
        filter.frequency.value = 800;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.06);
        osc.start(now); osc.stop(now + 0.08);

        // Locking click
        const lockOsc = actx.createOscillator();
        const lockGain = actx.createGain();
        lockOsc.connect(lockGain); lockGain.connect(dryGain);
        lockOsc.type = 'square';
        lockOsc.frequency.setValueAtTime(2500, now + 0.02);
        lockOsc.frequency.exponentialRampToValueAtTime(1800, now + 0.04);
        lockGain.gain.setValueAtTime(0.3, now + 0.02);
        lockGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        lockOsc.start(now + 0.02); lockOsc.stop(now + 0.06);

    } else if (type === 'weaponSwitch') {
        // Quick weapon swap sound
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.08);
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Cloth/strap rustle
        const rustleBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const rustleOut = rustleBuf.getChannelData(0);
        for (let i = 0; i < rustleBuf.length; i++) {
            rustleOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.03)) * 0.3;
        }
        const rustleN = actx.createBufferSource(); rustleN.buffer = rustleBuf;
        const rustleFilter = actx.createBiquadFilter();
        rustleFilter.type = 'highpass'; rustleFilter.frequency.value = 2000;
        const rustleG = actx.createGain();
        rustleG.gain.value = 0.25;
        rustleN.connect(rustleFilter); rustleFilter.connect(rustleG);
        rustleG.connect(dryGain);
        rustleN.start(now);

    } else if (type === 'collateral') {
        // Satisfying multi-kill sound - rising chime with bass punch
        // Bass punch
        const punchOsc = actx.createOscillator();
        const punchGain = actx.createGain();
        punchOsc.connect(punchGain); punchGain.connect(dryGain);
        punchOsc.type = 'sine';
        punchOsc.frequency.setValueAtTime(100, now);
        punchOsc.frequency.exponentialRampToValueAtTime(40, now + 0.15);
        punchGain.gain.setValueAtTime(0.6, now);
        punchGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        punchOsc.start(now); punchOsc.stop(now + 0.25);

        // Rising chime (satisfying ding)
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        osc.start(now); osc.stop(now + 0.45);

        // Harmonic overtone
        const harmOsc = actx.createOscillator();
        const harmGain = actx.createGain();
        harmOsc.connect(harmGain); harmGain.connect(dryGain);
        harmOsc.type = 'sine';
        harmOsc.frequency.setValueAtTime(1200, now + 0.05);
        harmOsc.frequency.exponentialRampToValueAtTime(2000, now + 0.2);
        harmGain.gain.setValueAtTime(0.2, now + 0.05);
        harmGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        harmOsc.start(now + 0.05); harmOsc.stop(now + 0.4);
    }
}

/**
 * SCENE SETUP
 */
const scene = new THREE.Scene();
// ENHANCED Procedural Skybox - Epic Sunset with Volumetric Clouds
const skyVertexShader = `
varying vec3 vWorldPosition;
varying vec3 vDirection;
void main() {
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    vDirection = normalize(position);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

const skyFragmentShader = `
uniform vec3 topColor;
uniform vec3 midColor;
uniform vec3 bottomColor;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform float time;
varying vec3 vWorldPosition;
varying vec3 vDirection;

// Simplex noise functions for procedural clouds
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

float fbm(vec3 p) {
    float f = 0.0;
    float amplitude = 0.5;
    for (int i = 0; i < 5; i++) {
        f += amplitude * snoise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return f;
}

void main() {
    vec3 dir = normalize(vDirection);
    float h = dir.y;

    // More natural sunset gradient
    vec3 horizonColor = vec3(0.95, 0.5, 0.2);   // Warm orange at horizon
    vec3 lowerSkyColor = vec3(0.6, 0.35, 0.25); // Muted pink-orange

    vec3 skyColor;
    if (h < 0.0) {
        // Below horizon - dark
        skyColor = mix(vec3(0.03, 0.02, 0.02), bottomColor * 0.3, smoothstep(-0.2, 0.0, h));
    } else if (h < 0.15) {
        // Horizon band
        skyColor = mix(horizonColor, lowerSkyColor, smoothstep(0.0, 0.15, h));
    } else if (h < 0.4) {
        // Lower sky
        skyColor = mix(lowerSkyColor, midColor, smoothstep(0.15, 0.4, h));
    } else {
        // Upper sky fading to darker blue-purple
        skyColor = mix(midColor, topColor, smoothstep(0.4, 0.85, h));
    }

    // Sun glow - more natural
    float sunDot = dot(dir, normalize(sunDirection));
    float sunGlow = pow(max(sunDot, 0.0), 80.0);
    float sunHalo = pow(max(sunDot, 0.0), 12.0) * 0.3;
    float sunDisk = smoothstep(0.997, 0.999, sunDot);

    skyColor += sunColor * sunGlow * 1.5;
    skyColor += sunColor * sunHalo * 0.4;
    skyColor += sunColor * sunDisk * 2.0;

    // Subtle procedural clouds
    if (h > 0.0 && h < 0.5) {
        vec3 cloudPos = dir * 2.0 + vec3(time * 0.005, 0.0, time * 0.003);
        float cloud = fbm(cloudPos * 1.5);
        cloud = smoothstep(0.1, 0.5, cloud);

        // Clouds lit by sunset - muted colors
        vec3 cloudColor = mix(vec3(0.8, 0.5, 0.35), vec3(0.5, 0.3, 0.25), 1.0 - h * 2.0);

        // Light the clouds from sun direction
        float cloudLight = max(0.0, dot(dir, normalize(sunDirection)));
        cloudColor = mix(cloudColor * 0.5, cloudColor * 1.2, cloudLight);

        // Cloud density varies by height - less dense overall
        float cloudMask = smoothstep(0.0, 0.1, h) * smoothstep(0.5, 0.2, h);
        cloud *= cloudMask * 0.4; // Much less cloud coverage

        skyColor = mix(skyColor, cloudColor, cloud);
    }

    // Subtle atmospheric scattering
    float scatter = 1.0 - abs(h);
    scatter = pow(scatter, 4.0);
    skyColor = mix(skyColor, horizonColor * 0.8, scatter * 0.15);

    gl_FragColor = vec4(skyColor, 1.0);
}`;

const skyUniforms = {
    topColor: { value: new THREE.Color(0x1a1535) },     // Dark blue-purple night sky
    midColor: { value: new THREE.Color(0x4a3055) },     // Muted purple
    bottomColor: { value: new THREE.Color(0xdd6030) },  // Warm orange horizon
    sunColor: { value: new THREE.Color(0xffcc55) },     // Golden sun
    sunDirection: { value: new THREE.Vector3(-0.5, 0.12, -0.85).normalize() },
    time: { value: 0.0 }
};
const skyGeo = new THREE.SphereGeometry(500, 64, 32);
const skyMat = new THREE.ShaderMaterial({
    vertexShader: skyVertexShader,
    fragmentShader: skyFragmentShader,
    uniforms: skyUniforms,
    side: THREE.BackSide
});
const sky = new THREE.Mesh(skyGeo, skyMat);
// scene.add(sky); // Disabled - indoor arena with roof

// Sunset clouds - scattered wispy shapes
const cloudGroup = new THREE.Group();
for (let i = 0; i < 25; i++) {
    const cloudGeo = new THREE.PlaneGeometry(80 + Math.random() * 60, 15 + Math.random() * 20);
    const cloudMat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().lerpColors(
            new THREE.Color(0xff4020),
            new THREE.Color(0xff8040),
            Math.random()
        ),
        transparent: true,
        opacity: 0.3 + Math.random() * 0.3,
        side: THREE.DoubleSide
    });
    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
    const angle = Math.random() * Math.PI * 2;
    const height = 80 + Math.random() * 100;
    const dist = 200 + Math.random() * 200;
    cloud.position.set(
        Math.cos(angle) * dist,
        height,
        Math.sin(angle) * dist
    );
    cloud.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
    cloud.rotation.z = Math.random() * Math.PI;
    cloud.lookAt(0, height, 0);
    cloudGroup.add(cloud);
}
// scene.add(cloudGroup); // Disabled - indoor arena with roof

// Setting sun (disabled for indoor)
const sunGeo = new THREE.SphereGeometry(25, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
const sun = new THREE.Mesh(sunGeo, sunMat);
sun.position.set(-200, 40, -350);
// scene.add(sun); // Disabled - indoor arena

// Sun glow - large orange halo
const sunGlowGeo = new THREE.SphereGeometry(60, 32, 32);
const sunGlowMat = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.25
});
const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
sunGlow.position.copy(sun.position);
// scene.add(sunGlow); // Disabled - indoor arena

// Outer sun glow
const sunGlow2Geo = new THREE.SphereGeometry(100, 32, 32);
const sunGlow2Mat = new THREE.MeshBasicMaterial({
    color: 0xff4400,
    transparent: true,
    opacity: 0.1
});
const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
sunGlow2.position.copy(sun.position);
// scene.add(sunGlow2); // Disabled - indoor arena

// Indoor haze/dust fog (subtle)
scene.fog = new THREE.FogExp2(0x222225, 0.006);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // Reduced FOV and far plane for performance
const renderer = new THREE.WebGLRenderer({
    antialias: true, // Enable for cleaner edges
    powerPreference: "high-performance",
    precision: "highp" // High precision for better visuals
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); // Higher quality
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft realistic shadows
renderer.shadowMap.autoUpdate = false; // Manual shadow update
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic tone mapping
renderer.toneMappingExposure = 1.1; // Slightly brighter
renderer.physicallyCorrectLights = true; // PBR lighting
document.body.appendChild(renderer.domElement);

// POST-PROCESSING SETUP - ENHANCED GRAPHICS PIPELINE
const composer = new THREE.EffectComposer(renderer);

// Depth texture for depth-based effects
const depthTexture = new THREE.DepthTexture(window.innerWidth, window.innerHeight);
depthTexture.type = THREE.UnsignedShortType;
const depthRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat,
    depthTexture: depthTexture
});

const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// God Rays - DISABLED for performance (too expensive)
// const godRaysPass = new THREE.ShaderPass(GodRaysShader);
// composer.addPass(godRaysPass);

// Lens Flare - DISABLED for performance
// const lensFlarePass = new THREE.ShaderPass(LensFlareShader);
// composer.addPass(lensFlarePass);

// Heat Distortion - DISABLED for performance (very subtle anyway)
// const heatPass = new THREE.ShaderPass(HeatDistortionShader);
// composer.addPass(heatPass);

// Bloom for muzzle flash glow - optimized for performance
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth / 4, window.innerHeight / 4), // Quarter resolution for speed
    0.12,  // strength - reduced
    0.3,   // radius - tighter
    0.9    // threshold - higher
);
composer.addPass(bloomPass);

// Color Grading - DISABLED (ACES tone mapping provides good cinematic look)
// const colorGradingPass = new THREE.ShaderPass(ColorGradingShader);
// composer.addPass(colorGradingPass);

// Motion Blur
const motionBlurPass = new THREE.ShaderPass(MotionBlurShader);
composer.addPass(motionBlurPass);

// Chromatic Aberration - Subtle realism, increases during action
const chromaticPass = new THREE.ShaderPass(ChromaticAberrationShader);
chromaticPass.uniforms.amount.value = 0.001; // Very subtle base
composer.addPass(chromaticPass);

// Film Grain - DISABLED for cleaner look
// const grainPass = new THREE.ShaderPass(FilmGrainShader);
// grainPass.uniforms.intensity.value = 0.04;
// composer.addPass(grainPass);

// Vignette - DISABLED per user request
// const vignettePass = new THREE.ShaderPass(VignetteShader);
// composer.addPass(vignettePass);

// FXAA - Fast approximate anti-aliasing for cleaner edges
const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
const pixelRatio = renderer.getPixelRatio();
fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * pixelRatio), 1 / (window.innerHeight * pixelRatio));
composer.addPass(fxaaPass);

// Sun screen position for god rays and lens flare (updated in animate loop)
let sunScreenPos = new THREE.Vector2(0.3, 0.7);
let sunVisible = 1.0;

// Create sunset environment map for reflections
const envMapSize = 256;
const envMapCanvas = document.createElement('canvas');
envMapCanvas.width = envMapCanvas.height = envMapSize;
const envCtx = envMapCanvas.getContext('2d');
const envGrad = envCtx.createLinearGradient(0, 0, 0, envMapSize);
envGrad.addColorStop(0, '#2a1030');   // Purple top
envGrad.addColorStop(0.4, '#ff6040'); // Orange mid
envGrad.addColorStop(1, '#ffaa60');   // Warm bottom
envCtx.fillStyle = envGrad;
envCtx.fillRect(0, 0, envMapSize, envMapSize);
const envMapTex = new THREE.CanvasTexture(envMapCanvas);
envMapTex.mapping = THREE.EquirectangularReflectionMapping;

// ============ INDOOR FLUORESCENT LIGHTING ============
// Brighter cool white ambient for indoor feel
const ambientLight = new THREE.AmbientLight(0xdddde8, 0.6);
scene.add(ambientLight);

// Hemisphere light - bright ceiling, lighter floor
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x666677, 0.5);
scene.add(hemiLight);

// Main overhead light (like a big fluorescent panel) - straight down
const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(0, 100, 0); // Straight above
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.bias = -0.0002;
dirLight.shadow.normalBias = 0.02;
dirLight.shadow.radius = 3; // Softer shadows for fluorescent
dirLight.shadow.camera.left = -100;
dirLight.shadow.camera.right = 100;
dirLight.shadow.camera.top = 100;
dirLight.shadow.camera.bottom = -100;
dirLight.shadow.camera.near = 10;
dirLight.shadow.camera.far = 150;
scene.add(dirLight);

// Fluorescent strip lights array (for that warehouse look)
const fluorLights = [];
const FLUOR_ROWS = 5;
const FLUOR_COLS = 5;
const FLUOR_SPACING = 28;
const ROOF_HEIGHT = 30;

for (let row = 0; row < FLUOR_ROWS; row++) {
    for (let col = 0; col < FLUOR_COLS; col++) {
        const x = (col - (FLUOR_COLS - 1) / 2) * FLUOR_SPACING;
        const z = (row - (FLUOR_ROWS - 1) / 2) * FLUOR_SPACING;

        // Point light for each fluorescent fixture (brighter)
        const fluorLight = new THREE.PointLight(0xffffff, 1.0, 50, 2);
        fluorLight.position.set(x, ROOF_HEIGHT - 2, z);
        scene.add(fluorLight);
        fluorLights.push(fluorLight);

        // Visible fluorescent tube (emissive mesh)
        const tubeGeo = new THREE.BoxGeometry(8, 0.3, 1);
        const tubeMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xeeffff,
            emissiveIntensity: 2
        });
        const tube = new THREE.Mesh(tubeGeo, tubeMat);
        tube.position.set(x, ROOF_HEIGHT - 1, z);
        scene.add(tube);
    }
}

// Subtle fill light for visibility
const rimLight = new THREE.DirectionalLight(0xaaaacc, 0.1);
rimLight.position.set(5, 10, 5);
scene.add(rimLight);

// Muzzle flash light
const muzzleLight = new THREE.PointLight(0xffaa00, 0, 30);
muzzleLight.castShadow = false;
scene.add(muzzleLight);

// Secondary fill light that follows camera for gun visibility (warm tint)
const gunFillLight = new THREE.PointLight(0xffaa77, 0.4, 15);
gunFillLight.position.set(0, -0.3, 0.5);
camera.add(gunFillLight);

// Initialize textures FIRST so they are available for everything
const concreteTex = TextureFactory.concrete();
const brickTex = TextureFactory.brick();
const woodTex = TextureFactory.wood();
const metalTexDark = TextureFactory.metal(true);
const metalTexLight = TextureFactory.metal(false);

// Concrete Floor (Bright)
const floorMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, 
    color: 0xdddddd, // Light grey
    roughness: 0.8, 
    metalness: 0.1,
    bumpMap: concreteTex,
    bumpScale: 0.05
});
// Larger arena for zombie swarms
const MAP_SIZE = 140;
const MAP_HALF = MAP_SIZE / 2;

const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), floorMat);
floor.rotation.x = -Math.PI / 2; floor.position.y = -5; floor.receiveShadow = true;
scene.add(floor);

// ============ ROOF/CEILING ============
// Create industrial ceiling texture
const ceilingTexCanvas = document.createElement('canvas');
ceilingTexCanvas.width = 256;
ceilingTexCanvas.height = 256;
const ceilCtx = ceilingTexCanvas.getContext('2d');

// Base ceiling color (industrial gray)
ceilCtx.fillStyle = '#404045';
ceilCtx.fillRect(0, 0, 256, 256);

// Add ceiling tile grid pattern
ceilCtx.strokeStyle = '#353538';
ceilCtx.lineWidth = 2;
const tileSize = 64;
for (let x = 0; x <= 256; x += tileSize) {
    ceilCtx.beginPath();
    ceilCtx.moveTo(x, 0);
    ceilCtx.lineTo(x, 256);
    ceilCtx.stroke();
}
for (let y = 0; y <= 256; y += tileSize) {
    ceilCtx.beginPath();
    ceilCtx.moveTo(0, y);
    ceilCtx.lineTo(256, y);
    ceilCtx.stroke();
}

// Add some subtle variation/stains
for (let i = 0; i < 20; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 5 + Math.random() * 20;
    ceilCtx.fillStyle = `rgba(${Math.random() > 0.5 ? 50 : 30}, ${Math.random() > 0.5 ? 50 : 30}, ${Math.random() > 0.5 ? 52 : 32}, 0.3)`;
    ceilCtx.beginPath();
    ceilCtx.arc(x, y, radius, 0, Math.PI * 2);
    ceilCtx.fill();
}

const ceilingTex = new THREE.CanvasTexture(ceilingTexCanvas);
ceilingTex.wrapS = ceilingTex.wrapT = THREE.RepeatWrapping;
ceilingTex.repeat.set(4, 4);

const ceilingMat = new THREE.MeshStandardMaterial({
    map: ceilingTex,
    color: 0x555560,
    roughness: 0.9,
    side: THREE.BackSide // Visible from below
});

const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE + 10, MAP_SIZE + 10), ceilingMat);
ceiling.rotation.x = -Math.PI / 2;
ceiling.position.y = ROOF_HEIGHT;
ceiling.receiveShadow = false;
scene.add(ceiling);

// ============ CENTRAL HILL ============
const HILL_RADIUS = 18;
const HILL_HEIGHT = 5;
const HILL_CENTER_X = 0;
const HILL_CENTER_Z = 0;

// Create smooth mound geometry (hemisphere-like)
const hillSegments = 32;
const hillGeo = new THREE.BufferGeometry();
const hillVertices = [];
const hillIndices = [];
const hillUvs = [];
const hillNormals = [];

// Generate vertices for a smooth dome/mound
for (let ring = 0; ring <= hillSegments; ring++) {
    const ringRatio = ring / hillSegments;
    const radius = HILL_RADIUS * ringRatio;
    const height = HILL_HEIGHT * Math.cos(ringRatio * Math.PI / 2); // Cosine falloff for smooth hill

    for (let seg = 0; seg <= hillSegments; seg++) {
        const angle = (seg / hillSegments) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = height;

        hillVertices.push(x, y, z);
        hillUvs.push(seg / hillSegments, ring / hillSegments);

        // Calculate normal (pointing outward/upward)
        const nx = Math.cos(angle) * ringRatio * 0.5;
        const ny = 1 - ringRatio * 0.5;
        const nz = Math.sin(angle) * ringRatio * 0.5;
        const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz);
        hillNormals.push(nx / nLen, ny / nLen, nz / nLen);
    }
}

// Generate indices (reversed winding for outward-facing normals)
for (let ring = 0; ring < hillSegments; ring++) {
    for (let seg = 0; seg < hillSegments; seg++) {
        const curr = ring * (hillSegments + 1) + seg;
        const next = curr + hillSegments + 1;

        // Correct winding order for visible from outside
        hillIndices.push(curr, curr + 1, next);
        hillIndices.push(curr + 1, next + 1, next);
    }
}

hillGeo.setAttribute('position', new THREE.Float32BufferAttribute(hillVertices, 3));
hillGeo.setAttribute('uv', new THREE.Float32BufferAttribute(hillUvs, 2));
hillGeo.setAttribute('normal', new THREE.Float32BufferAttribute(hillNormals, 3));
hillGeo.setIndex(hillIndices);

// Procedural grass texture for hill
const grassTexCanvas = document.createElement('canvas');
grassTexCanvas.width = 256;
grassTexCanvas.height = 256;
const grassCtx = grassTexCanvas.getContext('2d');

// Base grass green
grassCtx.fillStyle = '#3d5c28';
grassCtx.fillRect(0, 0, 256, 256);

// Add grass blade variations
for (let i = 0; i < 2000; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const length = 3 + Math.random() * 8;
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;

    // Vary green shades
    const shade = Math.floor(Math.random() * 40);
    const r = 45 + shade;
    const g = 80 + Math.floor(Math.random() * 30);
    const b = 30 + Math.floor(Math.random() * 20);

    grassCtx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
    grassCtx.lineWidth = 1 + Math.random();
    grassCtx.beginPath();
    grassCtx.moveTo(x, y);
    grassCtx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    grassCtx.stroke();
}

// Add some darker patches for depth
for (let i = 0; i < 30; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 5 + Math.random() * 15;
    grassCtx.fillStyle = 'rgba(30, 50, 20, 0.3)';
    grassCtx.beginPath();
    grassCtx.arc(x, y, radius, 0, Math.PI * 2);
    grassCtx.fill();
}

// Add lighter highlights
for (let i = 0; i < 20; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 3 + Math.random() * 10;
    grassCtx.fillStyle = 'rgba(100, 140, 60, 0.2)';
    grassCtx.beginPath();
    grassCtx.arc(x, y, radius, 0, Math.PI * 2);
    grassCtx.fill();
}

const grassTex = new THREE.CanvasTexture(grassTexCanvas);
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
grassTex.repeat.set(4, 4);

// Hill material - lush green grass
const hillMat = new THREE.MeshStandardMaterial({
    map: grassTex,
    color: 0x4a7030,
    roughness: 0.9,
    bumpMap: grassTex,
    bumpScale: 0.15
});

const hill = new THREE.Mesh(hillGeo, hillMat);
hill.position.set(HILL_CENTER_X, -5, HILL_CENTER_Z);
hill.receiveShadow = true;
hill.castShadow = true;
scene.add(hill);

// Terrain height function - returns Y position at any world X/Z
function getTerrainHeight(x, z) {
    const dx = x - HILL_CENTER_X;
    const dz = z - HILL_CENTER_Z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist >= HILL_RADIUS) {
        return -5; // Base ground level
    }

    // Smooth cosine falloff for natural hill shape
    const ratio = dist / HILL_RADIUS;
    const height = HILL_HEIGHT * Math.cos(ratio * Math.PI / 2);
    return -5 + height;
}

// Check if a position is on the hill (for spawn avoidance)
function isOnHill(x, z, margin = 2) {
    const dx = x - HILL_CENTER_X;
    const dz = z - HILL_CENTER_Z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    return dist < (HILL_RADIUS + margin);
}

// Walls (Concrete/Light Brick)
const wallMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, // Switched to concrete to match photo style
    color: 0xbbbbbb,
    roughness: 0.9, 
    bumpMap: concreteTex, 
    bumpScale: 0.1 
});
const wallGeo = new THREE.PlaneGeometry(MAP_SIZE, 50);
const wall1 = new THREE.Mesh(wallGeo, wallMat); wall1.position.set(0, 20, -MAP_HALF); wall1.receiveShadow = true; scene.add(wall1);
const wall2 = new THREE.Mesh(wallGeo, wallMat); wall2.position.set(0, 20, MAP_HALF); wall2.rotation.y = Math.PI; wall2.receiveShadow = true; scene.add(wall2);
const wall3 = new THREE.Mesh(wallGeo, wallMat); wall3.position.set(-MAP_HALF, 20, 0); wall3.rotation.y = Math.PI/2; wall3.receiveShadow = true; scene.add(wall3);
const wall4 = new THREE.Mesh(wallGeo, wallMat); wall4.position.set(MAP_HALF, 20, 0); wall4.rotation.y = -Math.PI/2; wall4.receiveShadow = true; scene.add(wall4);

// ============ SPAWN DOORS ============
const DOOR_WIDTH = 4;
const DOOR_HEIGHT = 6;
const DOOR_DEPTH = 1.5;

// Dark rusty metal door material
const doorMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.7,
    metalness: 0.8,
    emissive: 0x000000
});

// Door frame material (slightly lighter)
const doorFrameMat = new THREE.MeshStandardMaterial({
    color: 0x2a2a2a,
    roughness: 0.6,
    metalness: 0.7
});

// Create door geometry
const doorGeo = new THREE.BoxGeometry(DOOR_WIDTH, DOOR_HEIGHT, DOOR_DEPTH);
const doorFrameGeo = new THREE.BoxGeometry(DOOR_WIDTH + 0.6, DOOR_HEIGHT + 0.4, DOOR_DEPTH + 0.2);

// Spawn doors array (stores door objects and spawn positions)
const spawnDoors = [];

// Create doors on each wall (2 per wall = 8 total)
function createSpawnDoor(x, z, rotationY, wallSide) {
    const doorGroup = new THREE.Group();

    // Door frame (dark background)
    const frame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
    frame.position.y = 0;
    frame.castShadow = true;
    frame.receiveShadow = true;
    doorGroup.add(frame);

    // Left door panel
    const leftDoor = new THREE.Mesh(
        new THREE.BoxGeometry(DOOR_WIDTH / 2 - 0.1, DOOR_HEIGHT - 0.4, 0.3),
        doorMat.clone()
    );
    leftDoor.position.set(-DOOR_WIDTH / 4, 0, DOOR_DEPTH / 2 + 0.1);
    leftDoor.castShadow = true;
    leftDoor.userData.originalX = leftDoor.position.x;
    leftDoor.userData.isLeftDoor = true;
    doorGroup.add(leftDoor);

    // Right door panel
    const rightDoor = new THREE.Mesh(
        new THREE.BoxGeometry(DOOR_WIDTH / 2 - 0.1, DOOR_HEIGHT - 0.4, 0.3),
        doorMat.clone()
    );
    rightDoor.position.set(DOOR_WIDTH / 4, 0, DOOR_DEPTH / 2 + 0.1);
    rightDoor.castShadow = true;
    rightDoor.userData.originalX = rightDoor.position.x;
    rightDoor.userData.isRightDoor = true;
    doorGroup.add(rightDoor);

    // Red warning light above door
    const warningLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshStandardMaterial({
            color: 0x330000,
            emissive: 0x330000,
            emissiveIntensity: 0.5
        })
    );
    warningLight.position.set(0, DOOR_HEIGHT / 2 + 0.5, DOOR_DEPTH / 2);
    doorGroup.add(warningLight);

    // ============ OBSERVATION WINDOW ============
    // Large window above door where scientists observe
    const WINDOW_WIDTH = DOOR_WIDTH + 2;
    const WINDOW_HEIGHT = 3;
    const WINDOW_Y = DOOR_HEIGHT / 2 + 3; // Above the door

    // Window frame (dark metal)
    const windowFrameMat = new THREE.MeshStandardMaterial({
        color: 0x1a1a1a,
        roughness: 0.4,
        metalness: 0.9
    });
    const windowFrame = new THREE.Mesh(
        new THREE.BoxGeometry(WINDOW_WIDTH + 0.4, WINDOW_HEIGHT + 0.4, 0.3),
        windowFrameMat
    );
    windowFrame.position.set(0, WINDOW_Y, DOOR_DEPTH / 2 - 0.1);
    windowFrame.castShadow = true;
    doorGroup.add(windowFrame);

    // Glass pane (slightly reflective, dark tinted)
    const glassMat = new THREE.MeshStandardMaterial({
        color: 0x112233,
        roughness: 0.1,
        metalness: 0.3,
        transparent: true,
        opacity: 0.7,
        emissive: 0x0a1520,
        emissiveIntensity: 0.3
    });
    const glass = new THREE.Mesh(
        new THREE.BoxGeometry(WINDOW_WIDTH, WINDOW_HEIGHT, 0.1),
        glassMat
    );
    glass.position.set(0, WINDOW_Y, DOOR_DEPTH / 2 + 0.05);
    doorGroup.add(glass);

    // Interior light (warm fluorescent glow behind glass)
    const interiorLight = new THREE.Mesh(
        new THREE.PlaneGeometry(WINDOW_WIDTH - 0.5, WINDOW_HEIGHT - 0.5),
        new THREE.MeshBasicMaterial({
            color: 0x556677,
            transparent: true,
            opacity: 0.4
        })
    );
    interiorLight.position.set(0, WINDOW_Y, DOOR_DEPTH / 2 - 0.2);
    doorGroup.add(interiorLight);

    // Scientist silhouettes (dark figures watching)
    const silhouetteMat = new THREE.MeshBasicMaterial({
        color: 0x050505,
        transparent: true,
        opacity: 0.85
    });

    // Create 1-3 scientist silhouettes per window
    const numScientists = 1 + Math.floor(Math.random() * 2);
    for (let s = 0; s < numScientists; s++) {
        const silhouetteGroup = new THREE.Group();

        // Head (circle)
        const head = new THREE.Mesh(
            new THREE.CircleGeometry(0.25, 8),
            silhouetteMat
        );
        head.position.y = 0.9;
        silhouetteGroup.add(head);

        // Body (torso shape)
        const bodyShape = new THREE.Shape();
        bodyShape.moveTo(-0.35, 0.6);
        bodyShape.lineTo(0.35, 0.6);
        bodyShape.lineTo(0.45, -0.8);
        bodyShape.lineTo(-0.45, -0.8);
        bodyShape.closePath();
        const body = new THREE.Mesh(
            new THREE.ShapeGeometry(bodyShape),
            silhouetteMat
        );
        silhouetteGroup.add(body);

        // Shoulders (wider at top)
        const shoulders = new THREE.Mesh(
            new THREE.PlaneGeometry(0.9, 0.25),
            silhouetteMat
        );
        shoulders.position.y = 0.55;
        silhouetteGroup.add(shoulders);

        // Position scientist in window
        const spreadX = (numScientists === 1) ? 0 : (s - (numScientists - 1) / 2) * 1.8;
        const offsetZ = Math.random() * 0.3; // Slight depth variation
        silhouetteGroup.position.set(spreadX, WINDOW_Y - 0.3, DOOR_DEPTH / 2 - 0.15 - offsetZ);
        silhouetteGroup.scale.setScalar(0.9 + Math.random() * 0.2);
        doorGroup.add(silhouetteGroup);
    }

    // Position the door group
    doorGroup.position.set(x, DOOR_HEIGHT / 2 - 5, z); // -5 is floor offset
    doorGroup.rotation.y = rotationY;
    scene.add(doorGroup);

    // Calculate spawn position (slightly in front of door)
    const spawnOffset = 3;
    let spawnX = x, spawnZ = z;
    switch (wallSide) {
        case 'north': spawnZ += spawnOffset; break;
        case 'south': spawnZ -= spawnOffset; break;
        case 'west': spawnX += spawnOffset; break;
        case 'east': spawnX -= spawnOffset; break;
    }

    spawnDoors.push({
        group: doorGroup,
        leftDoor: leftDoor,
        rightDoor: rightDoor,
        warningLight: warningLight,
        spawnX: spawnX,
        spawnZ: spawnZ,
        isOpen: false,
        openTimer: 0
    });
}

// Create doors on each wall (3 per wall for larger arena = 12 total)
// North wall (z = -MAP_HALF): 3 doors
createSpawnDoor(-40, -MAP_HALF + 0.5, 0, 'north');
createSpawnDoor(0, -MAP_HALF + 0.5, 0, 'north');
createSpawnDoor(40, -MAP_HALF + 0.5, 0, 'north');

// South wall (z = MAP_HALF): 3 doors
createSpawnDoor(-40, MAP_HALF - 0.5, Math.PI, 'south');
createSpawnDoor(0, MAP_HALF - 0.5, Math.PI, 'south');
createSpawnDoor(40, MAP_HALF - 0.5, Math.PI, 'south');

// West wall (x = -MAP_HALF): 3 doors
createSpawnDoor(-MAP_HALF + 0.5, -40, Math.PI / 2, 'west');
createSpawnDoor(-MAP_HALF + 0.5, 0, Math.PI / 2, 'west');
createSpawnDoor(-MAP_HALF + 0.5, 40, Math.PI / 2, 'west');

// East wall (x = MAP_HALF): 3 doors
createSpawnDoor(MAP_HALF - 0.5, -40, -Math.PI / 2, 'east');
createSpawnDoor(MAP_HALF - 0.5, 0, -Math.PI / 2, 'east');
createSpawnDoor(MAP_HALF - 0.5, 40, -Math.PI / 2, 'east');

// Door animation function
function openDoor(door) {
    if (door.isOpen) return;
    door.isOpen = true;
    door.openTimer = 0;

    // Flash warning light red
    door.warningLight.material.emissive.setHex(0xff0000);
    door.warningLight.material.emissiveIntensity = 2;

    // Play door sound
    playSound('doorOpen');
}

function updateDoors(dt) {
    for (const door of spawnDoors) {
        if (door.isOpen) {
            door.openTimer += dt;

            // Animate doors sliding open (0 to 0.3 seconds)
            const openProgress = Math.min(door.openTimer / 0.3, 1);
            const eased = 1 - Math.pow(1 - openProgress, 3); // ease out cubic

            door.leftDoor.position.x = door.leftDoor.userData.originalX - (DOOR_WIDTH / 2) * eased;
            door.rightDoor.position.x = door.rightDoor.userData.originalX + (DOOR_WIDTH / 2) * eased;

            // Close door after 1.5 seconds
            if (door.openTimer > 1.5) {
                door.isOpen = false;
                door.openTimer = 0;
                door.warningLight.material.emissive.setHex(0x330000);
                door.warningLight.material.emissiveIntensity = 0.5;
            }
        } else if (door.leftDoor.position.x !== door.leftDoor.userData.originalX) {
            // Animate closing
            door.openTimer += dt;
            const closeProgress = Math.min(door.openTimer / 0.5, 1);
            const eased = 1 - Math.pow(1 - closeProgress, 2);

            door.leftDoor.position.x = door.leftDoor.userData.originalX - (DOOR_WIDTH / 2) * (1 - eased);
            door.rightDoor.position.x = door.rightDoor.userData.originalX + (DOOR_WIDTH / 2) * (1 - eased);

            if (closeProgress >= 1) {
                door.openTimer = 0;
            }
        }
    }
}

const targets = [];
targets.push(floor, hill, wall1, wall2, wall3, wall4);

// ============ COLLISION SYSTEM ============
// Get bounding box for an object (handles world transforms)
function getBoundingBox(obj) {
    const box = new THREE.Box3();
    box.setFromObject(obj);
    return box;
}

// Check if a circular entity at (x, z) with radius collides with walls or obstacles
function checkCollision(x, z, radius, excludeObj = null) {
    // Check walls (map boundaries)
    if (Math.abs(x) + radius > MAP_HALF || Math.abs(z) + radius > MAP_HALF) {
        return true;
    }

    // Check obstacles
    for (const obstacle of obstacles) {
        if (obstacle === excludeObj) continue;

        const box = getBoundingBox(obstacle);
        const centerX = (box.min.x + box.max.x) / 2;
        const centerZ = (box.min.z + box.max.z) / 2;
        const sizeX = box.max.x - box.min.x;
        const sizeZ = box.max.z - box.min.z;
        const obstacleRadius = Math.max(sizeX, sizeZ) / 2;

        const dx = x - centerX;
        const dz = z - centerZ;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < radius + obstacleRadius) {
            return true;
        }
    }

    return false;
}

// Enhanced collision detection that returns obstacle info for better avoidance
function checkCollisionAdvanced(x, z, radius, excludeObj = null) {
    // Check walls (map boundaries)
    if (Math.abs(x) + radius > MAP_HALF || Math.abs(z) + radius > MAP_HALF) {
        // Calculate normal from nearest wall
        let normalX = 0, normalZ = 0;
        if (x + radius > MAP_HALF) normalX = -1;
        else if (x - radius < -MAP_HALF) normalX = 1;
        if (z + radius > MAP_HALF) normalZ = -1;
        else if (z - radius < -MAP_HALF) normalZ = 1;

        // Normalize
        const mag = Math.sqrt(normalX * normalX + normalZ * normalZ);
        if (mag > 0) {
            normalX /= mag;
            normalZ /= mag;
        }

        return { collided: true, normalX, normalZ, isWall: true };
    }

    // Check obstacles
    for (const obstacle of obstacles) {
        if (obstacle === excludeObj) continue;

        const box = getBoundingBox(obstacle);
        const centerX = (box.min.x + box.max.x) / 2;
        const centerZ = (box.min.z + box.max.z) / 2;
        const sizeX = box.max.x - box.min.x;
        const sizeZ = box.max.z - box.min.z;
        const obstacleRadius = Math.max(sizeX, sizeZ) / 2;

        const dx = x - centerX;
        const dz = z - centerZ;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < radius + obstacleRadius) {
            // Calculate normal (direction from obstacle to entity)
            let normalX = dx;
            let normalZ = dz;
            if (dist > 0.01) {
                normalX /= dist;
                normalZ /= dist;
            } else {
                // Directly on top - push in random direction
                const angle = Math.random() * Math.PI * 2;
                normalX = Math.cos(angle);
                normalZ = Math.sin(angle);
            }

            return { collided: true, normalX, normalZ, isWall: false, obstacle };
        }
    }

    return { collided: false, normalX: 0, normalZ: 0 };
}

// Resolve collision by sliding along walls/obstacles with improved physics
function resolveCollision(oldX, oldZ, newX, newZ, radius, excludeObj = null) {
    // Try new position
    const collision = checkCollisionAdvanced(newX, newZ, radius, excludeObj);
    if (!collision.collided) {
        return { x: newX, z: newZ, collided: false };
    }

    // Calculate movement vector
    const moveX = newX - oldX;
    const moveZ = newZ - oldZ;
    const moveMag = Math.sqrt(moveX * moveX + moveZ * moveZ);

    if (moveMag < 0.001) {
        return { x: oldX, z: oldZ, collided: true };
    }

    // Project movement onto surface (slide along obstacle)
    // Slide direction = movement - (movement dot normal) * normal
    const dotProduct = moveX * collision.normalX + moveZ * collision.normalZ;
    const slideX = moveX - dotProduct * collision.normalX;
    const slideZ = moveZ - dotProduct * collision.normalZ;

    // Try sliding position
    const slideNewX = oldX + slideX;
    const slideNewZ = oldZ + slideZ;

    if (!checkCollision(slideNewX, slideNewZ, radius, excludeObj)) {
        return { x: slideNewX, z: slideNewZ, collided: true };
    }

    // If slide failed, try axis-aligned movement (legacy fallback)
    // Try sliding along X axis only
    if (!checkCollision(newX, oldZ, radius, excludeObj)) {
        return { x: newX, z: oldZ, collided: true };
    }

    // Try sliding along Z axis only
    if (!checkCollision(oldX, newZ, radius, excludeObj)) {
        return { x: oldX, z: newZ, collided: true };
    }

    // Can't move, stay at old position
    return { x: oldX, z: oldZ, collided: true };
}

// Better Obstacles
const barrierMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
const drumMat = new THREE.MeshStandardMaterial({ map: metalTexDark, roughness: 0.4, metalness: 0.8, color: 0x553333 });
// Wood crates like the photo
const crateMat = new THREE.MeshStandardMaterial({ map: woodTex, color: 0x886644, roughness: 0.7 });
const obstacles = []; // Store obstacle references for target placement

for(let i=0; i<30; i++) {
    let mesh;
    const r = Math.random();
    if(r > 0.6) {
        // Wooden Crate
        mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), crateMat);
        mesh.position.y = -3.5;
    } else if (r > 0.3) {
        // Concrete Jersey Barrier
        mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 2.5, 1), barrierMat);
        mesh.position.y = -3.75;
    } else {
        // Steel Drum
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 16), drumMat);
        mesh.position.y = -3.5;
    }

    // Find position that's NOT on the hill
    let posX, posZ;
    let attempts = 0;
    do {
        posX = (Math.random() - 0.5) * (MAP_SIZE - 10);
        posZ = (Math.random() - 0.5) * (MAP_SIZE - 10);
        attempts++;
    } while (isOnHill(posX, posZ, 3) && attempts < 50); // margin of 3 to keep obstacles clear of hill edge

    mesh.position.x = posX;
    mesh.position.z = posZ;
    mesh.rotation.y = Math.random() * Math.PI;
    mesh.castShadow = true; mesh.receiveShadow = true;
    scene.add(mesh);
    targets.push(mesh);
    obstacles.push(mesh); // Store for target placement
}

// SHOOTING TARGETS
const shootingTargets = [];

// Create target geometry (silhouette shape)
function createTargetMesh() {
    const group = new THREE.Group();

    // Head
    const headGeo = new THREE.CircleGeometry(0.8, 16);
    const targetMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.8,
        side: THREE.DoubleSide
    });
    const head = new THREE.Mesh(headGeo, targetMat);
    head.position.y = 3.2;
    group.add(head);

    // Body (torso)
    const bodyGeo = new THREE.PlaneGeometry(1.6, 2.4);
    const body = new THREE.Mesh(bodyGeo, targetMat);
    body.position.y = 1.6;
    group.add(body);

    // Base/stand
    const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
    const standGeo = new THREE.BoxGeometry(0.15, 4.4, 0.15);
    const stand = new THREE.Mesh(standGeo, standMat);
    stand.position.y = 2.0;
    stand.position.z = 0.15;
    group.add(stand);

    const baseGeo = new THREE.BoxGeometry(1.2, 0.15, 0.8);
    const base = new THREE.Mesh(baseGeo, standMat);
    base.position.y = -0.05;
    group.add(base);

    return group;
}

// Target class
class ShootingTarget {
    constructor(position) {
        this.mesh = createTargetMesh();
        this.mesh.position.copy(position);
        this.mesh.position.y = -5; // Ground level

        this.pivotPoint = new THREE.Group();
        this.pivotPoint.position.copy(this.mesh.position);
        this.pivotPoint.add(this.mesh);
        this.mesh.position.set(0, 0, 0);

        scene.add(this.pivotPoint);

        this.isUp = false;
        this.isAnimating = false;
        this.rotation = 0;
        this.targetRotation = Math.PI / 2; // Fallen state

        // Add hitbox to raycast targets
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4, 0.5),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2;
        this.pivotPoint.add(this.hitbox);
        this.hitbox.userData.isTarget = true;
        this.hitbox.userData.targetRef = this;
        targets.push(this.hitbox);
    }

    popup(obstacle) {
        if (this.isAnimating) return;
        this.isAnimating = true;

        // Position behind obstacle
        const pos = obstacle.position.clone();
        pos.x += (Math.random() - 0.5) * 2;
        pos.z += (Math.random() > 0.5 ? 2 : -2);
        this.pivotPoint.position.set(pos.x, -5, pos.z);
        this.pivotPoint.rotation.y = Math.atan2(
            camera.position.x - pos.x,
            camera.position.z - pos.z
        );

        // Animate up
        this.targetRotation = 0;
        this.isUp = true;
    }

    knockDown() {
        if (!this.isUp || this.isAnimating) return;
        this.isAnimating = true;
        this.targetRotation = Math.PI / 2;
        this.isUp = false;

        // Schedule popup at new location
        setTimeout(() => {
            if (obstacles.length > 0) {
                const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                this.popup(randomObstacle);
            }
        }, 1500 + Math.random() * 2000);
    }

    update(dt) {
        // Smooth rotation animation
        const diff = this.targetRotation - this.rotation;
        if (Math.abs(diff) > 0.01) {
            this.rotation += diff * 8 * dt;
            this.pivotPoint.rotation.x = -this.rotation;
        } else {
            this.rotation = this.targetRotation;
            this.isAnimating = false;
        }
    }
}

// Create shooting targets
for (let i = 0; i < 8; i++) {
    const target = new ShootingTarget(new THREE.Vector3(0, -5, 0));
    shootingTargets.push(target);

    // Spawn at random obstacle after delay
    setTimeout(() => {
        if (obstacles.length > 0) {
            const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            target.popup(randomObstacle);
        }
    }, 1000 + i * 500);
}

// ZOMBIES
const zombies = [];

// Zombie materials - decayed greenish-grey skin
const zombieSkinMat = new THREE.MeshStandardMaterial({ color: 0x5a6b4a, roughness: 0.9 });
const zombieSkinDarkMat = new THREE.MeshStandardMaterial({ color: 0x3d4a35, roughness: 0.9 });

// Create tattered shirt texture
const shirtTexCanvas = document.createElement('canvas');
shirtTexCanvas.width = 256; shirtTexCanvas.height = 256;
const shirtTexCtx = shirtTexCanvas.getContext('2d');
// Base dirty brown/grey color
shirtTexCtx.fillStyle = '#3a3530';
shirtTexCtx.fillRect(0, 0, 256, 256);
// Add blood stains
shirtTexCtx.fillStyle = '#4a1515';
for (let i = 0; i < 8; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.arc(Math.random() * 256, Math.random() * 256, 15 + Math.random() * 30, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add tears/holes (dark spots)
shirtTexCtx.fillStyle = '#1a1a1a';
for (let i = 0; i < 5; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.ellipse(Math.random() * 256, Math.random() * 256, 8 + Math.random() * 15, 4 + Math.random() * 10, Math.random() * Math.PI, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add dirt streaks
shirtTexCtx.strokeStyle = '#2a2520';
shirtTexCtx.lineWidth = 3;
for (let i = 0; i < 10; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.moveTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.lineTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.stroke();
}
const shirtTex = new THREE.CanvasTexture(shirtTexCanvas);

const zombieShirtMat = new THREE.MeshStandardMaterial({ map: shirtTex, roughness: 0.8 });
const zombiePantsMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.8 });

// ============ ZOMBIE VARIANTS ============
const ZOMBIE_VARIANTS = {
    normal: {
        name: 'Normal',
        scale: 1.0,
        healthMod: 1.0,
        speedMod: 1.0,
        damageMod: 1.0,
        skinColor: 0x5a6b4a,     // Gray-green
        skinColorDark: 0x3d4a35,
        shirtColor: null,        // Use default texture
        pantsColor: 0x252525,
        spawnWeight: 50          // Higher = more common
    },
    runner: {
        name: 'Runner',
        scale: 0.85,
        healthMod: 0.5,          // Low health
        speedMod: 1.8,           // Very fast
        damageMod: 0.7,
        skinColor: 0x8a9a8a,     // Pale gray
        skinColorDark: 0x6a7a6a,
        shirtColor: 0x444444,
        pantsColor: 0x333333,
        spawnWeight: 25
    },
    brute: {
        name: 'Brute',
        scale: 1.5,
        healthMod: 12.0,         // Extremely tanky (was 3.0)
        speedMod: 0.55,          // Slow
        damageMod: 3.0,          // Hits extremely hard
        skinColor: 0x4a2525,     // Dark red/brown
        skinColorDark: 0x351818,
        shirtColor: 0x2a1515,
        pantsColor: 0x1a1010,
        spawnWeight: 10
    },
    crawler: {
        name: 'Crawler',
        scale: 0.65,
        healthMod: 0.8,
        speedMod: 0.7,
        damageMod: 1.2,
        skinColor: 0x5a4a35,     // Rotted brown
        skinColorDark: 0x3d3020,
        shirtColor: 0x352a20,
        pantsColor: 0x252015,
        spawnWeight: 15
    }
};

// Pick random variant based on wave and weights
function pickZombieVariant(waveNum) {
    // Early waves: mostly normal zombies
    // Later waves: more special variants
    const variantChance = Math.min(0.6, 0.1 + waveNum * 0.05);

    if (Math.random() > variantChance) {
        return 'normal';
    }

    // Pick weighted random variant (excluding normal for special spawn)
    const specialVariants = ['runner', 'brute', 'crawler'];
    let weights = specialVariants.map(v => {
        let w = ZOMBIE_VARIANTS[v].spawnWeight;
        // Brutes more common in later waves
        if (v === 'brute' && waveNum >= 5) w *= 1.5;
        // Runners more common early
        if (v === 'runner' && waveNum < 3) w *= 1.5;
        return w;
    });

    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let roll = Math.random() * totalWeight;

    for (let i = 0; i < specialVariants.length; i++) {
        roll -= weights[i];
        if (roll <= 0) return specialVariants[i];
    }

    return 'normal';
}

function createZombieMesh(variant = 'normal') {
    const config = ZOMBIE_VARIANTS[variant] || ZOMBIE_VARIANTS.normal;
    const group = new THREE.Group();
    const baseScale = 2.0;
    const scale = baseScale * config.scale;

    // Create variant-specific materials
    const variantSkinMat = new THREE.MeshStandardMaterial({
        color: config.skinColor,
        roughness: 0.9
    });
    const variantSkinDarkMat = new THREE.MeshStandardMaterial({
        color: config.skinColorDark,
        roughness: 0.9
    });
    const variantShirtMat = config.shirtColor
        ? new THREE.MeshStandardMaterial({ color: config.shirtColor, roughness: 0.8 })
        : zombieShirtMat;
    const variantPantsMat = new THREE.MeshStandardMaterial({
        color: config.pantsColor,
        roughness: 0.8
    });

    // Head - variant colored zombie skin
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.35 * scale, 12, 8), variantSkinMat);
    head.position.y = 1.85 * scale;
    head.castShadow = true;
    group.add(head);

    // Torso - variant shirt
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale), variantShirtMat);
    torso.position.y = 1.1 * scale;
    torso.castShadow = true;
    group.add(torso);

    // Arms - zombie skin, arms extended forward
    const armGeo = new THREE.BoxGeometry(0.2 * scale, 0.7 * scale, 0.2 * scale);
    const leftArm = new THREE.Mesh(armGeo, variantSkinMat);
    leftArm.position.set(-0.45 * scale, 1.3 * scale, 0.4 * scale);
    leftArm.rotation.x = -Math.PI / 3; // Arms reaching forward
    leftArm.castShadow = true;
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, variantSkinDarkMat);
    rightArm.position.set(0.45 * scale, 1.3 * scale, 0.4 * scale);
    rightArm.rotation.x = -Math.PI / 3;
    rightArm.castShadow = true;
    group.add(rightArm);

    // Legs - variant pants
    const legGeo = new THREE.BoxGeometry(0.25 * scale, 0.8 * scale, 0.25 * scale);
    const leftLeg = new THREE.Mesh(legGeo, variantPantsMat);
    leftLeg.position.set(-0.2 * scale, 0.4 * scale, 0);
    leftLeg.castShadow = true;
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, variantPantsMat);
    rightLeg.position.set(0.2 * scale, 0.4 * scale, 0);
    rightLeg.castShadow = true;
    group.add(rightLeg);

    // Store variant info on group for reference
    group.userData.variant = variant;
    group.userData.variantScale = config.scale;

    return group;
}

// ============ HIVE MIND - SHARED ZOMBIE INTELLIGENCE ============
const HiveMind = {
    // Shared state (updated once per frame, all zombies reference)
    playerPos: { x: 0, z: 0 },
    playerVelocity: { x: 0, z: 0 },
    threatDirection: { x: 0, z: 0 },  // Where player is shooting/aiming
    threatIntensity: 0,                 // How much threat (0-1)
    
    // Flanking system - 8 positions around player
    flankSlots: [],
    flankRadius: 8.0,                    // Distance from player for flanking
    numFlankSlots: 8,
    
    // Performance tracking
    frameCounter: 0,
    
    // Update shared intelligence (called once per frame)
    update(dt) {
        this.frameCounter++;
        
        // Track player position and velocity
        const oldX = this.playerPos.x;
        const oldZ = this.playerPos.z;
        this.playerPos.x = camera.position.x;
        this.playerPos.z = camera.position.z;
        
        // Calculate player velocity (smoothed)
        const velX = (this.playerPos.x - oldX) / dt;
        const velZ = (this.playerPos.z - oldZ) / dt;
        this.playerVelocity.x = THREE.MathUtils.lerp(this.playerVelocity.x, velX, 0.3);
        this.playerVelocity.z = THREE.MathUtils.lerp(this.playerVelocity.z, velZ, 0.3);
        
        // Calculate threat direction (where player is aiming)
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);
        this.threatDirection.x = cameraDir.x;
        this.threatDirection.z = cameraDir.z;
        
        // Update threat intensity (higher when player is shooting/aiming)
        if (isFiring) {
            this.threatIntensity = Math.min(1.0, this.threatIntensity + dt * 5);
        } else {
            this.threatIntensity = Math.max(0, this.threatIntensity - dt * 2);
        }
        
        // Precompute flank positions around player (once per frame)
        const angleStep = (Math.PI * 2) / this.numFlankSlots;
        this.flankSlots = [];
        for (let i = 0; i < this.numFlankSlots; i++) {
            const angle = i * angleStep;
            this.flankSlots.push({
                x: this.playerPos.x + Math.cos(angle) * this.flankRadius,
                z: this.playerPos.z + Math.sin(angle) * this.flankRadius,
                angle: angle,
                occupied: false,
                occupiedBy: null
            });
        }
    },
    
    // Find best available flank slot for a zombie
    claimFlankSlot(zombie) {
        // Find closest unoccupied slot
        let bestSlot = null;
        let bestDist = Infinity;
        
        for (const slot of this.flankSlots) {
            if (slot.occupied && slot.occupiedBy !== zombie) continue;
            
            const dx = slot.x - zombie.mesh.position.x;
            const dz = slot.z - zombie.mesh.position.z;
            const dist = dx * dx + dz * dz; // Squared distance
            
            if (dist < bestDist) {
                bestDist = dist;
                bestSlot = slot;
            }
        }
        
        if (bestSlot) {
            // Release old slot if zombie had one
            for (const slot of this.flankSlots) {
                if (slot.occupiedBy === zombie) {
                    slot.occupied = false;
                    slot.occupiedBy = null;
                }
            }
            
            bestSlot.occupied = true;
            bestSlot.occupiedBy = zombie;
            return bestSlot;
        }
        
        return null;
    },
    
    // Release a flank slot when zombie dies or changes behavior
    releaseFlankSlot(zombie) {
        for (const slot of this.flankSlots) {
            if (slot.occupiedBy === zombie) {
                slot.occupied = false;
                slot.occupiedBy = null;
            }
        }
    }
};

class Zombie {
    constructor(x, z, waveNum = 1, variant = 'normal') {
        // Get variant config
        this.variant = variant;
        this.type = variant; // Fix for headshot immunity checks
        this.variantConfig = ZOMBIE_VARIANTS[variant] || ZOMBIE_VARIANTS.normal;

        this.mesh = createZombieMesh(variant);
        this.mesh.position.set(x, -5, z);
        scene.add(this.mesh);

        // Scale health and speed with wave AND variant
        const waveMod = 1 + (waveNum - 1) * 0.1;
        const baseHealth = Math.floor(2 + Math.random() * 2 * waveMod);
        this.health = Math.floor(baseHealth * this.variantConfig.healthMod);
        this.maxHealth = this.health;
        const baseSpd = 4.0 + Math.random() * 2.0; // Slower zombies
        this.baseSpeed = baseSpd * this.variantConfig.speedMod;
        this.speed = this.baseSpeed;

        // State
        this.isDead = false;
        this.deathTime = 0;
        this.attackCooldown = 0;
        this.attackRange = 3.5 * this.variantConfig.scale; // Scale attack range with size
        const baseDamage = 10 + Math.floor(waveNum / 2) * 5;
        this.attackDamage = Math.floor(baseDamage * this.variantConfig.damageMod);
        this.headExploded = false; // Tracks if head was blown off

        // Knockback state (for kick)
        this.isKnockedBack = false;
        this.knockbackVel = null;
        this.knockbackTime = 0;
        
        // AI STATE - Swarm Intelligence
        this.aiRole = this.assignRole(); // 'rusher', 'flanker', 'lurker'
        this.flankSlot = null;
        this.flankAngle = 0;
        this.separationForce = { x: 0, z: 0 };
        this.stuckTimer = 0;
        this.lastPositions = []; // For stuck detection (circular buffer)
        this.threatAwareness = 0; // Knows when being aimed at (0-1)
        this.updateCounter = 0; // For staggered updates
        this.aiWave = waveNum; // Store wave for adaptive behavior

        // FLUID Animation state
        this.walkCycle = Math.random() * Math.PI * 2;
        this.swayOffset = Math.random() * Math.PI * 2;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.limbPhase = Math.random() * Math.PI * 2;
        this.headBob = 0;
        this.bodyLean = 0;
        this.armSwing = 0;

        // Ragdoll parts (populated on death)
        this.ragdollParts = [];

        // Hitbox for raycasting (scaled by variant)
        const hitScale = this.variantConfig.scale;
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6 * hitScale, 4.4 * hitScale, 1.0 * hitScale),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2.2 * hitScale;
        this.mesh.add(this.hitbox);
        this.hitbox.userData.isBot = true;
        this.hitbox.userData.botRef = this;
        targets.push(this.hitbox);
    }
    
    // Assign tactical role based on spawn order and position
    assignRole() {
        const rand = Math.random();
        if (rand < 0.4) return 'rusher';   // 40% direct charge
        if (rand < 0.75) return 'flanker'; // 35% flanking
        return 'lurker';                     // 25% slower approach
    }
    
    // Calculate separation force from nearby zombies (prevents clumping)
    calculateSeparation(zombiesArray, dt) {
        this.separationForce.x = 0;
        this.separationForce.z = 0;
        
        const separationRadius = 3.0; // Distance to maintain from other zombies
        const separationRadiusSq = separationRadius * separationRadius;
        let neighborCount = 0;
        
        // Only check 3 closest zombies for performance (reduced from 5)
        const nearbyZombies = zombiesArray
            .filter(z => z !== this && !z.isDead)
            .map(z => {
                const dx = z.mesh.position.x - this.mesh.position.x;
                const dz = z.mesh.position.z - this.mesh.position.z;
                return { zombie: z, distSq: dx * dx + dz * dz, dx, dz };
            })
            .sort((a, b) => a.distSq - b.distSq)
            .slice(0, 3);
        
        for (const neighbor of nearbyZombies) {
            if (neighbor.distSq < separationRadiusSq && neighbor.distSq > 0.01) {
                const dist = Math.sqrt(neighbor.distSq);
                const strength = (separationRadius - dist) / separationRadius;
                
                // Push away from neighbor
                this.separationForce.x -= (neighbor.dx / dist) * strength * 2.0;
                this.separationForce.z -= (neighbor.dz / dist) * strength * 2.0;
                neighborCount++;
            }
        }
        
        // Normalize if multiple neighbors
        if (neighborCount > 0) {
            const mag = Math.sqrt(this.separationForce.x * this.separationForce.x + this.separationForce.z * this.separationForce.z);
            if (mag > 0.01) {
                this.separationForce.x /= mag;
                this.separationForce.z /= mag;
            }
        }
    }
    
    // Calculate steering forces based on AI role and wave difficulty
    calculateSteering(playerPos, dt) {
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const distSq = dx * dx + dz * dz;
        const dist = Math.sqrt(distSq);
        
        // Adaptive behavior based on wave
        const waveLevel = Math.min(this.aiWave, 7);
        const hasSeparation = waveLevel >= 3;
        const hasFlanking = waveLevel >= 5;
        const hasFullTactics = waveLevel >= 7;
        
        let targetX = playerPos.x;
        let targetZ = playerPos.z;
        let seekWeight = 1.0;
        
        // Role-based behavior
        if (this.aiRole === 'rusher') {
            // Direct charge - higher speed multiplier
            this.speed = this.baseSpeed * (hasFullTactics ? 1.3 : 1.1);
            seekWeight = 1.2; // Stronger seek
        } else if (this.aiRole === 'flanker' && hasFlanking) {
            // Flanking behavior
            if (!this.flankSlot) {
                this.flankSlot = HiveMind.claimFlankSlot(this);
            }
            
            if (this.flankSlot) {
                // Move toward flank position, but still seek player if close
                const flankWeight = dist > 10 ? 0.8 : 0.3;
                targetX = THREE.MathUtils.lerp(playerPos.x, this.flankSlot.x, flankWeight);
                targetZ = THREE.MathUtils.lerp(playerPos.z, this.flankSlot.z, flankWeight);
                this.speed = this.baseSpeed * 0.9; // Slightly slower for flanking
            }
        } else if (this.aiRole === 'lurker') {
            // Slower, cautious approach
            this.speed = this.baseSpeed * 0.7;
            seekWeight = 0.6;
            
            // Lurkers avoid threat direction
            if (HiveMind.threatIntensity > 0.5) {
                const threatDot = (dx * HiveMind.threatDirection.x + dz * HiveMind.threatDirection.z) / dist;
                if (threatDot > 0.5) {
                    // Being aimed at - move perpendicular
                    const perpX = -HiveMind.threatDirection.z;
                    const perpZ = HiveMind.threatDirection.x;
                    targetX = this.mesh.position.x + perpX * 5;
                    targetZ = this.mesh.position.z + perpZ * 5;
                }
            }
        }
        
        // Calculate seek vector
        const seekX = (targetX - this.mesh.position.x) / Math.max(dist, 0.1);
        const seekZ = (targetZ - this.mesh.position.z) / Math.max(dist, 0.1);
        
        // Combine forces
        let finalX = seekX * seekWeight;
        let finalZ = seekZ * seekWeight;
        
        // Add separation (if enabled for this wave)
        if (hasSeparation) {
            finalX += this.separationForce.x * 0.4;
            finalZ += this.separationForce.z * 0.4;
        }
        
        // Normalize final vector
        const finalMag = Math.sqrt(finalX * finalX + finalZ * finalZ);
        if (finalMag > 0.01) {
            finalX /= finalMag;
            finalZ /= finalMag;
        }
        
        return { x: finalX, z: finalZ };
    }
    
    // Detect if zombie is stuck with faster detection and better escape strategies
    checkStuck() {
        this.lastPositions.push({ x: this.mesh.position.x, z: this.mesh.position.z });
        if (this.lastPositions.length > 8) {
            this.lastPositions.shift();
        }

        // Faster stuck detection - only need 5 frames instead of 10
        if (this.lastPositions.length >= 5) {
            const first = this.lastPositions[0];
            const last = this.lastPositions[this.lastPositions.length - 1];
            const dx = last.x - first.x;
            const dz = last.z - first.z;
            const moved = Math.sqrt(dx * dx + dz * dz);

            // Check if barely moved (stuck threshold)
            if (moved < 0.3) {
                this.stuckTimer += 0.016; // Assume ~60fps
                if (this.stuckTimer > 0.5) { // Reduced from 1.0 to 0.5 for faster response
                    this.stuckTimer = 0;
                    this.lastPositions = [];
                    this.stuckCounter = (this.stuckCounter || 0) + 1; // Track how many times stuck
                    return true;
                }
            } else {
                this.stuckTimer = 0;
                this.stuckCounter = 0; // Reset if moving
            }
        }

        return false;
    }

    // Predictive obstacle avoidance - cast rays ahead to detect obstacles before collision
    calculateObstacleAvoidance(dirX, dirZ, playerPos) {
        const avoidanceForce = { x: 0, z: 0 };
        const lookAheadDist = 2.5; // How far ahead to look
        const zombieRadius = 0.6;

        // Cast 5 rays: center, left30, right30, left60, right60
        const angles = [0, -0.52, 0.52, -1.05, 1.05]; // 0, Â±30Â°, Â±60Â° in radians
        const weights = [1.0, 0.8, 0.8, 0.5, 0.5]; // Center ray has most weight

        for (let i = 0; i < angles.length; i++) {
            const angle = Math.atan2(dirX, dirZ) + angles[i];
            const rayDirX = Math.sin(angle);
            const rayDirZ = Math.cos(angle);

            // Check collision at lookahead distance
            const checkX = this.mesh.position.x + rayDirX * lookAheadDist;
            const checkZ = this.mesh.position.z + rayDirZ * lookAheadDist;

            const collision = checkCollisionAdvanced(checkX, checkZ, zombieRadius, this.mesh);
            if (collision.collided) {
                // Add avoidance force perpendicular to obstacle normal
                // Steer away from the obstacle
                avoidanceForce.x += collision.normalX * weights[i];
                avoidanceForce.z += collision.normalZ * weights[i];
            }
        }

        // Also check for obstacles very close (immediate repulsion)
        for (const obstacle of obstacles) {
            const box = getBoundingBox(obstacle);
            const centerX = (box.min.x + box.max.x) / 2;
            const centerZ = (box.min.z + box.max.z) / 2;
            const sizeX = box.max.x - box.min.x;
            const sizeZ = box.max.z - box.min.z;
            const obstacleRadius = Math.max(sizeX, sizeZ) / 2;

            const dx = this.mesh.position.x - centerX;
            const dz = this.mesh.position.z - centerZ;
            const dist = Math.sqrt(dx * dx + dz * dz);

            // If very close to obstacle, add strong repulsion
            const dangerDist = zombieRadius + obstacleRadius + 1.5;
            if (dist < dangerDist && dist > 0.01) {
                const repulsionStrength = (dangerDist - dist) / dangerDist;
                avoidanceForce.x += (dx / dist) * repulsionStrength * 1.5;
                avoidanceForce.z += (dz / dist) * repulsionStrength * 1.5;
            }
        }

        // Normalize avoidance force
        const mag = Math.sqrt(avoidanceForce.x * avoidanceForce.x + avoidanceForce.z * avoidanceForce.z);
        if (mag > 0.01) {
            avoidanceForce.x /= mag;
            avoidanceForce.z /= mag;
        }

        return avoidanceForce;
    }

    // Enhanced stuck escape with multiple strategies
    getStuckEscapeVector(playerPos, dt) {
        const escapeForce = { x: 0, z: 0 };
        const stuckLevel = Math.min(this.stuckCounter || 0, 3);

        if (stuckLevel === 0) {
            return escapeForce; // Not stuck
        }

        // Strategy 1: Try perpendicular movement (first attempt)
        if (stuckLevel === 1) {
            const toPlayerX = playerPos.x - this.mesh.position.x;
            const toPlayerZ = playerPos.z - this.mesh.position.z;
            const mag = Math.sqrt(toPlayerX * toPlayerX + toPlayerZ * toPlayerZ);
            if (mag > 0.01) {
                // Move perpendicular to player direction
                escapeForce.x = -toPlayerZ / mag;
                escapeForce.z = toPlayerX / mag;
                // Randomly choose left or right
                if (Math.random() < 0.5) {
                    escapeForce.x *= -1;
                    escapeForce.z *= -1;
                }
            }
        }
        // Strategy 2: Backstep (second attempt)
        else if (stuckLevel === 2) {
            const toPlayerX = playerPos.x - this.mesh.position.x;
            const toPlayerZ = playerPos.z - this.mesh.position.z;
            const mag = Math.sqrt(toPlayerX * toPlayerX + toPlayerZ * toPlayerZ);
            if (mag > 0.01) {
                // Move away from player temporarily
                escapeForce.x = -toPlayerX / mag;
                escapeForce.z = -toPlayerZ / mag;
            }
        }
        // Strategy 3: Random direction (third attempt)
        else {
            const randomAngle = Math.random() * Math.PI * 2;
            escapeForce.x = Math.cos(randomAngle);
            escapeForce.z = Math.sin(randomAngle);
        }

        return escapeForce;
    }

    hit(hitPoint, weaponDamageMultiplier = 1.0) {
        if (this.isDead) return;

        // Apply damage (boosted if power-up active, multiplied by weapon damage)
        const baseDamage = damageBoostTimer > 0 ? damageBoostMultiplier : 1;
        const damage = baseDamage * weaponDamageMultiplier;
        this.health -= damage;
        playSound('zombieHit');

        // === ENHANCED: Hit Stagger Animation ===
        // Direction from player to zombie (knockback direction)
        const knockDir = new THREE.Vector3();
        knockDir.subVectors(this.mesh.position, camera.position).normalize();

        // Stagger/flinch with random variation (heavier hits = bigger flinch)
        const flinchIntensity = (0.15 + Math.random() * 0.15) * Math.min(weaponDamageMultiplier, 2.0);
        this.mesh.rotation.x = -flinchIntensity - Math.random() * 0.1;
        this.mesh.rotation.z = (Math.random() - 0.5) * 0.2 * weaponDamageMultiplier; // More side tilt for big hits

        // Knockback - push zombie away from player (stronger for high-damage weapons)
        const knockbackStrength = (0.3 + Math.random() * 0.2) * weaponDamageMultiplier;
        this.mesh.position.x += knockDir.x * knockbackStrength;
        this.mesh.position.z += knockDir.z * knockbackStrength;

        // Store hit time for stagger recovery animation
        if (!this.lastHitTime) this.lastHitTime = 0;
        this.lastHitTime = performance.now();
        this.isStaggered = true;

        // Schedule stagger recovery
        setTimeout(() => {
            if (!this.isDead) {
                this.isStaggered = false;
            }
        }, 150 + Math.random() * 100);

        // VIOLENT blood spray from hit point
        const bloodPos = hitPoint || this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        const bloodDir = knockDir.clone();
        spawnBloodSpray(bloodPos, bloodDir, this.health <= 0 ? 4 : 2); // More blood on every hit
        if (Math.random() > 0.5) {
            spawnGoreChunks(bloodPos, bloodDir); // Chance for gore on hits too
        }

        if (this.health <= 0) {
            this.die();
        }
    }

    die() {
        this.isDead = true;
        this.deathTime = performance.now();

        // Release flank slot when zombie dies
        HiveMind.releaseFlankSlot(this);

        // Only play death sound if not headshot (headshot has its own sound)
        if (!this.headExploded) {
            playSound('zombieDeath');
            addKillScore(100); // Body kill - applies multiplier
        }
        // Headshot score is already added in shoot()
        zombiesKilledThisWave++;

        // Check for last zombie of wave - trigger cinematic slowmo
        if (isLastZombieOfWave()) {
            triggerSlowmo();
        }

        // Remove hitbox from targets
        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);

        // Get direction from camera to zombie for death impulse
        const deathDir = new THREE.Vector3();
        deathDir.subVectors(this.mesh.position, camera.position).normalize();

        // Gore effects - less if headshot (head already exploded separately)
        if (!this.headExploded) {
            const centerPos = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            spawnGoreChunks(centerPos, deathDir);
            spawnGoreChunks(centerPos, deathDir); // Double gore
            spawnBloodSpray(centerPos, deathDir, 4); // Much more blood
            spawnBloodSpray(centerPos.clone().add(new THREE.Vector3(0, -0.5, 0)), deathDir, 3);
        } else {
            // For headshot, just torso/body blood
            const torsoPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            spawnBloodSpray(torsoPos, deathDir, 2);
        }
        spawnBloodPool(this.mesh.position.clone());
        spawnBloodPool(this.mesh.position.clone().add(new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5)));

        // Detach each body part (skip hitbox at index 6)
        for (let i = 0; i < 6; i++) {
            const part = this.mesh.children[0];
            if (!part) continue;

            const partWorldPos = new THREE.Vector3();
            part.getWorldPosition(partWorldPos);

            this.mesh.remove(part);
            scene.add(part);
            part.position.copy(partWorldPos);

            // VIOLENT ragdoll - much more force
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * 15 + deathDir.x * 12,
                Math.random() * 10 + 5,
                (Math.random() - 0.5) * 15 + deathDir.z * 12
            );

            const rotVel = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25
            );

            this.ragdollParts.push({
                mesh: part,
                velocity: vel,
                rotVelocity: rotVel,
                grounded: false,
                bleedTimer: 0,
                canBleed: true
            });
        }

        this.mesh.visible = false;
    }

    cleanup() {
        // Remove from scene completely
        for (const part of this.ragdollParts) {
            scene.remove(part.mesh);
        }
        this.ragdollParts = [];
        scene.remove(this.mesh);

        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);
    }

    update(dt, time) {
        if (this.isDead) {
            // Update ragdoll physics
            const groundY = -4.8;
            const friction = 0.85;
            const bounciness = 0.3;

            for (const part of this.ragdollParts) {
                if (!part.grounded) {
                    // Apply gravity
                    part.velocity.y -= 25 * dt;
                    
                    // Store old position for collision resolution
                    const oldX = part.mesh.position.x;
                    const oldZ = part.mesh.position.z;
                    
                    // Calculate new position
                    const newX = oldX + part.velocity.x * dt;
                    const newZ = oldZ + part.velocity.z * dt;
                    
                    // Apply collision detection for ragdoll parts (smaller radius ~0.3)
                    // Exclude the part's own mesh to prevent self-collision
                    const partRadius = 0.3;
                    const resolved = resolveCollision(oldX, oldZ, newX, newZ, partRadius, part.mesh);
                    part.mesh.position.x = resolved.x;
                    part.mesh.position.z = resolved.z;
                    
                    // Apply vertical movement
                    part.mesh.position.y += part.velocity.y * dt;
                    
                    // Rotation
                    part.mesh.rotation.x += part.rotVelocity.x * dt;
                    part.mesh.rotation.y += part.rotVelocity.y * dt;
                    part.mesh.rotation.z += part.rotVelocity.z * dt;

                    // Ground collision
                    if (part.mesh.position.y < groundY) {
                        part.mesh.position.y = groundY;
                        if (Math.abs(part.velocity.y) > 1) {
                            part.velocity.y *= -bounciness;
                            part.velocity.x *= friction;
                            part.velocity.z *= friction;
                            part.rotVelocity.multiplyScalar(0.7);
                        } else {
                            part.velocity.set(0, 0, 0);
                            part.rotVelocity.multiplyScalar(0.9);
                            if (part.rotVelocity.length() < 0.1) {
                                part.grounded = true;
                            }
                        }
                    }
                    
                    // Apply friction
                    part.velocity.multiplyScalar(0.995);
                    
                    // If collision occurred, reduce velocity
                    if (resolved.collided) {
                        part.velocity.x *= 0.5;
                        part.velocity.z *= 0.5;
                        part.rotVelocity.multiplyScalar(0.8);
                    }

                    if (part.canBleed) {
                        part.bleedTimer += dt;
                        if (part.bleedTimer > 0.08) {
                            part.bleedTimer = 0;
                            const dropMat = new THREE.SpriteMaterial({
                                map: bloodSpriteTex,
                                color: 0x880000,
                                transparent: true,
                                opacity: 0.9
                            });
                            const drop = new THREE.Sprite(dropMat);
                            drop.position.copy(part.mesh.position);
                            drop.scale.setScalar(0.1 + Math.random() * 0.1);
                            scene.add(drop);
                            bloodParticles.push({
                                mesh: drop,
                                velocity: new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.5,
                                    -1,
                                    (Math.random() - 0.5) * 0.5
                                ),
                                life: 0.8,
                                gravity: 20,
                                type: 'droplet'
                            });
                        }
                    }
                } else if (part.canBleed) {
                    part.bleedTimer += dt;
                    if (part.bleedTimer > 2) {
                        part.canBleed = false;
                    }
                }
            }
            return;
        }

        // Recover from flinch
        this.mesh.rotation.x *= 0.9;

        // Handle kick knockback
        if (this.isKnockedBack && this.knockbackVel) {
            this.mesh.position.x += this.knockbackVel.x * dt;
            this.mesh.position.z += this.knockbackVel.z * dt;
            this.knockbackVel.multiplyScalar(0.9); // Friction
            this.knockbackTime -= dt;
            if (this.knockbackTime <= 0) {
                this.isKnockedBack = false;
                this.knockbackVel = null;
            }
            return; // Skip normal movement while knocked back
        }

        // INTELLIGENT CHASE WITH SWARM BEHAVIOR
        const playerPos = { x: HiveMind.playerPos.x, z: HiveMind.playerPos.z };
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const distSq = dx * dx + dz * dz;
        const dist = Math.sqrt(distSq);

        // Attack cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= dt;
        }

        // Attack if close enough
        if (dist < this.attackRange && this.attackCooldown <= 0) {
            this.attackCooldown = 1.0; // 1 second between attacks
            damagePlayer(this.attackDamage, this.mesh.position); // Pass attacker position for directional indicator
            playSound('zombieAttack');
        }

        // Update threat awareness (know when being aimed at)
        if (dist < 15) {
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            const toZombie = new THREE.Vector3(dx, 0, dz).normalize();
            const dot = cameraDir.dot(toZombie);
            this.threatAwareness = THREE.MathUtils.lerp(this.threatAwareness, dot > 0.7 ? 1.0 : 0.0, dt * 3);
        } else {
            this.threatAwareness = THREE.MathUtils.lerp(this.threatAwareness, 0, dt * 2);
        }

        // Move with intelligent steering
        if (dist > 1.5) {
            this.updateCounter++;

            // Staggered updates for performance (separation every 6 frames)
            if (this.updateCounter % 6 === 0) {
                this.calculateSeparation(zombies, dt); // zombies is global array
            }

            // Check if stuck
            const isStuck = this.checkStuck();

            // Calculate base steering forces
            const steering = this.calculateSteering(playerPos, dt);

            // Add predictive obstacle avoidance (staggered for performance)
            let avoidance = { x: 0, z: 0 };
            if (this.updateCounter % 4 === 0) {
                avoidance = this.calculateObstacleAvoidance(steering.x, steering.z, playerPos);
            } else if (this.lastAvoidance) {
                avoidance = this.lastAvoidance; // Reuse last calculation
            }
            this.lastAvoidance = avoidance;

            // Get stuck escape vector if needed
            const escapeVector = isStuck ? this.getStuckEscapeVector(playerPos, dt) : { x: 0, z: 0 };

            // Blend all forces together
            // Base steering: primary direction
            // Obstacle avoidance: prevent collisions (moderate weight)
            // Escape: override when stuck (high weight)
            let finalX = steering.x;
            let finalZ = steering.z;

            if (isStuck) {
                // When stuck, heavily prioritize escape
                const escapeWeight = 0.8;
                const seekWeight = 0.2;
                finalX = escapeVector.x * escapeWeight + steering.x * seekWeight;
                finalZ = escapeVector.z * escapeWeight + steering.z * seekWeight;

                // Release flank slot when stuck
                if (this.flankSlot) {
                    HiveMind.releaseFlankSlot(this);
                    this.flankSlot = null;
                }
            } else {
                // Normal movement with obstacle avoidance
                const avoidanceMag = Math.sqrt(avoidance.x * avoidance.x + avoidance.z * avoidance.z);
                if (avoidanceMag > 0.1) {
                    // Obstacle detected ahead - blend avoidance with steering
                    const avoidWeight = Math.min(avoidanceMag * 0.6, 0.7);
                    const seekWeight = 1.0 - avoidWeight;
                    finalX = steering.x * seekWeight + avoidance.x * avoidWeight;
                    finalZ = steering.z * seekWeight + avoidance.z * avoidWeight;
                }
            }

            // Normalize final direction
            const finalMag = Math.sqrt(finalX * finalX + finalZ * finalZ);
            if (finalMag > 0.01) {
                finalX /= finalMag;
                finalZ /= finalMag;
            }

            // Apply movement with speed
            const moveX = finalX * this.speed * dt;
            const moveZ = finalZ * this.speed * dt;

            // Store old position for collision resolution
            const oldX = this.mesh.position.x;
            const oldZ = this.mesh.position.z;

            // Calculate new position
            const newX = oldX + moveX;
            const newZ = oldZ + moveZ;

            // Apply collision detection and resolution (zombie radius ~0.6)
            const zombieRadius = 0.6;
            const resolved = resolveCollision(oldX, oldZ, newX, newZ, zombieRadius, this.mesh);
            this.mesh.position.x = resolved.x;
            this.mesh.position.z = resolved.z;

            // If collision occurred, release flank slot (might be blocked)
            if (resolved.collided && this.flankSlot) {
                HiveMind.releaseFlankSlot(this);
                this.flankSlot = null;
            }

            // Smooth face towards movement direction (not just player)
            const moveDirX = this.mesh.position.x - oldX;
            const moveDirZ = this.mesh.position.z - oldZ;
            const moveDist = Math.sqrt(moveDirX * moveDirX + moveDirZ * moveDirZ);
            
            if (moveDist > 0.01) {
                const targetRot = Math.atan2(moveDirX, moveDirZ);
                const rotDiff = targetRot - this.mesh.rotation.y;
                const normalizedDiff = Math.atan2(Math.sin(rotDiff), Math.cos(rotDiff));
                const turnSpeed = this.aiWave >= 7 ? 8 : 5; // Faster turning in later waves
                this.mesh.rotation.y += normalizedDiff * turnSpeed * dt;
            } else {
                // Fallback to facing player if not moving
                const targetRot = Math.atan2(dx, dz);
                const rotDiff = targetRot - this.mesh.rotation.y;
                const normalizedDiff = Math.atan2(Math.sin(rotDiff), Math.cos(rotDiff));
                this.mesh.rotation.y += normalizedDiff * 5 * dt;
            }

            // FLUID shambling walk animation
            const walkSpeed = this.speed * 1.2;
            this.walkCycle += dt * walkSpeed;
            this.limbPhase += dt * walkSpeed * 0.8; // Slightly offset phase

            const head = this.mesh.children[0];
            const torso = this.mesh.children[1];
            const leftArm = this.mesh.children[2];
            const rightArm = this.mesh.children[3];
            const leftLeg = this.mesh.children[4];
            const rightLeg = this.mesh.children[5];

            // Organic body vertical bob + terrain following
            this.headBob = THREE.MathUtils.lerp(this.headBob, Math.sin(this.walkCycle * 2) * 0.08, 0.15);
            const zombieTerrainY = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
            this.mesh.position.y = zombieTerrainY + this.headBob;

            // Body lean into movement
            this.bodyLean = THREE.MathUtils.lerp(this.bodyLean, 0.15, 0.05);
            if (torso) {
                torso.rotation.x = this.bodyLean + Math.sin(this.walkCycle) * 0.05;
                torso.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.08;
            }

            // Head wobble
            if (head) {
                head.rotation.x = Math.sin(this.walkCycle * 2 + 0.5) * 0.1;
                head.rotation.z = Math.sin(this.walkCycle + this.swayOffset) * 0.12;
                head.rotation.y = Math.sin(this.walkCycle * 0.3) * 0.15;
            }

            // Fluid leg animation - bent knee shamble
            if (leftLeg && rightLeg) {
                const legSwing = 0.5;
                leftLeg.rotation.x = Math.sin(this.walkCycle) * legSwing;
                leftLeg.rotation.z = Math.sin(this.walkCycle * 0.5) * 0.1;
                rightLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * legSwing;
                rightLeg.rotation.z = Math.sin(this.walkCycle * 0.5 + Math.PI) * 0.1;
            }

            // Arms - reaching forward with organic sway
            this.armSwing = THREE.MathUtils.lerp(this.armSwing, Math.sin(this.limbPhase) * 0.2, 0.1);
            if (leftArm && rightArm) {
                // Base reaching pose with fluid motion
                leftArm.rotation.x = -Math.PI / 3 + this.armSwing + Math.sin(this.walkCycle * 0.7) * 0.15;
                leftArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.2 - 0.1;
                rightArm.rotation.x = -Math.PI / 3 - this.armSwing + Math.sin(this.walkCycle * 0.7 + Math.PI) * 0.15;
                rightArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset + Math.PI) * 0.2 + 0.1;
            }

            // Fluid body sway (drunk shamble) - don't override when staggered
            if (!this.isStaggered) {
                this.mesh.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.1;
                this.mesh.rotation.x = Math.sin(this.walkCycle + this.bobOffset) * 0.03;
            } else {
                // During stagger, smoothly recover z rotation
                this.mesh.rotation.z *= 0.92;
            }
        } else {
            // Idle sway when close - also respect stagger
            if (!this.isStaggered) {
                this.mesh.rotation.z = Math.sin(time * 0.002 + this.swayOffset) * 0.05;
            }
        }

        // Keep within bounds (collision system handles this, but keep as backup)
        this.mesh.position.x = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.x));
        this.mesh.position.z = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.z));
    }

    // Minimal update for non-active zombies (performance optimization)
    updateMinimal(dt) {
        // Only update position and basic bounds checking
        this.mesh.position.x = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.x));
        this.mesh.position.z = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.z));
    }
}

// WAVE SYSTEM
let currentWave = 0;
let zombiesThisWave = 0;
let zombiesKilledThisWave = 0;
let zombiesSpawnedThisWave = 0;
let waveInProgress = false;
let waveStartTime = 0;
let betweenWaves = true;
let nextWaveCountdown = 1; // Start fast

function startWave(waveNum) {
    currentWave = waveNum;
    zombiesThisWave = 8 + waveNum * 4; // More zombies: 12, 16, 20, 24...
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = true;
    betweenWaves = false;
    waveStartTime = performance.now();

    // Clear any remaining dead zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    updateHUD();
}

function spawnZombie() {
    if (zombiesSpawnedThisWave >= zombiesThisWave) return;
    if (spawnDoors.length === 0) return;

    // Pick a random door to spawn from
    const doorIndex = Math.floor(Math.random() * spawnDoors.length);
    const door = spawnDoors[doorIndex];

    // Open the door with animation and sound
    openDoor(door);

    // Spawn zombie at door position (slightly randomized)
    const offsetX = (Math.random() - 0.5) * 2;
    const offsetZ = (Math.random() - 0.5) * 2;
    const x = door.spawnX + offsetX;
    const z = door.spawnZ + offsetZ;

    // Pick zombie variant based on wave
    const variant = pickZombieVariant(currentWave);

    zombies.push(new Zombie(x, z, currentWave, variant));
    zombiesSpawnedThisWave++;
}

function updateWaveSystem(dt) {
    if (betweenWaves) {
        nextWaveCountdown -= dt;
        if (nextWaveCountdown <= 0) {
            startWave(currentWave + 1);
        }
        return;
    }

    if (!waveInProgress) return;

    // Spawn zombies rapidly
    const timeSinceWaveStart = (performance.now() - waveStartTime) / 1000;
    const spawnInterval = Math.max(0.2, 0.8 - currentWave * 0.05); // Much faster spawns
    const shouldHaveSpawned = Math.floor(timeSinceWaveStart / spawnInterval) + 1;

    while (zombiesSpawnedThisWave < shouldHaveSpawned && zombiesSpawnedThisWave < zombiesThisWave) {
        spawnZombie();
    }

    // Check wave completion
    if (zombiesKilledThisWave >= zombiesThisWave) {
        waveInProgress = false;
        betweenWaves = true;
        nextWaveCountdown = 2; // Quick 2 seconds between waves

        // Bonus points for wave clear
        addScore(currentWave * 500);
        playSound('waveComplete');

        // Spawn guaranteed pickup on wave clear as reward - DISABLED
        // if (currentWave >= 2) {
        //     const type = getRandomPickupType();
        //     const angle = Math.random() * Math.PI * 2;
        //     const dist = 8 + Math.random() * 15;
        //     spawnPickup(type, camera.position.x + Math.cos(angle) * dist, camera.position.z + Math.sin(angle) * dist);
        // }
    }
}

// PICKUP SYSTEM - DISABLED FOR PERFORMANCE
// const pickups = [];
const pickups = []; // Keep empty array to prevent errors

// Power-up state - DISABLED
let speedBoostTimer = 0;
let damageBoostTimer = 0;
let rapidFireTimer = 0;
let infiniteAmmoTimer = 0;
let explosiveRoundsTimer = 0;
let penetratingRoundsTimer = 0;
let shieldTimer = 0;

const speedBoostMultiplier = 1.8;
const damageBoostMultiplier = 2;
const rapidFireMultiplier = 2.5;
const shieldDamageReduction = 0.25;

/* === POWER-UPS DISABLED FOR PERFORMANCE ===
// Pickup types configuration
const PICKUP_TYPES = {
    ammo: { color: 0xffaa00, glowColor: 0xffcc00, height: 0.4, label: 'AMMO', rarity: 1 },
    health: { color: 0x00ff00, glowColor: 0x44ff44, height: 0.5, label: '+HEALTH', rarity: 1 },
    speed: { color: 0x00ffff, glowColor: 0x44ffff, height: 0.5, label: 'SPEED BOOST!', rarity: 2 },
    damage: { color: 0xff0000, glowColor: 0xff4444, height: 0.5, label: '2X DAMAGE!', rarity: 2 },
    rapidfire: { color: 0xff8800, glowColor: 0xffaa44, height: 0.5, label: 'RAPID FIRE!', rarity: 2 },
    infiniteammo: { color: 0xffff00, glowColor: 0xffffaa, height: 0.5, label: 'INFINITE AMMO!', rarity: 3 },
    explosive: { color: 0xff4400, glowColor: 0xff6622, height: 0.5, label: 'EXPLOSIVE ROUNDS!', rarity: 3 },
    penetrating: { color: 0x8844ff, glowColor: 0xaa66ff, height: 0.5, label: 'ARMOR PIERCING!', rarity: 3 },
    shield: { color: 0x4488ff, glowColor: 0x66aaff, height: 0.5, label: 'SHIELD!', rarity: 2 },
    slowmo: { color: 0xaa00ff, glowColor: 0xcc44ff, height: 0.5, label: 'BULLET TIME!', rarity: 4 },
    nuke: { color: 0xff00ff, glowColor: 0xff44ff, height: 0.6, label: 'NUKE!', rarity: 5 }
};

// === PICKUP MESH CACHE (pre-created at init for zero-lag spawns) ===
const pickupCache = {
    meshTemplates: {},      // Pre-built mesh for each type
    glowGeo: null,          // Shared sphere geometry for all glows
    glowMats: {},           // Material per type (shared across instances)
    initialized: false
};

function initPickupCache() {
    if (pickupCache.initialized) return;

    // Pre-create mesh template for each pickup type
    for (const type of Object.keys(PICKUP_TYPES)) {
        pickupCache.meshTemplates[type] = createPickupMeshInternal(type);
    }

    // Single shared glow geometry for all pickups
    pickupCache.glowGeo = new THREE.SphereGeometry(0.8, 16, 16);

    // Pre-create glow materials (one per type, shared across instances)
    for (const [type, config] of Object.entries(PICKUP_TYPES)) {
        pickupCache.glowMats[type] = new THREE.MeshBasicMaterial({
            color: config.glowColor,
            transparent: true,
            opacity: 0.15
        });
    }

    pickupCache.initialized = true;
    console.log('[Pickup Cache] Pre-cached', Object.keys(PICKUP_TYPES).length, 'pickup types');
}

function createPickupMesh(type) {
    // Fast path: clone from cache (shares geometry/material refs)
    if (pickupCache.initialized && pickupCache.meshTemplates[type]) {
        return pickupCache.meshTemplates[type].clone();
    }
    // Fallback: create fresh (only during init before cache exists)
    return createPickupMeshInternal(type);
}

function createPickupMeshInternal(type) {
    const config = PICKUP_TYPES[type];
    const group = new THREE.Group();

    if (type === 'ammo') {
        // Ammo box
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.5, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.6 })
        );
        box.castShadow = true;
        group.add(box);

        // Bullets on top
        for (let i = 0; i < 3; i++) {
            const bullet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.25, 8),
                new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })
            );
            bullet.position.set(-0.2 + i * 0.2, 0.35, 0);
            bullet.rotation.x = Math.PI / 2;
            group.add(bullet);
        }
    } else if (type === 'health') {
        // Medical box with cross
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.5, 0.7),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
        );
        box.castShadow = true;
        group.add(box);

        // Red cross
        const crossH = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.1, 0.15),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossH.position.set(0, 0.26, 0);
        group.add(crossH);

        const crossV = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.1, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossV.position.set(0, 0.26, 0);
        group.add(crossV);
    } else if (type === 'speed') {
        // Lightning bolt shape
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.4);
        shape.lineTo(0.15, 0.1);
        shape.lineTo(0.05, 0.1);
        shape.lineTo(0.15, -0.4);
        shape.lineTo(-0.05, 0);
        shape.lineTo(0.05, 0);
        shape.lineTo(-0.1, 0.4);

        const extrudeSettings = { depth: 0.1, bevelEnabled: false };
        const boltGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const bolt = new THREE.Mesh(
            boltGeo,
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444, metalness: 0.5 })
        );
        bolt.rotation.y = Math.PI / 2;
        bolt.position.x = -0.05;
        group.add(bolt);
    } else if (type === 'damage') {
        // Skull shape (simplified)
        const skull = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 12, 10),
            new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0x440000 })
        );
        skull.scale.y = 1.2;
        group.add(skull);

        // Eye sockets
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        leftEye.position.set(-0.1, 0.05, 0.25);
        group.add(leftEye);

        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        rightEye.position.set(0.1, 0.05, 0.25);
        group.add(rightEye);
    } else if (type === 'nuke') {
        // Bomb/nuke shape
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 12),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 })
        );
        body.scale.y = 1.3;
        group.add(body);

        // Radiation symbol
        const symbolMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x440044 });
        const center = new THREE.Mesh(new THREE.CircleGeometry(0.08, 16), symbolMat);
        center.position.z = 0.36;
        group.add(center);

        // Fins
        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.3, 0.02),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 })
            );
            fin.position.set(0, -0.35, 0);
            fin.rotation.y = (i / 4) * Math.PI * 2;
            fin.position.x = Math.sin(fin.rotation.y) * 0.2;
            fin.position.z = Math.cos(fin.rotation.y) * 0.2;
            group.add(fin);
        }
    } else if (type === 'rapidfire') {
        // Triple bullet icon - fast fire
        const bulletMat = new THREE.MeshStandardMaterial({ color: 0xff8800, emissive: 0x442200, metalness: 0.7, roughness: 0.3 });
        for (let i = 0; i < 3; i++) {
            const bullet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.04, 0.4, 8),
                bulletMat
            );
            bullet.position.set(-0.15 + i * 0.15, 0, 0);
            bullet.rotation.x = Math.PI / 2;
            // Stagger heights for motion effect
            bullet.position.y = (i === 1) ? 0.1 : -0.05;
            group.add(bullet);
        }
        // Speed lines
        const lineMat = new THREE.MeshBasicMaterial({ color: 0xffaa44, transparent: true, opacity: 0.6 });
        for (let i = 0; i < 3; i++) {
            const line = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.02, 0.02), lineMat);
            line.position.set(-0.35, -0.1 + i * 0.1, 0);
            group.add(line);
        }
    } else if (type === 'infiniteammo') {
        // Infinity symbol made of bullets
        const goldMat = new THREE.MeshStandardMaterial({ color: 0xffd700, emissive: 0x443300, metalness: 0.9, roughness: 0.2 });
        // Create infinity shape with torus segments
        const torus1 = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.06, 8, 16, Math.PI),
            goldMat
        );
        torus1.position.x = -0.15;
        torus1.rotation.y = Math.PI / 2;
        group.add(torus1);
        const torus2 = new THREE.Mesh(
            new THREE.TorusGeometry(0.2, 0.06, 8, 16, Math.PI),
            goldMat
        );
        torus2.position.x = 0.15;
        torus2.rotation.y = -Math.PI / 2;
        group.add(torus2);
        // Center bullet
        const centerBullet = new THREE.Mesh(
            new THREE.CylinderGeometry(0.05, 0.05, 0.2, 8),
            goldMat
        );
        centerBullet.rotation.z = Math.PI / 2;
        group.add(centerBullet);
    } else if (type === 'explosive') {
        // Grenade/explosive round
        const bodyMat = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6, roughness: 0.4 });
        const body = new THREE.Mesh(new THREE.SphereGeometry(0.25, 12, 10), bodyMat);
        body.scale.y = 1.2;
        group.add(body);
        // Orange warning stripes
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xff4400, emissive: 0x441100 });
        for (let i = 0; i < 3; i++) {
            const stripe = new THREE.Mesh(
                new THREE.TorusGeometry(0.26, 0.03, 8, 16),
                stripeMat
            );
            stripe.position.y = -0.1 + i * 0.1;
            stripe.rotation.x = Math.PI / 2;
            group.add(stripe);
        }
        // Fuse on top
        const fuse = new THREE.Mesh(
            new THREE.CylinderGeometry(0.03, 0.03, 0.15, 8),
            new THREE.MeshStandardMaterial({ color: 0x8b4513 })
        );
        fuse.position.y = 0.35;
        group.add(fuse);
        // Spark
        const spark = new THREE.Mesh(
            new THREE.SphereGeometry(0.05, 8, 8),
            new THREE.MeshBasicMaterial({ color: 0xffff00 })
        );
        spark.position.y = 0.45;
        group.add(spark);
    } else if (type === 'penetrating') {
        // Armor-piercing bullet (long, pointed)
        const steelMat = new THREE.MeshStandardMaterial({ color: 0x666688, metalness: 0.95, roughness: 0.1 });
        const purpleMat = new THREE.MeshStandardMaterial({ color: 0x8844ff, emissive: 0x221144, metalness: 0.5 });
        // Main bullet body
        const body = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 0.5, 8),
            steelMat
        );
        body.rotation.x = Math.PI / 2;
        group.add(body);
        // Pointed tip
        const tip = new THREE.Mesh(
            new THREE.ConeGeometry(0.08, 0.25, 8),
            purpleMat
        );
        tip.rotation.x = -Math.PI / 2;
        tip.position.z = 0.35;
        group.add(tip);
        // Penetration rings
        for (let i = 0; i < 2; i++) {
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.12, 0.02, 8, 16),
                purpleMat
            );
            ring.position.z = -0.1 + i * 0.2;
            group.add(ring);
        }
    } else if (type === 'shield') {
        // Shield icon
        const shieldMat = new THREE.MeshStandardMaterial({
            color: 0x4488ff,
            emissive: 0x112244,
            metalness: 0.3,
            roughness: 0.5,
            transparent: true,
            opacity: 0.9
        });
        // Shield shape using extruded geometry
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.35);
        shape.lineTo(0.3, 0.25);
        shape.lineTo(0.3, 0);
        shape.lineTo(0, -0.35);
        shape.lineTo(-0.3, 0);
        shape.lineTo(-0.3, 0.25);
        shape.lineTo(0, 0.35);
        const extrudeSettings = { depth: 0.1, bevelEnabled: true, bevelSize: 0.02, bevelThickness: 0.02 };
        const shieldGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const shield = new THREE.Mesh(shieldGeo, shieldMat);
        shield.position.z = -0.05;
        group.add(shield);
        // Cross/plus symbol in center
        const crossMat = new THREE.MeshStandardMaterial({ color: 0xffffff, emissive: 0x224466 });
        const crossH = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.06, 0.12), crossMat);
        crossH.position.z = 0.06;
        group.add(crossH);
        const crossV = new THREE.Mesh(new THREE.BoxGeometry(0.06, 0.2, 0.12), crossMat);
        crossV.position.z = 0.06;
        group.add(crossV);
    } else if (type === 'slowmo') {
        // Hourglass/clock for bullet time
        const glassMat = new THREE.MeshStandardMaterial({
            color: 0xaa00ff,
            emissive: 0x330044,
            metalness: 0.2,
            roughness: 0.3,
            transparent: true,
            opacity: 0.8
        });
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 0.8, roughness: 0.2 });
        // Top bulb
        const topBulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8, 0, Math.PI * 2, 0, Math.PI / 2), glassMat);
        topBulb.position.y = 0.15;
        topBulb.scale.y = 1.5;
        group.add(topBulb);
        // Bottom bulb
        const bottomBulb = new THREE.Mesh(new THREE.SphereGeometry(0.2, 12, 8, 0, Math.PI * 2, Math.PI / 2, Math.PI / 2), glassMat);
        bottomBulb.position.y = -0.15;
        bottomBulb.scale.y = 1.5;
        group.add(bottomBulb);
        // Neck
        const neck = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.1, 8), glassMat);
        group.add(neck);
        // Frame rings
        const topRing = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.03, 8, 16), frameMat);
        topRing.position.y = 0.35;
        topRing.rotation.x = Math.PI / 2;
        group.add(topRing);
        const bottomRing = new THREE.Mesh(new THREE.TorusGeometry(0.22, 0.03, 8, 16), frameMat);
        bottomRing.position.y = -0.35;
        bottomRing.rotation.x = Math.PI / 2;
        group.add(bottomRing);
        // Sand particles inside (just small spheres)
        const sandMat = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
        for (let i = 0; i < 5; i++) {
            const grain = new THREE.Mesh(new THREE.SphereGeometry(0.02, 4, 4), sandMat);
            grain.position.set(
                (Math.random() - 0.5) * 0.1,
                -0.2 - Math.random() * 0.1,
                (Math.random() - 0.5) * 0.1
            );
            group.add(grain);
        }
    }

    return group;
}

class Pickup {
    constructor(type, x, z) {
        this.type = type;
        this.config = PICKUP_TYPES[type];

        // Clone from cache (fast - shares geometry/material refs)
        this.mesh = createPickupMesh(type);
        this.mesh.position.set(x, -4.5 + this.config.height, z);
        scene.add(this.mesh);

        // Glow effect - use cached geometry & material (zero allocation)
        this.glow = new THREE.Mesh(pickupCache.glowGeo, pickupCache.glowMats[type]);
        this.mesh.add(this.glow);

        // Point light for visibility (lightweight, can't easily pool)
        this.light = new THREE.PointLight(this.config.glowColor, 0.8, 8);
        this.light.position.set(0, 0.5, 0);
        this.mesh.add(this.light);

        this.bobOffset = Math.random() * Math.PI * 2;
        this.lifeTime = 30; // Despawn after 30 seconds
        this.collected = false;
    }

    update(dt, time) {
        if (this.collected) return true;

        // Bob and rotate
        this.mesh.position.y = -4.5 + this.config.height + Math.sin(time * 0.003 + this.bobOffset) * 0.15;
        this.mesh.rotation.y += dt * 2;

        // Pulse glow
        this.glow.material.opacity = 0.1 + Math.sin(time * 0.005) * 0.05;
        this.light.intensity = 0.6 + Math.sin(time * 0.005) * 0.3;

        // Check pickup collision with player
        const dx = camera.position.x - this.mesh.position.x;
        const dz = camera.position.z - this.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 2.5) {
            this.collect();
            return true;
        }

        // Lifetime
        this.lifeTime -= dt;
        if (this.lifeTime <= 0) {
            this.remove();
            return true;
        }

        // Flicker when about to despawn
        if (this.lifeTime < 5) {
            this.mesh.visible = Math.sin(time * 0.02) > 0;
        }

        return false;
    }

    collect() {
        this.collected = true;
        playSound('pickup');

        // Show floating text
        showPickupText(this.config.label, this.config.color);

        // Apply effect based on type
        switch (this.type) {
            case 'ammo':
                reserve = Math.min(reserve + 60, 300);
                addScore(50);
                break;

            case 'health':
                playerHealth = Math.min(playerHealth + 50, maxPlayerHealth);
                addScore(50);
                break;

            case 'speed':
                speedBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'damage':
                damageBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'rapidfire':
                rapidFireTimer = 8; // 8 seconds of rapid fire
                addScore(150);
                break;

            case 'infiniteammo':
                infiniteAmmoTimer = 10; // 10 seconds of infinite ammo
                // Also refill current mag
                if (currentWeapon === 'ak') ammo = 30;
                else if (currentWeapon === 'sniper') sniperAmmo = 5;
                else if (currentWeapon === 'shotgun') shotgunAmmo = 8;
                addScore(200);
                break;

            case 'explosive':
                explosiveRoundsTimer = 8; // 8 seconds of explosive rounds
                addScore(200);
                // Flash screen orange
                damageFlashIntensity = 0.5;
                document.getElementById('damage-flash').style.background =
                    'radial-gradient(ellipse at center, rgba(255,100,0,0.3) 0%, rgba(255,50,0,0.5) 100%)';
                setTimeout(() => {
                    document.getElementById('damage-flash').style.background =
                        'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
                }, 200);
                break;

            case 'penetrating':
                penetratingRoundsTimer = 10; // 10 seconds of armor-piercing
                addScore(150);
                break;

            case 'shield':
                shieldTimer = 12; // 12 seconds of shield
                addScore(150);
                // Flash screen blue
                damageFlashIntensity = 0.4;
                document.getElementById('damage-flash').style.background =
                    'radial-gradient(ellipse at center, rgba(68,136,255,0.4) 0%, rgba(30,60,150,0.3) 100%)';
                setTimeout(() => {
                    document.getElementById('damage-flash').style.background =
                        'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
                }, 200);
                break;

            case 'slowmo':
                // Trigger extended bullet time (player-controlled)
                triggerPowerupSlowmo();
                addScore(250);
                break;

            case 'nuke':
                // Kill all zombies!
                for (const zombie of zombies) {
                    if (!zombie.isDead) {
                        zombie.die();
                    }
                }
                addScore(500);
                playSound('nuke');
                // Screen flash
                damageFlashIntensity = 1.0;
                document.getElementById('damage-flash').style.background =
                    'radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,0,255,0.4) 100%)';
                setTimeout(() => {
                    document.getElementById('damage-flash').style.background =
                        'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
                }, 300);
                break;
        }

        updateHUD();
        this.remove();
    }

    remove() {
        scene.remove(this.mesh);
    }
}

function spawnPickup(type, x, z) {
    // Clamp to arena
    x = Math.max(-170, Math.min(170, x));
    z = Math.max(-170, Math.min(170, z));
    pickups.push(new Pickup(type, x, z));
}

// Rarity-weighted pickup selection
function getRandomPickupType() {
    // Build weighted array based on rarity (lower rarity = more common)
    // Rarity 1: 40% chance, Rarity 2: 25%, Rarity 3: 18%, Rarity 4: 12%, Rarity 5: 5%
    const rarityWeights = { 1: 40, 2: 25, 3: 18, 4: 12, 5: 5 };
    const weightedTypes = [];

    for (const [type, config] of Object.entries(PICKUP_TYPES)) {
        const weight = rarityWeights[config.rarity] || 10;
        for (let i = 0; i < weight; i++) {
            weightedTypes.push(type);
        }
    }

    return weightedTypes[Math.floor(Math.random() * weightedTypes.length)];
}

// Track last pickup spawn time
let lastPickupSpawnTime = 0;
const PICKUP_SPAWN_INTERVAL = 15; // Seconds between potential spawns
const MAX_PICKUPS = 5; // Maximum pickups on field at once

function updatePickups(dt, time) {
    // Update existing pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
        if (pickups[i].update(dt, time)) {
            pickups.splice(i, 1);
        }
    }

    // Spawn pickups during waves (rarity-based)
    if (waveInProgress && pickups.length < MAX_PICKUPS) {
        const timeSec = time / 1000;
        if (timeSec - lastPickupSpawnTime > PICKUP_SPAWN_INTERVAL) {
            // Chance increases with wave number (up to 60%)
            const spawnChance = Math.min(0.3 + currentWave * 0.03, 0.6);
            if (Math.random() < spawnChance) {
                const type = getRandomPickupType();
                // Spawn at random position around player (not too close, not too far)
                const angle = Math.random() * Math.PI * 2;
                const dist = 15 + Math.random() * 35;
                const x = camera.position.x + Math.cos(angle) * dist;
                const z = camera.position.z + Math.sin(angle) * dist;
                spawnPickup(type, x, z);
                lastPickupSpawnTime = timeSec;
            }
        }
    }
}

// Floating pickup text
let pickupTextTimeout = null;
function showPickupText(text, color) {
    let textEl = document.getElementById('pickup-text');
    if (!textEl) {
        textEl = document.createElement('div');
        textEl.id = 'pickup-text';
        textEl.style.cssText = `
            position: absolute; top: 40%; left: 50%; transform: translateX(-50%);
            font-size: 32px; font-weight: bold; pointer-events: none;
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
            transition: opacity 0.3s, top 0.5s;
        `;
        document.body.appendChild(textEl);
    }

    textEl.textContent = text;
    textEl.style.color = '#' + color.toString(16).padStart(6, '0');
    textEl.style.opacity = '1';
    textEl.style.top = '40%';

    if (pickupTextTimeout) clearTimeout(pickupTextTimeout);
    pickupTextTimeout = setTimeout(() => {
        textEl.style.opacity = '0';
        textEl.style.top = '35%';
    }, 1000);
}
=== END POWER-UPS DISABLED === */

// BLOOD & GORE SYSTEM
const bloodParticles = [];
const goreChunks = [];
const bloodDecals = [];
const bloodPools = [];

// Blood splatter texture (procedural)
const bloodTexCanvas = document.createElement('canvas');
bloodTexCanvas.width = 64; bloodTexCanvas.height = 64;
const bloodCtx = bloodTexCanvas.getContext('2d');
const bloodGrad = bloodCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
bloodGrad.addColorStop(0, 'rgba(180, 0, 0, 1)');
bloodGrad.addColorStop(0.3, 'rgba(120, 0, 0, 0.8)');
bloodGrad.addColorStop(0.7, 'rgba(80, 0, 0, 0.4)');
bloodGrad.addColorStop(1, 'rgba(40, 0, 0, 0)');
bloodCtx.fillStyle = bloodGrad;
bloodCtx.fillRect(0, 0, 64, 64);
const bloodSpriteTex = new THREE.CanvasTexture(bloodTexCanvas);

// Blood mist texture
const mistTexCanvas = document.createElement('canvas');
mistTexCanvas.width = 128; mistTexCanvas.height = 128;
const mistCtx = mistTexCanvas.getContext('2d');
const mistGrad = mistCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
mistGrad.addColorStop(0, 'rgba(150, 0, 0, 0.6)');
mistGrad.addColorStop(0.5, 'rgba(100, 0, 0, 0.3)');
mistGrad.addColorStop(1, 'rgba(60, 0, 0, 0)');
mistCtx.fillStyle = mistGrad;
mistCtx.fillRect(0, 0, 128, 128);
const bloodMistTex = new THREE.CanvasTexture(mistTexCanvas);

// Blood decal texture (splatter pattern)
const bloodDecalCanvas = document.createElement('canvas');
bloodDecalCanvas.width = 256; bloodDecalCanvas.height = 256;
const decalCtx = bloodDecalCanvas.getContext('2d');
decalCtx.fillStyle = 'rgba(0,0,0,0)';
decalCtx.fillRect(0, 0, 256, 256);
// Main splat
decalCtx.beginPath();
decalCtx.arc(128, 128, 60 + Math.random() * 20, 0, Math.PI * 2);
decalCtx.fillStyle = 'rgba(100, 0, 0, 0.9)';
decalCtx.fill();
// Splatter droplets
for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 40 + Math.random() * 80;
    const x = 128 + Math.cos(angle) * dist;
    const y = 128 + Math.sin(angle) * dist;
    const r = 3 + Math.random() * 12;
    decalCtx.beginPath();
    decalCtx.arc(x, y, r, 0, Math.PI * 2);
    decalCtx.fillStyle = `rgba(${80 + Math.random() * 40}, 0, 0, ${0.6 + Math.random() * 0.4})`;
    decalCtx.fill();
}
// Streaks
for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    decalCtx.beginPath();
    decalCtx.moveTo(128, 128);
    const len = 50 + Math.random() * 70;
    decalCtx.lineTo(128 + Math.cos(angle) * len, 128 + Math.sin(angle) * len);
    decalCtx.strokeStyle = `rgba(90, 0, 0, ${0.5 + Math.random() * 0.3})`;
    decalCtx.lineWidth = 2 + Math.random() * 4;
    decalCtx.stroke();
}
const bloodDecalTex = new THREE.CanvasTexture(bloodDecalCanvas);

// Gore materials
const goreMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.6 });
const boneMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.4 });
const organMat = new THREE.MeshStandardMaterial({ color: 0x4a0000, roughness: 0.7 });

// Pre-create blood sprite materials (avoid runtime allocation)
const bloodSpriteMats = [];
for (let i = 0; i < 40; i++) {
    bloodSpriteMats.push(new THREE.SpriteMaterial({
        map: bloodSpriteTex,
        color: new THREE.Color(0.5 + Math.random() * 0.3, 0, 0),
        transparent: true,
        opacity: 0.8,
        depthWrite: false
    }));
}
let bloodMatIdx = 0;

// Blood sprite pool
const bloodSpritePool = new ObjectPool(
    () => { const s = new THREE.Sprite(bloodSpriteMats[0]); s.visible = false; return s; },
    (s) => { s.visible = false; },
    MAX_BLOOD_PARTICLES
);

// Reusable vector for blood spray
const _bloodVel = new THREE.Vector3();

// Blood spray on hit - VIOLENT
function spawnBloodSpray(position, direction, intensity = 1) {
    const count = Math.floor(10 * intensity); // More blood

    // Blood droplets
    for (let i = 0; i < count; i++) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.1 + Math.random() * 0.15);
        sprite.visible = true;

        // VIOLENT blood spray velocity
        _bloodVel.copy(direction).multiplyScalar(6 + Math.random() * 10);
        _bloodVel.x += (Math.random() - 0.5) * 8;
        _bloodVel.y += Math.random() * 6;
        _bloodVel.z += (Math.random() - 0.5) * 8;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: _bloodVel.clone(),
            life: 1.0 + Math.random() * 0.5,
            gravity: 15,
            type: 'droplet'
        });
    }

    // Light blood mist (only on major hits, reuse material)
    if (intensity > 1.5) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.5);
        sprite.visible = true;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: direction.clone().multiplyScalar(2),
            life: 0.4,
            gravity: 0,
            type: 'mist',
            initialScale: 0.5
        });
    }
}

// === OPTIMIZED EXPLOSION SYSTEM ===
const explosionParticles = [];
const explosionGeo = new THREE.SphereGeometry(1, 12, 8); // Shared geometry
const explosionMatTemplate = new THREE.MeshBasicMaterial({
    color: 0xff4400,
    transparent: true,
    opacity: 0.8,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});

// Pool for explosion meshes
const explosionPool = new ObjectPool(() => {
    const mesh = new THREE.Mesh(explosionGeo, explosionMatTemplate.clone());
    mesh.visible = false;
    scene.add(mesh);
    return mesh;
}, (mesh) => {
    mesh.visible = false;
}, 30);

// Pool for explosion lights (expensive! limit to 4)
const explosionLightPool = new ObjectPool(() => {
    const light = new THREE.PointLight(0xff6600, 3, 10);
    light.visible = false;
    scene.add(light);
    return light;
}, (light) => {
    light.visible = false;
}, 4);

function updateExplosions(dt) {
    for (let i = explosionParticles.length - 1; i >= 0; i--) {
        const p = explosionParticles[i];
        p.age += dt;
        
        if (p.age >= p.maxAge) {
            explosionPool.release(p.mesh);
            if (p.light) explosionLightPool.release(p.light);
            explosionParticles.splice(i, 1);
        } else {
            const progress = p.age / p.maxAge;
            const scale = 0.5 + (p.maxScale - 0.5) * (1 - Math.pow(1 - progress, 3)); // Cubic ease out
            p.mesh.scale.setScalar(scale);
            p.mesh.material.opacity = 0.8 * (1 - progress);
            
            if (p.light) {
                p.light.intensity = 3 * (1 - progress);
            }
        }
    }
}

// EXPLOSIVE ROUNDS - AOE damage and visual effect (Optimized)
function spawnExplosion(position, radius, damageMultiplier = 1.0) {
    // 1. Visual Sphere (Pooled)
    const explosion = explosionPool.get();
    if (explosion) {
        explosion.position.copy(position);
        explosion.scale.setScalar(0.5);
        explosion.material.opacity = 0.8;
        explosion.visible = true;
        
        explosionParticles.push({
            mesh: explosion,
            light: null,
            age: 0,
            maxAge: 0.35, // Fast bang
            maxScale: radius * 0.7
        });
        
        // 2. Light (Pooled, limited)
        const light = explosionLightPool.get();
        if (light) {
            light.position.copy(position);
            light.distance = radius * 2;
            light.intensity = 3;
            light.visible = true;
            explosionParticles[explosionParticles.length - 1].light = light;
        }
    }
    
    // 3. Skip extra fire sprites for performance - the sphere + light is enough visual feedback

    // AOE damage to zombies
    for (const zombie of zombies) {
        if (zombie.isDead) continue;
        const dist = position.distanceTo(zombie.mesh.position);
        if (dist < radius) {
            // Damage falls off with distance
            const falloff = 1 - (dist / radius);
            const damage = falloff * damageMultiplier;
            zombie.hit(position, damage);

            // Screen shake for close explosions
            if (dist < radius * 0.5) {
                Springs.shakeX.impulse((Math.random() - 0.5) * 3 * falloff);
                Springs.shakeY.impulse(Math.random() * 2 * falloff);
            }
        }
    }

    // Play explosion sound
    playSound('explosion');
}

// Spawn gore chunks on death - VIOLENT
function spawnGoreChunks(position, direction) {
    const chunkCount = 6 + Math.floor(Math.random() * 4); // More chunks

    for (let i = 0; i < chunkCount; i++) {
        let geo, mat;
        const type = Math.random();

        if (type < 0.6) {
            // Small meat chunk
            geo = new THREE.DodecahedronGeometry(0.08 + Math.random() * 0.08);
            mat = goreMat.clone();
        } else {
            // Bone fragment
            geo = new THREE.BoxGeometry(0.04, 0.12, 0.04);
            mat = boneMat.clone();
        }

        const chunk = new THREE.Mesh(geo, mat);
        chunk.position.copy(position);
        chunk.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        chunk.castShadow = true;

        // VIOLENT - explosive chunk velocity
        const vel = direction.clone().multiplyScalar(8 + Math.random() * 10);
        vel.add(new THREE.Vector3(
            (Math.random() - 0.5) * 12,
            Math.random() * 8 + 4,
            (Math.random() - 0.5) * 12
        ));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 6 + Math.random() * 3,
            grounded: false,
            canBleed: Math.random() > 0.7,
            bleedTimer: 0
        });
    }
}

// HEAD EXPLOSION - Satisfying headshot effect
// Brain/skull material for headshot gore
const brainMat = new THREE.MeshStandardMaterial({ color: 0xcc6677, roughness: 0.8 });
const skullMat = new THREE.MeshStandardMaterial({ color: 0xddccbb, roughness: 0.5 });

function explodeHead(zombie, hitPoint, direction) {
    // Get the head mesh (first child of zombie mesh)
    const head = zombie.mesh.children[0];
    if (!head) return;

    // Get head world position before hiding
    const headWorldPos = new THREE.Vector3();
    head.getWorldPosition(headWorldPos);

    // Hide the head
    head.visible = false;
    zombie.headExploded = true;

    // Play headshot sound
    playSound('headshot');

    // MASSIVE blood spray in all directions
    for (let i = 0; i < 5; i++) {
        const sprayDir = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            Math.random() * 0.5 + 0.5,
            (Math.random() - 0.5) * 2
        ).normalize();
        spawnBloodSpray(headWorldPos.clone(), sprayDir, 3);
    }

    // Spawn skull fragments
    const skullFragCount = 6 + Math.floor(Math.random() * 4);
    for (let i = 0; i < skullFragCount; i++) {
        const size = 0.08 + Math.random() * 0.12;
        const geo = new THREE.TetrahedronGeometry(size);
        const chunk = new THREE.Mesh(geo, skullMat.clone());
        chunk.position.copy(headWorldPos);
        chunk.castShadow = true;

        // Explosive outward velocity
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            Math.random() * 15 + 5,
            (Math.random() - 0.5) * 20
        );
        // Add direction bias from bullet
        vel.add(direction.clone().multiplyScalar(10));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 40
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 5 + Math.random() * 3,
            grounded: false,
            canBleed: true,
            bleedTimer: 0,
            isSkull: true
        });
    }

    // Spawn brain chunks (pink/red squishy bits)
    const brainChunkCount = 8 + Math.floor(Math.random() * 5);
    for (let i = 0; i < brainChunkCount; i++) {
        const size = 0.06 + Math.random() * 0.1;
        const geo = new THREE.SphereGeometry(size, 6, 4);
        // Deform slightly for organic look
        const positions = geo.attributes.position;
        for (let j = 0; j < positions.count; j++) {
            positions.setXYZ(j,
                positions.getX(j) * (0.8 + Math.random() * 0.4),
                positions.getY(j) * (0.8 + Math.random() * 0.4),
                positions.getZ(j) * (0.8 + Math.random() * 0.4)
            );
        }

        const chunk = new THREE.Mesh(geo, brainMat.clone());
        chunk.position.copy(headWorldPos);
        chunk.castShadow = true;

        // Slower, goopier velocity for brain matter
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 15,
            Math.random() * 10 + 3,
            (Math.random() - 0.5) * 15
        );
        vel.add(direction.clone().multiplyScalar(8));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 4 + Math.random() * 2,
            grounded: false,
            canBleed: true,
            bleedTimer: 0,
            isBrain: true
        });
    }

    // Create a blood mist cloud at head position
    for (let i = 0; i < 3; i++) {
        const mistSprite = bloodSpritePool.get();
        mistSprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        mistSprite.position.copy(headWorldPos);
        mistSprite.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        mistSprite.scale.setScalar(1.0 + Math.random() * 0.5);
        mistSprite.visible = true;

        scene.add(mistSprite);
        bloodParticles.push({
            mesh: mistSprite,
            velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                Math.random() * 2,
                (Math.random() - 0.5) * 2
            ),
            life: 0.6,
            gravity: 0,
            type: 'mist',
            initialScale: mistSprite.scale.x
        });
    }
}

// Spawn blood decal on ANY surface (floor or obstacles)
function spawnBloodDecal(position, normal, size = 1) {
    const decalMat = new THREE.MeshBasicMaterial({
        map: bloodDecalTex,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -2,
        side: THREE.DoubleSide
    });

    const decalSize = (1.5 + Math.random() * 1.5) * size;
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(decalSize, decalSize), decalMat);
    decal.position.copy(position);

    // If normal is provided and not pointing up, orient to surface
    if (normal && Math.abs(normal.y) < 0.9) {
        // Vertical or angled surface (obstacle)
        decal.position.addScaledVector(normal, 0.02); // Offset slightly from surface
        decal.lookAt(position.clone().add(normal));
        decal.rotation.z = Math.random() * Math.PI * 2;
    } else {
        // Floor (horizontal surface)
        decal.position.y = -4.95; // Just above floor
        decal.rotation.x = -Math.PI / 2;
        decal.rotation.z = Math.random() * Math.PI * 2;
    }

    scene.add(decal);
    bloodDecals.push({
        mesh: decal,
        life: 10.0 + Math.random() * 5.0
    });
}

// Raycaster for blood collision with obstacles
const bloodRaycaster = new THREE.Raycaster();
const _bloodRayDir = new THREE.Vector3();

// Check if blood particle hits an obstacle and spawn decal
function checkBloodObstacleCollision(particle) {
    if (!particle.velocity || particle.type !== 'droplet') return false;

    // Cast ray in direction of movement
    _bloodRayDir.copy(particle.velocity).normalize();
    bloodRaycaster.set(particle.mesh.position, _bloodRayDir);
    bloodRaycaster.far = particle.velocity.length() * 0.1; // Check short distance

    const hits = bloodRaycaster.intersectObjects(obstacles);
    if (hits.length > 0) {
        const hit = hits[0];
        // Spawn blood splat on obstacle surface
        spawnBloodDecal(hit.point, hit.face.normal, 0.4 + Math.random() * 0.3);
        return true;
    }
    return false;
}

// Spawn expanding blood pool under body
function spawnBloodPool(position) {
    const poolMat = new THREE.MeshBasicMaterial({
        color: 0x3a0000,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1
    });

    const pool = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), poolMat);
    pool.position.copy(position);
    pool.position.y = -4.98;
    pool.rotation.x = -Math.PI / 2;

    scene.add(pool);
    bloodPools.push({
        mesh: pool,
        targetSize: 2.0 + Math.random() * 1.5, // Bigger pools
        currentSize: 0.1,
        growthRate: 1.0 + Math.random() * 0.5, // Faster growth
        life: 8.0 + Math.random() * 5.0 // Fixed: 8-13 seconds instead of 500-800 frames
    });
}

// Reusable normal vector for decals
const _upNormal = new THREE.Vector3(0, 1, 0);

// Update blood particle systems (optimized with swap-and-pop)
function updateBloodEffects(dt) {
    // Update blood particles
    for (let i = bloodParticles.length - 1; i >= 0; i--) {
        const p = bloodParticles[i];
        p.life -= dt;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodSpritePool.release(p.mesh);
            bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
            bloodParticles.pop();
            continue;
        }

        if (p.type === 'droplet') {
            p.velocity.y -= p.gravity * dt;
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.mesh.material.opacity = Math.min(1, p.life);

            // Check for obstacle collision (blood sticks to walls/crates)
            if (checkBloodObstacleCollision(p)) {
                scene.remove(p.mesh);
                bloodSpritePool.release(p.mesh);
                bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
                bloodParticles.pop();
                continue;
            }

            // Hit ground
            if (p.mesh.position.y < -4.8) {
                if (Math.random() > 0.7) { // Increased decal spawns
                    spawnBloodDecal(p.mesh.position.clone(), _upNormal, 0.3);
                }
                scene.remove(p.mesh);
                bloodSpritePool.release(p.mesh);
                bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
                bloodParticles.pop();
            }
        } else if (p.type === 'mist') {
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.velocity.multiplyScalar(0.95);
            p.mesh.scale.setScalar(p.initialScale * (1 + (1 - p.life) * 3));
            p.mesh.material.opacity = p.life * 0.5;
        }
    }

    // Update gore chunks
    for (let i = goreChunks.length - 1; i >= 0; i--) {
        const g = goreChunks[i];
        g.life -= dt;

        if (g.life <= 0) {
            scene.remove(g.mesh);
            goreChunks[i] = goreChunks[goreChunks.length - 1];
            goreChunks.pop();
            continue;
        }

        if (!g.grounded) {
            g.velocity.y -= 20 * dt;
            g.mesh.position.addScaledVector(g.velocity, dt);
            g.mesh.rotation.x += g.rotVelocity.x * dt;
            g.mesh.rotation.y += g.rotVelocity.y * dt;
            g.mesh.rotation.z += g.rotVelocity.z * dt;

            // Check for obstacle collision (gore sticks to walls/crates)
            _bloodRayDir.copy(g.velocity).normalize();
            bloodRaycaster.set(g.mesh.position, _bloodRayDir);
            bloodRaycaster.far = g.velocity.length() * dt * 2;
            const goreHits = bloodRaycaster.intersectObjects(obstacles);
            if (goreHits.length > 0 && g.canBleed) {
                const hit = goreHits[0];
                // Splatter blood on obstacle
                spawnBloodDecal(hit.point, hit.face.normal, 0.5 + Math.random() * 0.3);
                // Bounce off
                g.velocity.reflect(hit.face.normal).multiplyScalar(0.3);
                g.rotVelocity.multiplyScalar(0.5);
            }

            if (g.mesh.position.y < -4.7) {
                g.mesh.position.y = -4.7;
                if (Math.abs(g.velocity.y) > 2) {
                    g.velocity.y *= -0.3;
                    g.velocity.x *= 0.7;
                    g.velocity.z *= 0.7;
                    g.rotVelocity.multiplyScalar(0.5);
                    if (Math.random() > 0.4) { // More decal spawns
                        spawnBloodDecal(g.mesh.position.clone(), _upNormal, 0.5);
                    }
                } else {
                    g.grounded = true;
                    g.velocity.set(0, 0, 0);
                }
            }
        }

        // Bleeding effect (disabled for performance)
        // if (g.canBleed && !g.grounded) { ... }

        if (g.life < 2) {
            g.mesh.material.opacity = g.life / 2;
            g.mesh.material.transparent = true;
        }
    }

    // Update blood pools
    for (let i = bloodPools.length - 1; i >= 0; i--) {
        const p = bloodPools[i];
        p.life -= dt; // Fixed: time-based instead of frame-based

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodPools[i] = bloodPools[bloodPools.length - 1];
            bloodPools.pop();
            continue;
        }

        if (p.currentSize < p.targetSize) {
            p.currentSize += p.growthRate * dt;
            p.mesh.scale.setScalar(p.currentSize);
        }

        if (p.life < 1.5) {
            p.mesh.material.opacity = (p.life / 1.5) * 0.9; // Fixed: fade over last 1.5 seconds
        }
    }

    // Update blood decals
    for (let i = bloodDecals.length - 1; i >= 0; i--) {
        const d = bloodDecals[i];
        d.life -= dt; // Fixed: time-based instead of frame-based

        if (d.life <= 0) {
            scene.remove(d.mesh);
            bloodDecals[i] = bloodDecals[bloodDecals.length - 1];
            bloodDecals.pop();
            continue;
        }

        if (d.life < 1.5) {
            d.mesh.material.opacity = (d.life / 1.5) * 0.85; // Fixed: fade over last 1.5 seconds
        }
    }
}

// ATMOSPHERIC DUST PARTICLES (reduced for performance)
const dustParticles = [];
const dustGeo = new THREE.BufferGeometry();
const dustCount = 100; // Further reduced for performance
const dustPositions = new Float32Array(dustCount * 3);
for(let i = 0; i < dustCount; i++) {
    dustPositions[i * 3] = (Math.random() - 0.5) * 200;
    dustPositions[i * 3 + 1] = Math.random() * 30 - 5;
    dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
const dustMat = new THREE.PointsMaterial({
    color: 0xeebb88, // Warm dust
    size: 0.08, // Smaller particles
    transparent: true,
    opacity: 0.2, // Less opaque
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
});
const dustCloud = new THREE.Points(dustGeo, dustMat);
scene.add(dustCloud);

/**
 * GUN CONSTRUCTION
 */
const gunGroup = new THREE.Group();
const recoilGroup = new THREE.Group();
recoilGroup.add(gunGroup);

// Enhanced gun materials with environment reflections
const woodMat = new THREE.MeshStandardMaterial({
    map: woodTex,
    roughness: 0.45,
    metalness: 0.05,
    bumpMap: woodTex,
    bumpScale: 0.03,
    envMap: envMapTex,
    envMapIntensity: 0.15
});

const metalMat = new THREE.MeshStandardMaterial({
    map: metalTexLight,
    color: 0xdddddd,
    roughness: 0.25,
    metalness: 0.95,
    bumpMap: metalTexLight,
    bumpScale: 0.008,
    envMap: envMapTex,
    envMapIntensity: 0.6
});

const darkMetalMat = new THREE.MeshStandardMaterial({
    map: metalTexDark,
    color: 0x1a1a1a,
    roughness: 0.5,
    metalness: 0.7,
    bumpMap: metalTexDark,
    bumpScale: 0.01,
    envMap: envMapTex,
    envMapIntensity: 0.3
});

const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 4), darkMetalMat);
receiver.castShadow = true; gunGroup.add(receiver);

const dustCover = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4, 16, 1, false, 0, Math.PI), darkMetalMat);
dustCover.rotation.set(Math.PI/2, Math.PI/2, 0); dustCover.position.y = 0.5; dustCover.castShadow = true; gunGroup.add(dustCover);

const stock = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 3), woodMat);
stock.position.set(0, -0.5, 3.5); stock.rotation.x = 0.2; stock.castShadow = true; gunGroup.add(stock);

const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 6, 12), metalMat);
barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.3, -4); barrel.castShadow = true; gunGroup.add(barrel);

const gasTube = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 3, 12), metalMat);
gasTube.rotation.x = Math.PI / 2; gasTube.position.set(0, 0.7, -3); gunGroup.add(gasTube);

const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 2.5), woodMat);
handguard.position.set(0, 0.2, -3); handguard.castShadow = true; gunGroup.add(handguard);

const grip = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.5, 0.8), woodMat);
grip.position.set(0, -1, 0.5); grip.rotation.x = -0.3; grip.castShadow = true; gunGroup.add(grip);

// Sights
const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.2), darkMetalMat);
frontSight.position.set(0, 0.8, -6.5); frontSight.castShadow = true; gunGroup.add(frontSight);

const rearSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), darkMetalMat);
rearSightBase.position.set(0, 0.9, -1.0); gunGroup.add(rearSightBase);
const rearSightL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightL.position.set(-0.15, 1.1, -1.0); gunGroup.add(rearSightL);
const rearSightR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightR.position.set(0.15, 1.1, -1.0); gunGroup.add(rearSightR);

const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.6), metalMat);
bolt.position.set(0.5, 0.4, -0.5); bolt.castShadow = true; gunGroup.add(bolt);

// Magazine Pivot Group (For cooler reloading arcs)
const magPivot = new THREE.Group();
magPivot.position.set(0, -0.5, -1);
gunGroup.add(magPivot);

const magGeo = new THREE.BoxGeometry(0.6, 2.5, 1.2);
const magCurve = new THREE.Mesh(magGeo, metalMat);
magCurve.rotation.x = 0.4; magCurve.position.y = -1.2; magCurve.castShadow = true;
magPivot.add(magCurve);

// ENHANCED MUZZLE FLASH VFX
const flashGroup = new THREE.Group();

// Core flash (bright white center)
const flashCoreMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
const flashCore = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), flashCoreMat);
flashGroup.add(flashCore);

// Mid flash (orange/yellow)
const flashMidMat = new THREE.MeshBasicMaterial({
    color: 0xffaa44, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    flashGroup.add(f);
}

// Outer flash (red/orange glow)
const flashOuterMat = new THREE.MeshBasicMaterial({
    color: 0xff6622, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<6; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), flashOuterMat);
    f.rotation.z = (Math.PI / 3) * i;
    flashGroup.add(f);
}

// Flash streaks (elongated for directional feel)
const flashStreakMat = new THREE.MeshBasicMaterial({
    color: 0xffcc66, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<3; i++) {
    const streak = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 3.0), flashStreakMat);
    streak.rotation.z = (Math.PI / 3) * i + Math.PI/6;
    streak.position.z = -0.5;
    flashGroup.add(streak);
}

flashGroup.position.set(0, 0.3, -7.2);
gunGroup.add(flashGroup);

// Legacy reference for compatibility
const flashMat = flashMidMat;

/**
 * SNIPER RIFLE CONSTRUCTION - Geometric Tactical Style
 */
const sniperGroup = new THREE.Group();
const sniperRecoilGroup = new THREE.Group();
sniperRecoilGroup.add(sniperGroup);

// Materials for geometric sniper
const gunMetalDark = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.3,
    metalness: 0.8,
    envMap: envMapTex,
    envMapIntensity: 0.5
});
const gunMetalLight = new THREE.MeshStandardMaterial({
    color: 0x333333,
    roughness: 0.4,
    metalness: 0.6,
    envMap: envMapTex,
    envMapIntensity: 0.4
});
const scopeLensMat = new THREE.MeshStandardMaterial({
    color: 0x110022,
    roughness: 0.1,
    metalness: 0.9,
    envMap: envMapTex,
    envMapIntensity: 1.5,
    transparent: true,
    opacity: 0.9
});

// Scale factor to match game scale (original model is larger)
const geoScale = 0.12;
const offsetZ = 0; // Center offset

// Helper functions for geometric construction
function createSniperBox(w, h, d, mat, x, y, z, rotX=0, rotY=0, rotZ=0) {
    const geo = new THREE.BoxGeometry(w * geoScale, h * geoScale, d * geoScale);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x * geoScale, y * geoScale, z * geoScale + offsetZ);
    mesh.rotation.set(rotX, rotY, rotZ);
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
}

function createSniperCylinder(rt, rb, h, seg, mat, x, y, z, rotX=0, rotZ=0) {
    const geo = new THREE.CylinderGeometry(rt * geoScale, rb * geoScale, h * geoScale, seg);
    const mesh = new THREE.Mesh(geo, mat);
    mesh.position.set(x * geoScale, y * geoScale, z * geoScale + offsetZ);
    mesh.rotation.x = rotX;
    mesh.rotation.z = rotZ;
    mesh.castShadow = true;
    mesh.receiveShadow = true;
    return mesh;
}

// 1. Lower Receiver (Main body)
const sniperReceiver = createSniperBox(1.2, 1.8, 8, gunMetalDark, 0, 0, 0);
sniperGroup.add(sniperReceiver);

// Upper Rail (Picatinny)
const sniperRail = createSniperBox(1.0, 0.4, 9, gunMetalLight, 0, 1.1, 0.5);
sniperGroup.add(sniperRail);

// 2. Barrel Assembly
// Main Barrel - long and heavy
const sniperBarrel = createSniperCylinder(0.25, 0.25, 12, 16, gunMetalLight, 0, 0.2, -10, Math.PI / 2);
sniperGroup.add(sniperBarrel);

// Barrel Base/Fluting (thicker near receiver)
const sniperBarrelBase = createSniperCylinder(0.4, 0.4, 4, 16, gunMetalDark, 0, 0.2, -5, Math.PI / 2);
sniperGroup.add(sniperBarrelBase);

// Muzzle Brake (angular tactical design)
const brakeMain = createSniperBox(1.2, 0.8, 1.5, gunMetalDark, 0, 0.2, -16);
sniperGroup.add(brakeMain);

// Muzzle brake side vents
const brakeVentL = createSniperBox(0.3, 0.4, 1.0, gunMetalLight, -0.7, 0.2, -16);
sniperGroup.add(brakeVentL);
const brakeVentR = createSniperBox(0.3, 0.4, 1.0, gunMetalLight, 0.7, 0.2, -16);
sniperGroup.add(brakeVentR);

// 3. Bolt handle (prominent for bolt-action)
const sniperBoltHandle = new THREE.Group();
const boltBody = new THREE.Mesh(
    new THREE.CylinderGeometry(0.06 * geoScale, 0.06 * geoScale, 1.5 * geoScale, 8),
    gunMetalLight
);
boltBody.rotation.x = Math.PI / 2;
boltBody.position.set(0.5 * geoScale, 0.6 * geoScale, 0.5 * geoScale);
boltBody.castShadow = true;
sniperBoltHandle.add(boltBody);

const boltKnob = new THREE.Mesh(
    new THREE.SphereGeometry(0.15 * geoScale, 8, 8),
    gunMetalDark
);
boltKnob.position.set(0.5 * geoScale, 0.6 * geoScale, 1.3 * geoScale);
boltKnob.castShadow = true;
sniperBoltHandle.add(boltKnob);

const boltStem = new THREE.Mesh(
    new THREE.CylinderGeometry(0.05 * geoScale, 0.05 * geoScale, 0.5 * geoScale, 6),
    gunMetalLight
);
boltStem.rotation.z = Math.PI / 2;
boltStem.position.set(0.25 * geoScale, 0.6 * geoScale, 0.5 * geoScale);
boltStem.castShadow = true;
sniperBoltHandle.add(boltStem);

sniperGroup.add(sniperBoltHandle);

// 4. Grip & Trigger
const sniperGrip = createSniperBox(0.8, 2, 1, gunMetalDark, 0, -1.5, 3.5, -0.3);
sniperGroup.add(sniperGrip);

// Trigger guard (angular)
const sniperGuard = createSniperBox(0.4, 0.1, 1.5, gunMetalLight, 0, -1.2, 2.8);
sniperGroup.add(sniperGuard);
const sniperGuardFront = createSniperBox(0.4, 0.6, 0.1, gunMetalLight, 0, -0.95, 2.05);
sniperGroup.add(sniperGuardFront);
const sniperGuardBack = createSniperBox(0.4, 0.6, 0.1, gunMetalLight, 0, -0.95, 3.55);
sniperGroup.add(sniperGuardBack);

// 5. Stock (Shoulder rest) - tactical folding style
const stockStrut = createSniperBox(1.2, 1.5, 3, gunMetalDark, 0, 0, 5.5);
sniperGroup.add(stockStrut);

// Stock tube (buffer tube style)
const stockTube = createSniperCylinder(0.3, 0.3, 2.5, 12, gunMetalLight, 0, 0.2, 6.5, Math.PI / 2);
sniperGroup.add(stockTube);

const buttPad = createSniperBox(1.4, 2.5, 0.5, new THREE.MeshStandardMaterial({
    color: 0x111111, roughness: 0.8, metalness: 0.1
}), 0, -0.3, 7.5);
sniperGroup.add(buttPad);

// Cheek rest (adjustable style)
const cheekRest = createSniperBox(0.8, 0.6, 2, gunMetalDark, 0, 1.0, 5);
sniperGroup.add(cheekRest);

// 6. Scope Assembly
// Scope tube main
const scopeTube = createSniperCylinder(0.35, 0.35, 5, 16, gunMetalDark, 0, 2.2, 1, Math.PI / 2);
sniperGroup.add(scopeTube);

// Scope objective (front, larger)
const scopeFront = createSniperCylinder(0.5, 0.5, 1, 16, gunMetalDark, 0, 2.2, -1.5, Math.PI / 2);
sniperGroup.add(scopeFront);

// Scope ocular (rear)
const scopeBack = createSniperCylinder(0.4, 0.4, 1, 16, gunMetalDark, 0, 2.2, 3.5, Math.PI / 2);
sniperGroup.add(scopeBack);

// Scope lens (reflective)
const lensMesh = createSniperCylinder(0.45, 0.45, 0.1, 16, scopeLensMat, 0, 2.2, -1.95, Math.PI / 2);
sniperGroup.add(lensMesh);

// Scope lens rear
const lensRear = new THREE.Mesh(
    new THREE.CircleGeometry(0.35 * geoScale, 16),
    scopeLensMat
);
lensRear.position.set(0, 2.2 * geoScale, 4 * geoScale);
sniperGroup.add(lensRear);

// Scope mounts (tactical ring mounts)
const mountFront = createSniperBox(0.8, 1, 0.5, gunMetalLight, 0, 1.5, 0);
sniperGroup.add(mountFront);
const mountBack = createSniperBox(0.8, 1, 0.5, gunMetalLight, 0, 1.5, 2);
sniperGroup.add(mountBack);

// Scope turrets
const elevationTurret = createSniperCylinder(0.2, 0.2, 0.5, 8, gunMetalLight, 0, 2.8, 1);
sniperGroup.add(elevationTurret);

const windageTurret = new THREE.Mesh(
    new THREE.CylinderGeometry(0.15 * geoScale, 0.15 * geoScale, 0.4 * geoScale, 8),
    gunMetalLight
);
windageTurret.rotation.z = Math.PI / 2;
windageTurret.position.set(0.5 * geoScale, 2.2 * geoScale, 1 * geoScale);
windageTurret.castShadow = true;
sniperGroup.add(windageTurret);

// 7. Bipod (deployed legs)
// Bipod hub
const bipodHub = createSniperCylinder(0.4, 0.4, 1.2, 12, gunMetalDark, 0, -0.3, -4, 0, Math.PI / 2);
sniperGroup.add(bipodHub);

// Left leg
const legL = createSniperCylinder(0.1, 0.08, 3, 8, gunMetalLight, -0.6, -1.8, -4);
legL.rotation.z = 0.25;
sniperGroup.add(legL);

// Left leg foot
const footL = createSniperCylinder(0.15, 0.12, 0.3, 8, gunMetalDark, -0.85, -3.0, -4);
sniperGroup.add(footL);

// Right leg
const legR = createSniperCylinder(0.1, 0.08, 3, 8, gunMetalLight, 0.6, -1.8, -4);
legR.rotation.z = -0.25;
sniperGroup.add(legR);

// Right leg foot
const footR = createSniperCylinder(0.15, 0.12, 0.3, 8, gunMetalDark, 0.85, -3.0, -4);
sniperGroup.add(footR);

// 8. Magazine (box mag, angled)
const sniperMagPivot = new THREE.Group();
sniperMagPivot.position.set(0, -0.3 * geoScale, 1 * geoScale);
sniperGroup.add(sniperMagPivot);

const sniperMag = new THREE.Mesh(
    new THREE.BoxGeometry(1.0 * geoScale, 2.5 * geoScale, 1.5 * geoScale),
    gunMetalLight
);
sniperMag.position.y = -1.5 * geoScale;
sniperMag.rotation.x = 0.15; // Slight angle
sniperMag.castShadow = true;
sniperMagPivot.add(sniperMag);

// Magazine ridges
const magRidge1 = new THREE.Mesh(
    new THREE.BoxGeometry(1.05 * geoScale, 0.15 * geoScale, 1.55 * geoScale),
    gunMetalDark
);
magRidge1.position.set(0, -1.0 * geoScale, 0);
magRidge1.rotation.x = 0.15;
sniperMagPivot.add(magRidge1);

const magRidge2 = new THREE.Mesh(
    new THREE.BoxGeometry(1.05 * geoScale, 0.15 * geoScale, 1.55 * geoScale),
    gunMetalDark
);
magRidge2.position.set(0, -2.0 * geoScale, 0);
magRidge2.rotation.x = 0.15;
sniperMagPivot.add(magRidge2);

// 9. Muzzle flash (positioned at barrel tip)
const sniperFlashGroup = new THREE.Group();
const sniperFlashCore = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 0.6), flashCoreMat);
sniperFlashGroup.add(sniperFlashCore);
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    sniperFlashGroup.add(f);
}
for(let i=0; i<6; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.0), flashOuterMat);
    f.rotation.z = (Math.PI / 3) * i;
    sniperFlashGroup.add(f);
}
sniperFlashGroup.position.set(0, 0.2 * geoScale, -17 * geoScale);
sniperGroup.add(sniperFlashGroup);

// Position and scale the sniper for first-person view
sniperGroup.scale.setScalar(2.3); // Scaled down for less screen coverage

// Position sniper (hidden by default)
sniperRecoilGroup.rotation.y = Math.PI;
sniperRecoilGroup.visible = false;
camera.add(sniperRecoilGroup);

/**
 * SHOTGUN CONSTRUCTION - Simplified Tactical Pump-Action
 */
const shotgunGroup = new THREE.Group();
const shotgunRecoilGroup = new THREE.Group();
shotgunRecoilGroup.add(shotgunGroup);

// Materials for shotgun
const sgMetalMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.3,
    metalness: 0.8,
    envMap: envMapTex,
    envMapIntensity: 0.5
});
const sgPlasticMat = new THREE.MeshStandardMaterial({
    color: 0x080808,
    roughness: 0.9,
    metalness: 0.1,
    envMap: envMapTex,
    envMapIntensity: 0.1
});

// === RECEIVER ===
const sgReceiverGeo = new THREE.BoxGeometry(0.4 * 2.5, 0.6 * 2.5, 2.8 * 2.5);
const sgReceiver = new THREE.Mesh(sgReceiverGeo, sgMetalMat);
sgReceiver.position.z = -0.4 * 2.5;
sgReceiver.castShadow = true;
shotgunGroup.add(sgReceiver);

// === BARREL & MAG TUBE ===
const sgBarrelGeo = new THREE.CylinderGeometry(0.1 * 2.5, 0.1 * 2.5, 3.8 * 2.5, 16);
const sgBarrel = new THREE.Mesh(sgBarrelGeo, sgMetalMat);
sgBarrel.rotation.x = Math.PI / 2;
sgBarrel.position.set(0, 0.15 * 2.5, -2.4 * 2.5);
sgBarrel.castShadow = true;
shotgunGroup.add(sgBarrel);

const sgMagGeo = new THREE.CylinderGeometry(0.09 * 2.5, 0.09 * 2.5, 3.2 * 2.5, 16);
const sgMagTube = new THREE.Mesh(sgMagGeo, sgMetalMat);
sgMagTube.rotation.x = Math.PI / 2;
sgMagTube.position.set(0, -0.12 * 2.5, -2.1 * 2.5);
sgMagTube.castShadow = true;
shotgunGroup.add(sgMagTube);

// === PUMP/HANDGUARD ===
const sgPumpPivot = new THREE.Group();
sgPumpPivot.position.set(0, -0.1 * 2.5, -1.6 * 2.5);
shotgunGroup.add(sgPumpPivot);

const sgPumpGeo = new THREE.CylinderGeometry(0.22 * 2.5, 0.22 * 2.5, 1.1 * 2.5, 10);
const sgPump = new THREE.Mesh(sgPumpGeo, sgPlasticMat);
sgPump.rotation.x = Math.PI / 2;
sgPump.castShadow = true;
sgPumpPivot.add(sgPump);

// === HEAT SHIELD ===
const sgShieldGeo = new THREE.CylinderGeometry(0.16 * 2.5, 0.16 * 2.5, 2.0 * 2.5, 12, 1, true);
const sgShield = new THREE.Mesh(sgShieldGeo, new THREE.MeshStandardMaterial({
    color: 0x111111,
    side: THREE.DoubleSide,
    envMap: envMapTex,
    envMapIntensity: 0.3
}));
sgShield.rotation.x = Math.PI / 2;
sgShield.position.set(0, 0.2 * 2.5, -2.3 * 2.5);
const sgShieldWire = new THREE.Mesh(sgShieldGeo, new THREE.MeshBasicMaterial({ color: 0x000000, wireframe: true }));
sgShield.add(sgShieldWire);
shotgunGroup.add(sgShield);

// === GRIP ===
const sgGripGeo = new THREE.BoxGeometry(0.25 * 2.5, 0.7 * 2.5, 0.4 * 2.5);
const sgGrip = new THREE.Mesh(sgGripGeo, sgPlasticMat);
sgGrip.rotation.x = -Math.PI / 6;
sgGrip.position.set(0, -0.5 * 2.5, 0.7 * 2.5);
sgGrip.castShadow = true;
shotgunGroup.add(sgGrip);

// === STOCK (skeleton style) ===
const sgStockGroup = new THREE.Group();
const sgArmGeo = new THREE.BoxGeometry(0.08 * 2.5, 0.08 * 2.5, 2.2 * 2.5);
const sgArm = new THREE.Mesh(sgArmGeo, sgMetalMat);
sgArm.position.z = 1.1 * 2.5;
sgArm.castShadow = true;
sgStockGroup.add(sgArm);

const sgPadGeo = new THREE.BoxGeometry(0.12 * 2.5, 0.7 * 2.5, 0.1 * 2.5);
const sgPad = new THREE.Mesh(sgPadGeo, sgMetalMat);
sgPad.position.set(0, -0.3 * 2.5, 2.2 * 2.5);
sgPad.castShadow = true;
sgStockGroup.add(sgPad);

sgStockGroup.position.set(0, 0.3 * 2.5, 0.4 * 2.5);
shotgunGroup.add(sgStockGroup);

// === HANDS - Blocky but detailed ===
const skinMat = new THREE.MeshStandardMaterial({
    color: 0xd4a574,
    roughness: 0.7,
    metalness: 0.0
});
const skinMatDark = new THREE.MeshStandardMaterial({
    color: 0xc49464,
    roughness: 0.75,
    metalness: 0.0
});
const nailMat = new THREE.MeshStandardMaterial({
    color: 0xf5deb3,
    roughness: 0.4,
    metalness: 0.1
});
const sleeveMat = new THREE.MeshStandardMaterial({
    color: 0x2a2a2a,
    roughness: 0.8,
    metalness: 0.0
});

// Helper to create a finger segment
function createFinger(length, thickness, mat) {
    const group = new THREE.Group();
    const seg = new THREE.Mesh(new THREE.BoxGeometry(thickness, thickness, length), mat);
    seg.position.z = length / 2;
    seg.castShadow = true;
    group.add(seg);
    // Knuckle bump
    const knuckle = new THREE.Mesh(new THREE.SphereGeometry(thickness * 0.6, 6, 6), mat);
    knuckle.scale.set(1, 0.8, 0.8);
    knuckle.castShadow = true;
    group.add(knuckle);
    return group;
}

// === RIGHT HAND (Grip Hand) ===
const rightHand = new THREE.Group();

// Wrist/Forearm
const rightWrist = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 1.2), skinMat);
rightWrist.position.set(0, 0, -0.6);
rightWrist.castShadow = true;
rightHand.add(rightWrist);

// Sleeve
const rightSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.4, 0.5), sleeveMat);
rightSleeve.position.set(0, 0, -1.1);
rightSleeve.castShadow = true;
rightHand.add(rightSleeve);

// Palm
const rightPalm = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.5, 0.6), skinMat);
rightPalm.position.set(0, 0, 0);
rightPalm.castShadow = true;
rightHand.add(rightPalm);

// Thumb (wrapped around grip)
const rightThumb = new THREE.Group();
const thumbBase = createFinger(0.25, 0.14, skinMat);
thumbBase.rotation.set(0, -0.4, Math.PI/2 + 0.3);
thumbBase.position.set(0.3, 0.05, 0.1);
rightThumb.add(thumbBase);
const thumbTip = createFinger(0.2, 0.12, skinMat);
thumbTip.rotation.x = 0.4;
thumbTip.position.set(0, 0, 0.22);
thumbBase.add(thumbTip);
// Thumbnail
const thumbNail = new THREE.Mesh(new THREE.BoxGeometry(0.08, 0.1, 0.06), nailMat);
thumbNail.position.set(0, 0.07, 0.18);
thumbTip.add(thumbNail);
rightHand.add(rightThumb);

// Fingers (wrapped around grip - curled)
const fingerOffsets = [
    { x: -0.18, z: 0.28, curl: 2.2 },  // Index
    { x: -0.06, z: 0.30, curl: 2.3 },  // Middle
    { x: 0.06, z: 0.28, curl: 2.2 },   // Ring
    { x: 0.17, z: 0.24, curl: 2.1 }    // Pinky
];
const fingerLengths = [0.28, 0.32, 0.30, 0.24];
const fingerThickness = [0.11, 0.12, 0.11, 0.09];

fingerOffsets.forEach((offset, i) => {
    const finger = new THREE.Group();

    // Base segment
    const base = createFinger(fingerLengths[i] * 0.4, fingerThickness[i], skinMat);
    base.rotation.x = offset.curl * 0.4;
    base.position.set(offset.x, -0.22, offset.z);
    finger.add(base);

    // Middle segment
    const mid = createFinger(fingerLengths[i] * 0.35, fingerThickness[i] * 0.9, skinMat);
    mid.rotation.x = offset.curl * 0.5;
    mid.position.set(0, 0, fingerLengths[i] * 0.38);
    base.add(mid);

    // Tip segment
    const tip = createFinger(fingerLengths[i] * 0.3, fingerThickness[i] * 0.8, skinMatDark);
    tip.rotation.x = offset.curl * 0.4;
    tip.position.set(0, 0, fingerLengths[i] * 0.32);
    mid.add(tip);

    // Fingernail
    const nail = new THREE.Mesh(new THREE.BoxGeometry(fingerThickness[i] * 0.6, fingerThickness[i] * 0.8, 0.04), nailMat);
    nail.position.set(0, fingerThickness[i] * 0.45, fingerLengths[i] * 0.28);
    tip.add(nail);

    rightHand.add(finger);
});

// Position right hand on grip
rightHand.position.set(0, -0.5 * 2.5 - 0.4, 0.7 * 2.5 + 0.1);
rightHand.rotation.set(-Math.PI/6 - 0.2, 0, 0);
rightHand.scale.setScalar(1.8);
// shotgunGroup.add(rightHand); // DISABLED - hands removed

// === LEFT HAND (Pump Hand) - Attached to pump pivot ===
const leftHand = new THREE.Group();

// Wrist/Forearm
const leftWrist = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.35, 1.4), skinMat);
leftWrist.position.set(0, 0, 0.7);
leftWrist.castShadow = true;
leftHand.add(leftWrist);

// Sleeve
const leftSleeve = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.4, 0.5), sleeveMat);
leftSleeve.position.set(0, 0, 1.35);
leftSleeve.castShadow = true;
leftHand.add(leftSleeve);

// Palm (horizontal, gripping pump from below)
const leftPalm = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.4, 0.55), skinMat);
leftPalm.position.set(0, 0, 0.05);
leftPalm.castShadow = true;
leftHand.add(leftPalm);

// Thumb (on top of pump)
const leftThumb = new THREE.Group();
const lThumbBase = createFinger(0.22, 0.13, skinMat);
lThumbBase.rotation.set(-0.3, 0.3, -Math.PI/2 - 0.2);
lThumbBase.position.set(-0.28, 0.22, -0.05);
leftThumb.add(lThumbBase);
const lThumbTip = createFinger(0.18, 0.11, skinMat);
lThumbTip.rotation.x = 0.3;
lThumbTip.position.set(0, 0, 0.2);
lThumbBase.add(lThumbTip);
// Thumbnail
const lThumbNail = new THREE.Mesh(new THREE.BoxGeometry(0.07, 0.09, 0.05), nailMat);
lThumbNail.position.set(0, 0.06, 0.16);
lThumbTip.add(lThumbNail);
leftHand.add(leftThumb);

// Fingers (wrapped around pump from below - curled up)
const lFingerOffsets = [
    { x: 0.18, z: -0.22, curl: 2.4 },  // Index
    { x: 0.06, z: -0.24, curl: 2.5 },  // Middle
    { x: -0.06, z: -0.22, curl: 2.4 }, // Ring
    { x: -0.17, z: -0.18, curl: 2.3 }  // Pinky
];

lFingerOffsets.forEach((offset, i) => {
    const finger = new THREE.Group();

    // Base segment (curling up around pump)
    const base = createFinger(fingerLengths[i] * 0.4, fingerThickness[i], skinMat);
    base.rotation.x = -offset.curl * 0.35;
    base.position.set(offset.x, -0.18, offset.z);
    finger.add(base);

    // Middle segment
    const mid = createFinger(fingerLengths[i] * 0.35, fingerThickness[i] * 0.9, skinMat);
    mid.rotation.x = -offset.curl * 0.45;
    mid.position.set(0, 0, fingerLengths[i] * 0.38);
    base.add(mid);

    // Tip segment
    const tip = createFinger(fingerLengths[i] * 0.3, fingerThickness[i] * 0.8, skinMatDark);
    tip.rotation.x = -offset.curl * 0.35;
    tip.position.set(0, 0, fingerLengths[i] * 0.32);
    mid.add(tip);

    // Fingernail
    const nail = new THREE.Mesh(new THREE.BoxGeometry(fingerThickness[i] * 0.6, fingerThickness[i] * 0.8, 0.04), nailMat);
    nail.position.set(0, fingerThickness[i] * 0.45, fingerLengths[i] * 0.28);
    tip.add(nail);

    leftHand.add(finger);
});

// Position left hand on pump - attached to sgPumpPivot so it moves with pump
leftHand.position.set(0, -0.35, 0);
leftHand.rotation.set(Math.PI/2 + 0.1, 0, Math.PI);
leftHand.scale.setScalar(1.7);
// sgPumpPivot.add(leftHand); // DISABLED - hands removed

// === CHARACTER BODY (No Head) ===
// Materials for body
const clothMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.85,
    metalness: 0.0
});
const clothMatDark = new THREE.MeshStandardMaterial({
    color: 0x0f0f0f,
    roughness: 0.9,
    metalness: 0.0
});
const vestMat = new THREE.MeshStandardMaterial({
    color: 0x2d2d2d,
    roughness: 0.7,
    metalness: 0.1
});
const beltMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.6,
    metalness: 0.2
});
const bootMat = new THREE.MeshStandardMaterial({
    color: 0x1a1410,
    roughness: 0.8,
    metalness: 0.1
});
const buckleMat = new THREE.MeshStandardMaterial({
    color: 0x888888,
    roughness: 0.3,
    metalness: 0.8
});

// === ARMS (attached to shotgun - move with weapon) ===
const armsGroup = new THREE.Group();

// Right arm (connects to right hand on grip)
const rightArmGroup = new THREE.Group();

// Right upper arm
const rightUpperArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.1), sleeveMat);
rightUpperArm.castShadow = true;
rightArmGroup.add(rightUpperArm);

// Right elbow
const rightElbow = new THREE.Mesh(new THREE.SphereGeometry(0.22, 8, 8), sleeveMat);
rightElbow.position.set(0, 0, 0.55);
rightElbow.castShadow = true;
rightArmGroup.add(rightElbow);

// Right forearm (connects to existing hand)
const rightForearm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 0.9), sleeveMat);
rightForearm.position.set(0, 0, 1.0);
rightForearm.castShadow = true;
rightArmGroup.add(rightForearm);

// Position right arm to connect to hand
rightArmGroup.position.set(0.4, -0.5 * 2.5 + 0.8, 0.7 * 2.5 + 2.2);
rightArmGroup.rotation.set(-0.6, 0.15, 0.1);
rightArmGroup.scale.setScalar(1.6);
// shotgunGroup.add(rightArmGroup); // DISABLED - arms removed

// Left arm (connects to left hand on pump)
const leftArmGroup = new THREE.Group();

// Left upper arm
const leftUpperArm = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 1.1), sleeveMat);
leftUpperArm.castShadow = true;
leftArmGroup.add(leftUpperArm);

// Left elbow
const leftElbow = new THREE.Mesh(new THREE.SphereGeometry(0.22, 8, 8), sleeveMat);
leftElbow.position.set(0, 0, 0.55);
leftElbow.castShadow = true;
leftArmGroup.add(leftElbow);

// Left forearm
const leftForearm = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.35, 1.0), sleeveMat);
leftForearm.position.set(0, 0, 1.05);
leftForearm.castShadow = true;
leftArmGroup.add(leftForearm);

// Position left arm to reach toward pump
leftArmGroup.position.set(-0.5, -0.1 * 2.5 + 1.2, -1.6 * 2.5 + 4.5);
leftArmGroup.rotation.set(-0.3, -0.3, -0.15);
leftArmGroup.scale.setScalar(1.6);
// shotgunGroup.add(leftArmGroup); // DISABLED - arms removed

// === TORSO & LEGS (attached to camera - stable body) ===
const bodyGroup = new THREE.Group();

// === UPPER TORSO / CHEST ===
const chest = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.9, 0.7), clothMat);
chest.position.set(0, -1.2, 0.1);
chest.castShadow = true;
bodyGroup.add(chest);

// Tactical vest
const vest = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.85, 0.75), vestMat);
vest.position.set(0, -1.2, 0.12);
vest.castShadow = true;
bodyGroup.add(vest);

// Vest pouches (front)
for (let i = 0; i < 3; i++) {
    const pouch = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.3, 0.15), vestMat);
    pouch.position.set(-0.35 + i * 0.35, -1.1, 0.45);
    pouch.castShadow = true;
    bodyGroup.add(pouch);

    // Pouch flap
    const flap = new THREE.Mesh(new THREE.BoxGeometry(0.24, 0.08, 0.16), clothMatDark);
    flap.position.set(-0.35 + i * 0.35, -0.97, 0.45);
    bodyGroup.add(flap);
}

// Shoulder straps
const leftStrap = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.9, 0.08), vestMat);
leftStrap.position.set(-0.45, -0.85, 0.35);
leftStrap.rotation.x = 0.2;
leftStrap.castShadow = true;
bodyGroup.add(leftStrap);

const rightStrap = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.9, 0.08), vestMat);
rightStrap.position.set(0.45, -0.85, 0.35);
rightStrap.rotation.x = 0.2;
rightStrap.castShadow = true;
bodyGroup.add(rightStrap);

// === STOMACH / WAIST ===
const stomach = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.6, 0.6), clothMat);
stomach.position.set(0, -1.9, 0.1);
stomach.castShadow = true;
bodyGroup.add(stomach);

// Belt
const belt = new THREE.Mesh(new THREE.BoxGeometry(1.3, 0.18, 0.65), beltMat);
belt.position.set(0, -2.15, 0.1);
belt.castShadow = true;
bodyGroup.add(belt);

// Belt buckle
const buckle = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.15, 0.08), buckleMat);
buckle.position.set(0, -2.15, 0.45);
bodyGroup.add(buckle);

// Belt pouches/holster
const holster = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.5, 0.2), beltMat);
holster.position.set(0.55, -2.3, 0.2);
holster.rotation.z = 0.1;
holster.castShadow = true;
bodyGroup.add(holster);

// === LEGS ===
// Right leg
const rightLegGroup = new THREE.Group();

// Right thigh
const rightThigh = new THREE.Mesh(new THREE.BoxGeometry(0.45, 1.0, 0.45), clothMat);
rightThigh.position.set(0, -0.5, 0);
rightThigh.castShadow = true;
rightLegGroup.add(rightThigh);

// Right knee
const rightKnee = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.5), clothMatDark);
rightKnee.position.set(0, -1.05, 0.02);
rightKnee.castShadow = true;
rightLegGroup.add(rightKnee);

// Knee pad
const rightKneePad = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.22, 0.12), vestMat);
rightKneePad.position.set(0, -1.05, 0.28);
rightLegGroup.add(rightKneePad);

// Right shin
const rightShin = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), clothMat);
rightShin.position.set(0, -1.6, 0);
rightShin.castShadow = true;
rightLegGroup.add(rightShin);

// Right boot
const rightBoot = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.45, 0.7), bootMat);
rightBoot.position.set(0, -2.25, 0.1);
rightBoot.castShadow = true;
rightLegGroup.add(rightBoot);

// Boot sole
const rightSole = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.1, 0.72), clothMatDark);
rightSole.position.set(0, -2.5, 0.1);
rightLegGroup.add(rightSole);

// Boot toe cap
const rightToeCap = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.25, 0.15), bootMat);
rightToeCap.position.set(0, -2.35, 0.45);
rightLegGroup.add(rightToeCap);

// Boot laces detail
for (let i = 0; i < 4; i++) {
    const lace = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.03, 0.03), clothMatDark);
    lace.position.set(0, -2.0 - i * 0.1, 0.35);
    rightLegGroup.add(lace);
}

rightLegGroup.position.set(0.35, -2.3, 0.15);
bodyGroup.add(rightLegGroup);

// Left leg (mirror of right)
const leftLegGroup = new THREE.Group();

// Left thigh
const leftThigh = new THREE.Mesh(new THREE.BoxGeometry(0.45, 1.0, 0.45), clothMat);
leftThigh.position.set(0, -0.5, 0);
leftThigh.castShadow = true;
leftLegGroup.add(leftThigh);

// Left knee
const leftKnee = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.25, 0.5), clothMatDark);
leftKnee.position.set(0, -1.05, 0.02);
leftKnee.castShadow = true;
leftLegGroup.add(leftKnee);

// Knee pad
const leftKneePad = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.22, 0.12), vestMat);
leftKneePad.position.set(0, -1.05, 0.28);
leftLegGroup.add(leftKneePad);

// Left shin
const leftShin = new THREE.Mesh(new THREE.BoxGeometry(0.4, 1.0, 0.4), clothMat);
leftShin.position.set(0, -1.6, 0);
leftShin.castShadow = true;
leftLegGroup.add(leftShin);

// Left boot
const leftBoot = new THREE.Mesh(new THREE.BoxGeometry(0.42, 0.45, 0.7), bootMat);
leftBoot.position.set(0, -2.25, 0.1);
leftBoot.castShadow = true;
leftLegGroup.add(leftBoot);

// Boot sole
const leftSole = new THREE.Mesh(new THREE.BoxGeometry(0.44, 0.1, 0.72), clothMatDark);
leftSole.position.set(0, -2.5, 0.1);
leftLegGroup.add(leftSole);

// Boot toe cap
const leftToeCap = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.25, 0.15), bootMat);
leftToeCap.position.set(0, -2.35, 0.45);
leftLegGroup.add(leftToeCap);

// Boot laces detail
for (let i = 0; i < 4; i++) {
    const lace = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.03, 0.03), clothMatDark);
    lace.position.set(0, -2.0 - i * 0.1, 0.35);
    leftLegGroup.add(lace);
}

leftLegGroup.position.set(-0.35, -2.3, 0.15);
bodyGroup.add(leftLegGroup);

// === NECK STUMP (no head, but need collar) ===
const collar = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.4), clothMat);
collar.position.set(0, -0.68, 0.1);
collar.castShadow = true;
bodyGroup.add(collar);

// Neck base (skin showing)
const neckBase = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.22, 0.15, 8), skinMat);
neckBase.position.set(0, -0.55, 0.1);
neckBase.castShadow = true;
bodyGroup.add(neckBase);

// Position body - visible when looking down
bodyGroup.position.set(0, 0.3, 0.3);
bodyGroup.scale.setScalar(1.0);

// Store reference for later (attached to camera after camera exists)
window.playerBodyGroup = bodyGroup;

// === MUZZLE FLASH GROUP ===
const shotgunFlashGroup = new THREE.Group();
const shotgunFlashCore = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 1.2), flashCoreMat);
shotgunFlashGroup.add(shotgunFlashCore);
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.0, 2.0), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    shotgunFlashGroup.add(f);
}
for(let i=0; i<8; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(3.0, 3.0), flashOuterMat);
    f.rotation.z = (Math.PI / 4) * i;
    shotgunFlashGroup.add(f);
}
// Extra wide spread flash for shotgun
for(let i=0; i<6; i++) {
    const streak = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 2.5), flashStreakMat);
    streak.rotation.z = (Math.PI / 3) * i;
    streak.position.z = -0.3;
    shotgunFlashGroup.add(streak);
}
shotgunFlashGroup.position.set(0, 0.15 * 2.5, -4.4 * 2.5);
shotgunGroup.add(shotgunFlashGroup);

// Scale shotgun
shotgunGroup.scale.setScalar(0.65); // Scaled down from 0.95

// Position shotgun (hidden by default)
shotgunRecoilGroup.rotation.y = Math.PI;
shotgunRecoilGroup.visible = false;
camera.add(shotgunRecoilGroup);

// Add player body to camera (visible when looking down with shotgun)
// DISABLED - body removed
// if (window.playerBodyGroup) {
//     window.playerBodyGroup.visible = false;
//     camera.add(window.playerBodyGroup);
// }

// === KICK SYSTEM ===
let isKicking = false;
let kickCooldown = 0;
const KICK_COOLDOWN = 0.6; // seconds between kicks
const KICK_DAMAGE = 2; // Takes 2 hits to kill most zombies
const KICK_RANGE = 4.5;
const KICK_KNOCKBACK = 15;
const KICK_ANGLE = Math.PI / 3; // 60 degree cone in front

// Kick leg mesh
const kickLegGroup = new THREE.Group();
const kickLegPivot = new THREE.Group(); // Pivot at hip for rotation

// Thigh
const kickThigh = new THREE.Mesh(
    new THREE.BoxGeometry(0.35, 0.9, 0.35),
    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.85 })
);
kickThigh.position.set(0, -0.45, 0);
kickThigh.castShadow = true;
kickLegPivot.add(kickThigh);

// Knee
const kickKnee = new THREE.Mesh(
    new THREE.SphereGeometry(0.2, 8, 8),
    new THREE.MeshStandardMaterial({ color: 0x0f0f0f, roughness: 0.9 })
);
kickKnee.position.set(0, -0.9, 0);
kickKnee.castShadow = true;
kickLegPivot.add(kickKnee);

// Shin
const kickShin = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 0.85, 0.3),
    new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.85 })
);
kickShin.position.set(0, -1.35, 0);
kickShin.castShadow = true;
kickLegPivot.add(kickShin);

// Boot
const kickBoot = new THREE.Mesh(
    new THREE.BoxGeometry(0.35, 0.35, 0.6),
    new THREE.MeshStandardMaterial({ color: 0x1a1410, roughness: 0.8 })
);
kickBoot.position.set(0, -1.85, 0.1);
kickBoot.castShadow = true;
kickLegPivot.add(kickBoot);

// Boot toe (for that satisfying kick contact)
const kickToe = new THREE.Mesh(
    new THREE.BoxGeometry(0.32, 0.25, 0.2),
    new THREE.MeshStandardMaterial({ color: 0x1a1410, roughness: 0.8 })
);
kickToe.position.set(0, -1.9, 0.35);
kickToe.castShadow = true;
kickLegPivot.add(kickToe);

// Position pivot at hip level
kickLegPivot.position.set(0.25, -0.8, -0.3);
kickLegGroup.add(kickLegPivot);

// Start with leg down/hidden
kickLegPivot.rotation.x = 0.3; // Slightly back
kickLegGroup.visible = false;
camera.add(kickLegGroup);

// Kick spring for smooth animation
const kickSpring = new Spring(500, 25, 1);

function kick() {
    if (isKicking || kickCooldown > 0) return;
    if (typeof isPaused !== 'undefined' && isPaused) return;
    if (typeof isGameOver !== 'undefined' && isGameOver) return;

    isKicking = true;
    kickLegGroup.visible = true;

    // Play kick sound
    playKickSound();

    // Animate leg up with spring
    kickSpring.position = 0;
    kickSpring.velocity = 0;
    kickSpring.impulse(25);

    // Check for zombie hits at peak of kick
    setTimeout(() => {
        performKickHit();
    }, 100);

    // Animate kick with tweens
    // Phase 1: Kick UP (fast, aggressive)
    new TWEEN.Tween(kickLegPivot.rotation)
        .to({ x: -1.8 }, 120) // Kick up high (negative = forward/up)
        .easing(TWEEN.Easing.Back.Out)
        .onComplete(() => {
            // Phase 2: Hold briefly at peak
            new TWEEN.Tween(kickLegPivot.rotation)
                .to({ x: -1.6 }, 80)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // Phase 3: Return down
                    new TWEEN.Tween(kickLegPivot.rotation)
                        .to({ x: 0.3 }, 200)
                        .easing(TWEEN.Easing.Quadratic.In)
                        .onComplete(() => {
                            kickLegGroup.visible = false;
                            isKicking = false;
                            kickCooldown = KICK_COOLDOWN;
                        })
                        .start();
                })
                .start();
        })
        .start();

    // Screen shake on kick
    Springs.recoilX.impulse((Math.random() - 0.5) * 2);
    Springs.recoilY.impulse(-3);
}

// === SLIDE FUNCTION ===
function startSlide() {
    isSliding = true;
    slideTimer = slideDuration;

    // Capture current ACTUAL movement direction (velocity-based, not just camera)
    // This preserves momentum from sprinting
    const fwd = new THREE.Vector3();
    camera.getWorldDirection(fwd);
    fwd.y = 0;
    fwd.normalize();

    const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0, 1, 0)).normalize();

    // Calculate world velocity direction from current velocity
    const worldVelX = rgt.x * velocity.x + fwd.x * velocity.z;
    const worldVelZ = rgt.z * velocity.x + fwd.z * velocity.z;
    const currentVelMag = Math.sqrt(worldVelX * worldVelX + worldVelZ * worldVelZ);

    // If we have velocity, use that direction; otherwise use camera forward
    if (currentVelMag > 1) {
        slideDirection.set(worldVelX / currentVelMag, 0, worldVelZ / currentVelMag);
    } else {
        slideDirection.copy(fwd);
    }

    // Calculate initial slide speed based on current velocity + boost
    const sprintSpeed = baseSpeed * sprintMultiplier * (speedBoostTimer > 0 ? speedBoostMultiplier : 1);
    // Carry forward current momentum and add boost
    slideSpeed = Math.max(currentVelMag, sprintSpeed) * slideSpeedBoost;

    // Play slide sound (using existing sound system)
    playSlideSound();

    // Initial spring impulses for juicy feedback
    Springs.slideY.impulse(slideCameraDropMax * 2);           // Quick camera drop
    Springs.slideTilt.impulse(0.35);                          // Forward lean
    Springs.slideRoll.impulse((Math.random() - 0.5) * 0.15);  // Slight random roll
    Springs.slideFOV.impulse(8);                              // FOV punch

    // Weapon drops and tilts forward during slide
    Springs.bobY.impulse(-2.5);
    Springs.tilt.impulse(0.2);
    Springs.momentumZ.impulse(4);

    // Screen shake for slide initiation
    Springs.shakeY.impulse(-1.5);
    Springs.shakeX.impulse((Math.random() - 0.5) * 0.8);
}

function playSlideSound() {
    if (!actx) return;

    // Create a sliding/scraping sound
    const now = actx.currentTime;

    // Whoosh sound
    const noise = actx.createBufferSource();
    const bufferSize = actx.sampleRate * 0.3;
    const buffer = actx.createBuffer(1, bufferSize, actx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize) * 0.3;
    }
    noise.buffer = buffer;

    // Bandpass filter for swoosh character
    const filter = actx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.setValueAtTime(800, now);
    filter.frequency.linearRampToValueAtTime(300, now + 0.3);
    filter.Q.value = 1.5;

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0.4 * masterVolume * sfxVolume, now);
    gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(actx.destination);
    noise.start(now);
}

function performKickHit() {
    const playerPos = camera.position.clone();
    const playerDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
    playerDir.y = 0;
    playerDir.normalize();

    let hitCount = 0;

    for (const zombie of zombies) {
        if (zombie.isDead) continue;

        const zombiePos = zombie.mesh.position.clone();
        const toZombie = zombiePos.sub(playerPos);
        toZombie.y = 0;
        const dist = toZombie.length();

        if (dist > KICK_RANGE) continue;

        // Check if zombie is in front (within kick cone)
        toZombie.normalize();
        const dot = playerDir.dot(toZombie);

        if (dot > Math.cos(KICK_ANGLE)) {
            // HIT! Apply damage and knockback
            hitCount++;

            // Damage
            zombie.health -= KICK_DAMAGE;

            // Big knockback (kick them in the nuts!)
            const knockDir = toZombie.clone();
            knockDir.y = 0.3; // Slight upward
            knockDir.normalize();

            // Apply knockback velocity (clone so knockDir stays normalized for gore)
            zombie.knockbackVel = knockDir.clone().multiplyScalar(KICK_KNOCKBACK);
            zombie.isKnockedBack = true;
            zombie.knockbackTime = 0.4;

            // Stagger animation
            zombie.mesh.rotation.x = -0.4;

            // Hit feedback
            if (typeof showHitmarker === 'function') showHitmarker(false);

            // Check for kill - use proper die() for ragdoll physics
            if (zombie.health <= 0 && !zombie.isDead) {
                zombie.die();
            }
        }
    }

    // Extra feedback if we hit something
    if (hitCount > 0) {
        Springs.recoilZ.impulse(-2);
        // Meaty impact sound
        playKickImpactSound();
    }
}

function playKickSound() {
    if (!actx) return;
    if (actx.state === 'suspended') actx.resume();
    const now = actx.currentTime;

    // Whoosh sound
    const noise = actx.createBufferSource();
    const noiseBuffer = actx.createBuffer(1, 4410, actx.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * (1 - i / noiseData.length);
    }
    noise.buffer = noiseBuffer;

    const whooshFilter = actx.createBiquadFilter();
    whooshFilter.type = 'bandpass';
    whooshFilter.frequency.setValueAtTime(800, now);
    whooshFilter.frequency.exponentialRampToValueAtTime(2000, now + 0.1);
    whooshFilter.Q.value = 1;

    const whooshGain = actx.createGain();
    whooshGain.gain.setValueAtTime(0.3, now);
    whooshGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    noise.connect(whooshFilter);
    whooshFilter.connect(whooshGain);
    whooshGain.connect(dryGain);

    noise.start(now);
    noise.stop(now + 0.15);
}

function playKickImpactSound() {
    if (!actx) return;
    if (actx.state === 'suspended') actx.resume();
    const now = actx.currentTime;

    // Meaty thud
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(80, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);

    const thudGain = actx.createGain();
    thudGain.gain.setValueAtTime(0.5, now);
    thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);

    // Noise burst for impact texture
    const noise = actx.createBufferSource();
    const noiseBuffer = actx.createBuffer(1, 2205, actx.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
    }
    noise.buffer = noiseBuffer;

    const noiseGain = actx.createGain();
    noiseGain.gain.setValueAtTime(0.3, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);

    osc.connect(thudGain);
    thudGain.connect(dryGain);
    noise.connect(noiseGain);
    noiseGain.connect(dryGain);

    osc.start(now);
    osc.stop(now + 0.15);
    noise.start(now);
    noise.stop(now + 0.1);
}

// Sniper springs for bolt action
const SniperSprings = {
    // Bolt action springs
    boltRotate: new Spring(300, 18, 1),   // Bolt handle rotation (lift)
    boltPull: new Spring(350, 20, 1),     // Bolt pull back
    boltPush: new Spring(400, 22, 1),     // Bolt push forward
    boltDown: new Spring(350, 20, 1),     // Bolt rotate down

    // === BRUTAL SNIPER RECOIL - Fast snap, slow recovery ===
    // High stiffness for INSTANT jolt, high mass for slow return
    heavyRecoilZ: new Spring(400, 25, 1.0),    // SNAP back instantly, settle slowly
    heavyRecoilX: new Spring(350, 22, 1.0),    // Fast muzzle snap up
    heavyRecoilY: new Spring(300, 20, 1.0),     // Quick vertical jump
    heavyRecoilRoll: new Spring(320, 22, 1.0), // Violent rotational snap

    // Stock compression - INSTANT slam into shoulder
    stockCompress: new Spring(450, 28, 0.8),   // Fast compression, slow decompress
    stockRotate: new Spring(380, 24, 0.9),     // Quick barrel tip

    // Scope-specific shake (VIOLENT initial jitter)
    scopeShakeX: new Spring(500, 30, 0.8),     // Very fast scope snap
    scopeShakeY: new Spring(500, 30, 0.8),
    scopeSettleX: new Spring(80, 12, 1.2),      // Very slow scope settle
    scopeSettleY: new Spring(80, 12, 1.2),

    // Heavy weapon sway - more inertia when moving
    heavySwayX: new Spring(60, 10, 1.5),        // Sluggish sway
    heavySwayY: new Spring(60, 10, 1.5),
    heavyMomentumX: new Spring(50, 8, 1.8),    // Weapon trails behind significantly
    heavyMomentumZ: new Spring(50, 8, 1.8),

    // Barrel droop - forward dip after recoil settles
    barrelDroop: new Spring(80, 12, 1.5),       // Slow barrel settle after kick

    // Breathing amplification when scoped
    scopedBreath: new Spring(25, 5, 2.0),    // Exaggerated breathing sway

    // Recovery springs - SLOW crawl back to neutral
    recoveryZ: new Spring(60, 12, 1.5),
    recoveryX: new Spring(55, 11, 1.5),
};

// Shotgun springs - PUNCHY and AGGRESSIVE with satisfying pump action
const ShotgunSprings = {
    // === SHOTGUN RECOIL - Punchy but controlled ===
    // Strong kick with fast recovery, won't accumulate off-screen

    // Primary recoil - punchy with high damping to prevent runaway
    // Increased mass (0.6 -> 1.5) for stability, adjusted stiffness for same punch feel
    recoilZ: new Spring(400, 45, 1.5),     // Heavy slam back
    recoilX: new Spring(380, 42, 1.6),     // Muzzle climb
    recoilY: new Spring(350, 40, 1.6),     // Vertical jump

    // Rotational kick - controlled twist
    recoilRoll: new Spring(350, 40, 1.5),  
    recoilTilt: new Spring(320, 38, 1.5), 

    // Stock impact - satisfying but controlled
    stockKick: new Spring(450, 50, 1.2),   
    stockRotate: new Spring(400, 45, 1.2),

    // Pump action springs - crisp mechanical feel
    pumpPull: new Spring(400, 30, 1.2),    
    pumpPush: new Spring(450, 32, 1.0),    
    pumpRotate: new Spring(300, 22, 1.4),  

    // Weapon sway - heavier than AK, lighter than sniper
    swayX: new Spring(55, 12, 1.2),
    swayY: new Spring(55, 12, 1.2),
    momentumX: new Spring(45, 14, 1.3),
    momentumZ: new Spring(45, 14, 1.3),

    // Shell ejection physics
    shellEject: new Spring(400, 25, 1.0), 

    // Recovery - FAST return to ready
    recoveryZ: new Spring(120, 24, 1.5),
    recoveryX: new Spring(110, 22, 1.5),

    // Barrel droop after shot
    barrelDroop: new Spring(80, 16, 1.5),

    // Fore-end (pump grip) independent motion
    foreEndZ: new Spring(300, 24, 1.2),
    foreEndRotate: new Spring(240, 18, 1.4),
};

// Camera Rig
const hipPos = new THREE.Vector3(0.9, -1.1, -1.8);
const aimPos = new THREE.Vector3(0.0, -1.22, -0.5);
const sniperHipPos = new THREE.Vector3(0.5, -0.8, -1.1);
const sniperAimPos = new THREE.Vector3(0.0, -0.62, -0.35); // Higher for scope alignment
const shotgunHipPos = new THREE.Vector3(0.75, -0.95, -2.8); // Zoomed out, down+right
const shotgunAimPos = new THREE.Vector3(0.0, -0.65, -1.4); // Iron sights aim position (adjusted for new scale)

// Position AK-47
recoilGroup.position.copy(hipPos);
recoilGroup.rotation.y = Math.PI;
camera.add(recoilGroup);

// Position Sniper (starts hidden)
sniperRecoilGroup.position.copy(sniperHipPos);
// sniperRecoilGroup already has rotation.y = Math.PI set during construction
// and is already added to camera and set visible = false

scene.add(camera);

/**
 * ENHANCED PARTICLE SYSTEMS
 */

// Improved Smoke with object pooling
const smokeParticles = [];
const smokeTexCanvas = document.createElement('canvas'); smokeTexCanvas.width = 64; smokeTexCanvas.height = 64; // Reduced size
const stx = smokeTexCanvas.getContext('2d');
const sGrad = stx.createRadialGradient(32,32,0,32,32,32);
sGrad.addColorStop(0, 'rgba(200,200,200,0.6)');
sGrad.addColorStop(0.4, 'rgba(150,150,150,0.3)');
sGrad.addColorStop(1, 'rgba(100,100,100,0)');
stx.fillStyle = sGrad; stx.fillRect(0,0,64,64);
const smokeSpriteTex = new THREE.CanvasTexture(smokeTexCanvas);

// Pre-create smoke sprite materials (no cloning needed)
const smokeMats = [];
const hotSmokeMats = [];
for (let i = 0; i < 20; i++) {
    smokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0x888888, transparent: true,
        blending: THREE.NormalBlending, depthWrite: false
    }));
    hotSmokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0xffaa66, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
    }));
}
let smokeMatIdx = 0;
let hotSmokeMatIdx = 0;

// Object pool for smoke sprites
const smokePool = new ObjectPool(
    () => new THREE.Sprite(smokeMats[0]),
    (s) => { s.visible = false; s.scale.setScalar(0.4); }
);

// Reusable vectors for smoke spawning
const _smokeSpawnPos = new THREE.Vector3(0, 0.3, -7.5);
const _smokeVel = new THREE.Vector3();
const _smokeQuat = new THREE.Quaternion();

function spawnSmoke() {
    const basePos = _smokeSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    gunGroup.getWorldQuaternion(_smokeQuat);

    // Hot smoke near muzzle (reduced count)
    for(let i=0; i<1; i++) {
        const s = smokePool.get();
        s.material = hotSmokeMats[hotSmokeMatIdx++ % hotSmokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.3 + Math.random() * 0.3);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.5; _smokeVel.y += Math.random()*0.3; _smokeVel.z += (Math.random()-0.5)*0.5;
        _smokeVel.multiplyScalar(3 + Math.random()*2);
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 0.4 + Math.random()*0.3, hot: true });
    }
    // Regular smoke (reduced count)
    for(let i=0; i<2; i++) {
        const s = smokePool.get();
        s.material = smokeMats[smokeMatIdx++ % smokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.4 + Math.random() * 0.4);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.4; _smokeVel.y += Math.random()*0.6; _smokeVel.z += (Math.random()-0.5)*0.4;
        _smokeVel.multiplyScalar(1.5 + Math.random());
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 1.0 + Math.random()*0.5, hot: false });
    }
}

// === NEW: Muzzle Smoke Wisps - lingering smoke after firing ===
const muzzleSmokeWisps = [];
const wispMats = [];
for (let i = 0; i < 10; i++) {
    wispMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex,
        color: 0x888899,
        transparent: true,
        blending: THREE.NormalBlending,
        opacity: 0.3,
        depthWrite: false
    }));
}
let wispMatIdx = 0;

function spawnMuzzleSmokeWisps() {
    // Only spawn wisps occasionally for subtle effect
    if (Math.random() > 0.4) return;

    const basePos = _smokeSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    gunGroup.getWorldQuaternion(_smokeQuat);

    // Spawn 1-2 slow-moving wisps that rise gently
    const wispCount = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < wispCount; i++) {
        const s = new THREE.Sprite(wispMats[wispMatIdx++ % wispMats.length].clone());
        s.position.copy(basePos);
        s.position.x += (Math.random() - 0.5) * 0.2;
        s.position.y += (Math.random() - 0.5) * 0.1;
        s.scale.setScalar(0.15 + Math.random() * 0.1);
        scene.add(s);

        // Very slow upward drift with slight random motion
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 0.2,
            0.3 + Math.random() * 0.2,
            (Math.random() - 0.5) * 0.2
        );

        muzzleSmokeWisps.push({
            mesh: s,
            velocity: vel,
            age: 0,
            life: 2.0 + Math.random() * 1.5, // Long-lasting
            initialScale: s.scale.x
        });
    }
}

// Update smoke wisps (called in main loop)
function updateMuzzleSmokeWisps(dt) {
    for (let i = muzzleSmokeWisps.length - 1; i >= 0; i--) {
        const w = muzzleSmokeWisps[i];
        w.age += dt;

        if (w.age >= w.life) {
            scene.remove(w.mesh);
            w.mesh.material.dispose();
            muzzleSmokeWisps.splice(i, 1);
            continue;
        }

        // Move upward slowly
        w.mesh.position.add(w.velocity.clone().multiplyScalar(dt));

        // Add slight turbulence
        w.mesh.position.x += Math.sin(w.age * 3 + i) * 0.01 * dt;
        w.mesh.position.z += Math.cos(w.age * 2.5 + i * 2) * 0.01 * dt;

        // Grow and fade
        const lifeRatio = w.age / w.life;
        const growthFactor = 1 + lifeRatio * 3; // Grow to 4x size
        w.mesh.scale.setScalar(w.initialScale * growthFactor);

        // Fade out smoothly
        const fadeStart = 0.3;
        if (lifeRatio > fadeStart) {
            const fadeRatio = (lifeRatio - fadeStart) / (1 - fadeStart);
            w.mesh.material.opacity = 0.3 * (1 - fadeRatio);
        }

        // Slow down over time
        w.velocity.multiplyScalar(0.995);
    }
}

// SPARK PARTICLES - pooled for performance
const sparks = [];
const sparkGeo = new THREE.SphereGeometry(0.02, 3, 3); // Reduced geometry complexity
const sparkBaseMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending });

// Pre-create spark materials
const sparkMats = [];
for (let i = 0; i < 30; i++) {
    sparkMats.push(new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending }));
}
let sparkMatIdx = 0;

// Object pool for sparks
const sparkPool = new ObjectPool(
    () => { const m = new THREE.Mesh(sparkGeo, sparkMats[0]); m.visible = false; return m; },
    (s) => { s.visible = false; },
    MAX_SPARKS
);

const _sparkSpawnPos = new THREE.Vector3(0, 0.3, -7.5);

function spawnMuzzleSparks() {
    const basePos = _sparkSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    for(let i=0; i<5; i++) { // Reduced from 8
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(basePos);
        spark.visible = true;
        _tempVec3.set((Math.random()-0.5) * 8, Math.random() * 4, -Math.random() * 15);
        _tempVec3.applyQuaternion(camera.quaternion);
        spark.userData = { velocity: _tempVec3.clone(), life: 0.15 + Math.random()*0.2 };
        scene.add(spark);
        sparks.push(spark);
    }
}

function spawnImpactSparks(point, normal) {
    for(let i=0; i<3; i++) { // Further reduced for performance
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(point);
        spark.visible = true;
        _tempVec3.copy(normal).multiplyScalar(5 + Math.random()*10);
        _tempVec3.x += (Math.random()-0.5) * 8;
        _tempVec3.y += Math.random() * 5;
        _tempVec3.z += (Math.random()-0.5) * 8;
        spark.userData = { velocity: _tempVec3.clone(), life: 0.2 + Math.random()*0.3 };
        scene.add(spark);
        sparks.push(spark);
    }
}

// DEBRIS PARTICLES - pooled
const debris = [];
const debrisGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
const debrisMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });

const debrisPool = new ObjectPool(
    () => { const d = new THREE.Mesh(debrisGeo, debrisMat); d.visible = false; return d; },
    (d) => { d.visible = false; },
    MAX_DEBRIS
);

function spawnDebris(point, normal) {
    for(let i=0; i<1; i++) { // Further reduced for performance
        const d = debrisPool.get();
        d.position.copy(point);
        d.visible = true;
        _tempVec3.copy(normal).multiplyScalar(2 + Math.random()*4);
        _tempVec3.x += (Math.random()-0.5) * 4;
        _tempVec3.y += Math.random() * 3;
        _tempVec3.z += (Math.random()-0.5) * 4;
        d.userData = {
            velocity: _tempVec3.clone(),
            rotVel: new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10),
            life: 1.0 + Math.random() * 1.0 // Fixed: 1-2 seconds instead of 60-120 frames
        };
        scene.add(d);
        debris.push(d);
    }
}

const shells = [];
const mags = [];
const tracers = [];
const decals = [];
const decalTex = TextureFactory.impact();
const decalMat = new THREE.MeshBasicMaterial({ map: decalTex, transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
const shellGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
const shellMat = new THREE.MeshStandardMaterial({
    color: 0xd4af37,
    metalness: 1.0,
    roughness: 0.15,
    envMap: envMapTex,
    envMapIntensity: 0.8
});

const raycaster = new THREE.Raycaster();

function ejectShell() {
    const shell = new THREE.Mesh(shellGeo, shellMat);
    shell.position.copy(new THREE.Vector3(0.5, 0.4, 0).applyMatrix4(gunGroup.matrixWorld));
    shell.quaternion.copy(gunGroup.quaternion); shell.rotation.z = Math.PI/2;
    const velocity = new THREE.Vector3(0.1 + Math.random()*0.1, 0.2 + Math.random()*0.1, 0).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 2.5 }; // Fixed: 2.5 seconds instead of 150 frames
    scene.add(shell); shells.push(shell);
}

function spawnTracer(start, end) {
    // Main tracer line
    const points = [start, end];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({
        color: 0xffff88,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    tracers.push({ mesh: line, life: 0.1 }); // Fixed: 0.1 seconds instead of 4 frames

    // Glow tracer (wider, softer)
    const glowMat = new THREE.LineBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
    });
    const glowLine = new THREE.Line(geo.clone(), glowMat);
    scene.add(glowLine);
    tracers.push({ mesh: glowLine, life: 0.08 }); // Fixed: 0.08 seconds instead of 3 frames
}

function spawnDecal(point, normal) {
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), decalMat);
    decal.position.copy(point);
    decal.position.addScaledVector(normal, 0.01);
    decal.lookAt(point.clone().add(normal));
    decal.rotation.z = Math.random() * Math.PI * 2;
    scene.add(decal);
    decals.push({ mesh: decal, life: 10.0 }); // Fixed: 10 seconds instead of 600 frames

    // Spawn impact effects
    spawnImpactSparks(point, normal);
    spawnDebris(point, normal);
}

/**
 * LOGIC & STATE
 */
let ammo = 30;
let reserve = 90;
let isReloading = false;
let isFiring = false;
let isAiming = false;
let lastIsAiming = false;
let lastShotTime = 0;
const fireRate = 0.1;

// === WEAPON SYSTEM ===
let currentWeapon = 'ak'; // 'ak', 'sniper', or 'shotgun'
let isSwitchingWeapon = false;

// Sniper-specific state
let sniperAmmo = 5;
let sniperReserve = 20;
const sniperMagSize = 5;
const sniperFireRate = 0.4; // Semi-auto .50 cal fire rate
const sniperDamageMultiplier = 3.0; // More damage per shot

// Shotgun-specific state
let shotgunAmmo = 8;
let shotgunReserve = 32;
const shotgunMagSize = 8;
const shotgunFireRate = 0.85; // Pump action - slower but devastating
const shotgunDamageMultiplier = 1.2; // Per pellet damage
const shotgunPelletCount = 8; // Pellets per shot
const shotgunSpread = 0.08; // Spread angle (radians)

// Pump action state
let needsPump = false;      // True after firing, must pump to chamber next round
let isPumping = false;      // Currently in pump animation
let pumpPhase = 0;          // Animation phase: 0=idle, 1=pull, 2=push

// Bolt action state
let needsBoltCycle = false;  // True after firing, must cycle bolt
let isCyclingBolt = false;   // Currently in bolt animation
let boltCyclePhase = 0;      // Animation phase: 0=idle, 1=lift, 2=pull, 3=push, 4=down

// Scope state
let scopeZoomLevel = 4; // 4x zoom when scoped

// PLAYER HEALTH & GAME STATE
let playerHealth = 100;
let maxPlayerHealth = 100;
let score = 0;
let isGameOver = false;
let isPaused = false;

// PAUSE SYSTEM
function pauseGame() {
    if (isGameOver || isPaused) return;
    isPaused = true;

    // Show pause menu
    const pauseOverlay = document.getElementById('pause-overlay');
    if (pauseOverlay) pauseOverlay.classList.add('active');

    // Release pointer lock
    document.exitPointerLock();

    // Pause music
    const bgMusic = document.getElementById('bg-music');
    if (bgMusic) bgMusic.pause();
}

function resumeGame() {
    if (!isPaused) return;
    isPaused = false;

    // Hide pause menu
    const pauseOverlay = document.getElementById('pause-overlay');
    if (pauseOverlay) pauseOverlay.classList.remove('active');

    // Request pointer lock again
    document.body.requestPointerLock();

    // Resume music
    const bgMusic = document.getElementById('bg-music');
    if (bgMusic) bgMusic.play();
}

function togglePause() {
    if (isPaused) {
        resumeGame();
    } else {
        pauseGame();
    }
}

// KILL MULTIPLIER SYSTEM
let killMultiplier = 1;
let killMultiplierMax = 10;
let killMultiplierDecayTime = 3.0; // Seconds before multiplier decays
let killMultiplierTimer = 0;
let lastMultiplierLevel = 1;
let lastDamageTime = 0;
let damageFlashIntensity = 0;

// HEALTH REGENERATION SYSTEM
const HEALTH_REGEN_DELAY = 5.0;    // Seconds without damage before regen starts
const HEALTH_REGEN_RATE = 15;       // Health per second when regenerating
let isRegenerating = false;
let displayedScore = 0;             // For smooth score counting animation
let scoreAnimationTarget = 0;

function damagePlayer(amount, attackerPos = null) {
    if (isGameOver) return;
    if (isSliding) return; // Immune while sliding

    // Apply shield damage reduction
    const actualDamage = shieldTimer > 0 ? amount * shieldDamageReduction : amount;
    playerHealth -= actualDamage;
    lastDamageTime = performance.now();

    // Shield shows blue flash, no shield shows red
    if (shieldTimer > 0) {
        damageFlashIntensity = 0.3;
        document.getElementById('damage-flash').style.background =
            'radial-gradient(ellipse at center, rgba(68,136,255,0.3) 0%, rgba(68,136,255,0.5) 100%)';
        setTimeout(() => {
            document.getElementById('damage-flash').style.background =
                'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
        }, 150);
    } else {
        damageFlashIntensity = 0.5;
    }
    playSound('playerHurt');

    // Screen shake
    Springs.shakeX.impulse((Math.random() - 0.5) * 20);
    Springs.shakeY.impulse((Math.random() - 0.5) * 20);

    // === NEW: Damage Direction Indicator ===
    if (attackerPos) {
        // Calculate direction from player to attacker in camera space
        const toAttacker = new THREE.Vector3();
        toAttacker.subVectors(attackerPos, camera.position);
        toAttacker.y = 0; // Ignore vertical

        // Get camera forward direction (horizontal)
        const camForward = new THREE.Vector3(0, 0, -1);
        camForward.applyQuaternion(camera.quaternion);
        camForward.y = 0;
        camForward.normalize();

        // Get camera right direction
        const camRight = new THREE.Vector3(1, 0, 0);
        camRight.applyQuaternion(camera.quaternion);
        camRight.y = 0;
        camRight.normalize();

        // Dot products to determine relative position
        const forward = toAttacker.dot(camForward);
        const right = toAttacker.dot(camRight);

        // Determine which arrow to show based on angle
        const angle = Math.atan2(right, forward);
        const deg = (angle * 180 / Math.PI + 360) % 360;

        // Map angle to direction (0 = front, 90 = right, 180 = back, 270 = left)
        if (deg >= 337.5 || deg < 22.5) lastDamageDir = 'top';         // Front
        else if (deg >= 22.5 && deg < 67.5) lastDamageDir = 'top-right';
        else if (deg >= 67.5 && deg < 112.5) lastDamageDir = 'right';
        else if (deg >= 112.5 && deg < 157.5) lastDamageDir = 'bottom-right';
        else if (deg >= 157.5 && deg < 202.5) lastDamageDir = 'bottom'; // Back
        else if (deg >= 202.5 && deg < 247.5) lastDamageDir = 'bottom-left';
        else if (deg >= 247.5 && deg < 292.5) lastDamageDir = 'left';
        else lastDamageDir = 'top-left';

        damageIndicatorAlpha = 1.0; // Start fade
    }

    if (playerHealth <= 0) {
        playerHealth = 0;
        gameOver();
    }
    updateHUD();
}

function addScore(points) {
    score += points;
    scoreAnimationTarget = score;
    updateHUD();

    // Enhanced score animation based on points
    const scoreEl = document.getElementById('score-display');
    if (scoreEl) {
        scoreEl.classList.remove('score-bump', 'score-mega-bump');
        void scoreEl.offsetWidth; // Force reflow to restart animation

        if (points >= 500) {
            scoreEl.classList.add('score-mega-bump');
        } else {
            scoreEl.classList.add('score-bump');
        }
    }
}

// Animate score counting effect
function updateScoreDisplay() {
    const scoreEl = document.getElementById('score-display');
    if (!scoreEl) return;

    if (displayedScore < score) {
        // Calculate increment - faster for bigger differences
        const diff = score - displayedScore;
        const increment = Math.max(1, Math.ceil(diff * 0.15));
        displayedScore = Math.min(displayedScore + increment, score);

        scoreEl.textContent = displayedScore.toString().padStart(8, '0');

        // Add counting class for subtle flicker
        if (!scoreEl.classList.contains('counting')) {
            scoreEl.classList.add('counting');
        }
    } else {
        displayedScore = score;
        scoreEl.classList.remove('counting');
        scoreEl.textContent = score.toString().padStart(8, '0');
    }
}

// Show floating score bonus for big kills
function showScoreBonusFloat(points, multiplier) {
    const bonus = document.createElement('div');
    bonus.className = 'score-bonus-float';

    if (multiplier > 1) {
        bonus.innerHTML = `+${points}<span style="font-size:28px;opacity:0.8;margin-left:8px;">(${multiplier}x)</span>`;
    } else {
        bonus.textContent = '+' + points;
    }

    // Color based on multiplier tier
    if (multiplier >= 8) {
        bonus.style.color = '#ff4444';
        bonus.style.textShadow = '0 0 30px #ff0000, 0 0 60px #ff4400, 0 4px 8px rgba(0,0,0,0.8)';
    } else if (multiplier >= 5) {
        bonus.style.color = '#ff8800';
    } else if (multiplier >= 3) {
        bonus.style.color = '#ffcc00';
    }

    document.body.appendChild(bonus);

    setTimeout(() => bonus.remove(), 1000);
}

// Add score for kills - applies multiplier and increases combo
function addKillScore(basePoints, isHeadshot = false) {
    // Apply multiplier
    const multipliedPoints = Math.floor(basePoints * killMultiplier);
    score += multipliedPoints;
    scoreAnimationTarget = score;

    // Increase multiplier (caps at max)
    const oldMultiplier = killMultiplier;
    killMultiplier = Math.min(killMultiplier + 1, killMultiplierMax);

    // Reset decay timer
    killMultiplierTimer = killMultiplierDecayTime;

    // Update UI
    updateMultiplierUI();
    updateHUD();

    // Play feedback if multiplier increased
    if (killMultiplier > oldMultiplier) {
        playMultiplierSound(killMultiplier);
        bumpMultiplierUI();
    }

    // Show floating score with multiplier info
    if (killMultiplier > 1) {
        showMultiplierScore(multipliedPoints, killMultiplier);
    }

    // Show big floating bonus for high multiplier or headshots
    if (killMultiplier >= 5 || (isHeadshot && killMultiplier >= 3)) {
        showScoreBonusFloat(multipliedPoints, killMultiplier);
    }

    // Enhanced score animation - mega for high multipliers
    const scoreEl = document.getElementById('score-display');
    if (scoreEl) {
        scoreEl.classList.remove('score-bump', 'score-mega-bump');
        void scoreEl.offsetWidth;

        if (killMultiplier >= 5 || multipliedPoints >= 500) {
            scoreEl.classList.add('score-mega-bump');
        } else {
            scoreEl.classList.add('score-bump');
        }
    }
}

// Update multiplier UI display
function updateMultiplierUI() {
    const container = document.getElementById('multiplier-container');
    const valueEl = document.getElementById('multiplier-value');
    const timerFill = document.getElementById('multiplier-timer-fill');

    if (!container || !valueEl || !timerFill) return;

    // Show/hide based on multiplier
    if (killMultiplier > 1) {
        container.classList.add('active');
        container.classList.remove('lost');
    }

    // Update value text
    valueEl.textContent = killMultiplier + 'x';

    // Update timer bar
    const timerPercent = (killMultiplierTimer / killMultiplierDecayTime) * 100;
    timerFill.style.width = timerPercent + '%';

    // Update color tier (1-2: white, 3-4: yellow, 5-6: orange, 7-8: dark orange, 9-10: red)
    let tier = 1;
    if (killMultiplier >= 9) tier = 5;
    else if (killMultiplier >= 7) tier = 4;
    else if (killMultiplier >= 5) tier = 3;
    else if (killMultiplier >= 3) tier = 2;
    container.setAttribute('data-tier', tier);

    // Warning pulse when timer is low
    if (killMultiplierTimer < 1.0 && killMultiplier > 1) {
        container.classList.add('warning');
    } else {
        container.classList.remove('warning');
    }
}

// Bump animation for multiplier
function bumpMultiplierUI() {
    const valueEl = document.getElementById('multiplier-value');
    if (!valueEl) return;

    valueEl.classList.remove('bump');
    void valueEl.offsetWidth;
    valueEl.classList.add('bump');
}

// Reset multiplier with feedback
function resetMultiplier() {
    if (killMultiplier <= 1) return;

    const container = document.getElementById('multiplier-container');
    if (container) {
        container.classList.add('lost');
        container.classList.remove('active', 'warning');
    }

    // Play lost sound
    playMultiplierLostSound();

    // Reset state
    killMultiplier = 1;
    killMultiplierTimer = 0;
    lastMultiplierLevel = 1;
}

// Procedural multiplier increase sound
function playMultiplierSound(level) {
    if (!actx) return;

    const now = actx.currentTime;

    // Rising pitch based on multiplier level
    const baseFreq = 400 + (level - 1) * 80;

    // Quick ascending tone
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(baseFreq * 0.8, now);
    osc.frequency.exponentialRampToValueAtTime(baseFreq * 1.2, now + 0.08);

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

    // Add harmonics for richness at higher levels
    if (level >= 5) {
        const osc2 = actx.createOscillator();
        osc2.type = 'triangle';
        osc2.frequency.setValueAtTime(baseFreq * 1.5, now);
        osc2.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + 0.1);

        const gain2 = actx.createGain();
        gain2.gain.setValueAtTime(0.08, now);
        gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

        osc2.connect(gain2);
        gain2.connect(actx.destination);
        osc2.start(now);
        osc2.stop(now + 0.15);
    }

    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.2);
}

// Procedural multiplier lost sound
function playMultiplierLostSound() {
    if (!actx) return;

    const now = actx.currentTime;

    // Descending sad tone
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(600, now);
    osc.frequency.exponentialRampToValueAtTime(200, now + 0.3);

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0.12, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.35);

    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.4);
}

// === HEALTH REGENERATION SOUNDS & UI ===

// Set regen visual state on UI elements
function setRegenUI(active) {
    const healthFill = document.getElementById('health-fill');
    const healthText = document.getElementById('health-text');
    const healthBar = document.getElementById('health-bar');
    const regenIndicator = document.getElementById('regen-indicator');

    if (healthFill) healthFill.classList.toggle('regenerating', active);
    if (healthText) healthText.classList.toggle('regenerating', active);
    if (healthBar) healthBar.classList.toggle('regenerating', active);
    if (regenIndicator) regenIndicator.classList.toggle('active', active);
}

// Regen start sound - gentle ascending chime
function playRegenStartSound() {
    if (!actx) return;

    const now = actx.currentTime;

    // Soft chime
    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(800, now);
    osc.frequency.exponentialRampToValueAtTime(1200, now + 0.15);

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0.08, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.3);

    // Second harmonic
    const osc2 = actx.createOscillator();
    osc2.type = 'triangle';
    osc2.frequency.setValueAtTime(1200, now + 0.05);
    osc2.frequency.exponentialRampToValueAtTime(1600, now + 0.2);

    const gain2 = actx.createGain();
    gain2.gain.setValueAtTime(0.04, now + 0.05);
    gain2.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

    osc2.connect(gain2);
    gain2.connect(actx.destination);
    osc2.start(now + 0.05);
    osc2.stop(now + 0.3);
}

// Regen tick sound - soft pulse
function playRegenTickSound() {
    if (!actx) return;

    const now = actx.currentTime;

    const osc = actx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(1000, now);

    const gain = actx.createGain();
    gain.gain.setValueAtTime(0.03, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.1);
}

// Regen complete sound - triumphant chord
function playRegenCompleteSound() {
    if (!actx) return;

    const now = actx.currentTime;

    // Major chord - C E G
    const frequencies = [523.25, 659.25, 783.99]; // C5, E5, G5

    frequencies.forEach((freq, i) => {
        const osc = actx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, now);

        const gain = actx.createGain();
        gain.gain.setValueAtTime(0.06, now + i * 0.03);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.4);

        osc.connect(gain);
        gain.connect(actx.destination);
        osc.start(now + i * 0.03);
        osc.stop(now + 0.5);
    });
}

// Show floating multiplier score
function showMultiplierScore(points, mult) {
    const popup = document.createElement('div');
    popup.className = 'multiplier-popup';
    popup.innerHTML = `+${points} <span style="color: #ffcc00; font-size: 0.7em;">(${mult}x)</span>`;
    popup.style.cssText = `
        position: fixed;
        top: 45%;
        left: 50%;
        transform: translateX(-50%);
        font-size: 24px;
        font-weight: bold;
        color: #fff;
        text-shadow: 0 0 10px rgba(255, 200, 0, 0.8), 0 2px 4px rgba(0, 0, 0, 0.8);
        pointer-events: none;
        z-index: 150;
        animation: multiplier-score-float 0.8s ease forwards;
    `;

    document.body.appendChild(popup);
    setTimeout(() => popup.remove(), 800);
}

function gameOver() {
    isGameOver = true;
    waveInProgress = false;
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('final-score').textContent = score;
    document.getElementById('final-wave').textContent = currentWave;
    document.exitPointerLock();
}

function restartGame() {
    // Reset all game state
    isPaused = false;
    playerHealth = maxPlayerHealth;
    score = 0;
    displayedScore = 0;
    scoreAnimationTarget = 0;
    killMultiplier = 1;
    killMultiplierTimer = 0;
    isRegenerating = false;
    lastDamageTime = 0;
    setRegenUI(false);
    const multiplierContainer = document.getElementById('multiplier-container');
    if (multiplierContainer) {
        multiplierContainer.classList.remove('active', 'warning', 'lost');
        multiplierContainer.setAttribute('data-tier', '1');
    }
    ammo = 30;
    reserve = 90;
    currentWave = 0;
    zombiesThisWave = 0;
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = false;
    betweenWaves = true;
    nextWaveCountdown = 3;
    isGameOver = false;
    isReloading = false;

    // Reset sniper state
    sniperAmmo = sniperMagSize;
    needsBoltCycle = false;
    isCyclingBolt = false;
    boltCyclePhase = 0;
    document.getElementById('bolt-indicator').classList.remove('show');

    // Reset shotgun state
    shotgunAmmo = shotgunMagSize;
    shotgunReserve = 32;
    needsPump = false;
    isPumping = false;
    pumpPhase = 0;
    document.getElementById('pump-indicator').classList.remove('show');

    // Reset to AK-47
    if (currentWeapon !== 'ak') {
        sniperRecoilGroup.visible = false;
        shotgunRecoilGroup.visible = false;
        recoilGroup.visible = true;
        currentWeapon = 'ak';
        updateWeaponIndicator();
    }

    // Clear all zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    // Clear all pickups - DISABLED
    // for (const pickup of pickups) {
    //     pickup.remove();
    // }
    // pickups.length = 0;

    // Reset power-up timers - DISABLED
    // speedBoostTimer = 0;
    // damageBoostTimer = 0;
    // rapidFireTimer = 0;
    // infiniteAmmoTimer = 0;
    // explosiveRoundsTimer = 0;
    // penetratingRoundsTimer = 0;
    // shieldTimer = 0;

    // Reset player position
    camera.position.set(0, 0, 0);

    // Hide game over screen
    document.getElementById('game-over').style.display = 'none';

    // Re-lock pointer
    document.body.requestPointerLock();

    updateHUD();
}

const moveState = { f: false, b: false, l: false, r: false, sprint: false };
const velocity = new THREE.Vector3();
// Player speed is 1.15x average zombie speed (zombie avg = 7.75, so player = ~9)
const baseSpeed = 9.0;
const sprintMultiplier = 1.8;
let prevTime = performance.now();

// Jump physics
let verticalVelocity = 0;
let playerHeight = 0; // Height above current terrain
let currentGroundLevel = 0; // Dynamic ground level (updated each frame)
const gravity = 35;
const jumpForce = 12;
let isGrounded = true;
let canJump = true;

// === DOUBLE JUMP ===
let hasDoubleJump = true;          // Reset on landing
const doubleJumpForce = 10;        // Slightly weaker than first jump

// === SLIDE SYSTEM ===
let isSliding = false;
let slideTimer = 0;
const slideDuration = 0.8;           // How long the slide lasts
const slideSpeedBoost = 1.4;         // Initial speed multiplier (on top of sprint)
const slideDeceleration = 1.2;       // How fast the slide slows down (lower = more momentum)
const slideCameraDropMax = 1.6;      // How low camera drops during slide
let slideCooldown = 0;
const slideCooldownTime = 0.3;       // Cooldown between slides
let slideDirection = new THREE.Vector3(); // Direction player slides in
let slideSpeed = 0;                  // Current slide speed

// Slide push - bulldoze zombies out of the way
const SLIDE_PUSH_RANGE = 3.5;        // How close zombies need to be to get pushed
const SLIDE_PUSH_KNOCKBACK = 18;     // Knockback force (stronger than kick)
const SLIDE_PUSH_DAMAGE = 1;         // Light damage when pushed

// Slide springs for smooth weapon animation
Springs.slideY = new Spring(180, 18, 1);      // Camera drop
Springs.slideTilt = new Spring(100, 12, 1);   // Forward lean
Springs.slideRoll = new Spring(80, 10, 1);    // Side roll
Springs.slideFOV = new Spring(60, 8, 1);      // FOV punch

// Smooth landing spring
Springs.landing = new Spring(200, 15, 1);

// CAMERA STATE
let cameraPitch = 0;
let cameraYaw = 0;
let cameraRecoil = 0;
let currentFOV = 90;
Springs.adsFov.position = 90;
Springs.adsFov.target = 90;

const crosshair = document.getElementById('crosshair');
const hitmarker = document.getElementById('hitmarker');

let hitmarkerTimeout = null;
function showHitmarker(isHeadshot = false) {
    hitmarker.classList.add('show');
    if (isHeadshot) {
        hitmarker.classList.add('headshot');
    }
    if (hitmarkerTimeout) clearTimeout(hitmarkerTimeout);
    hitmarkerTimeout = setTimeout(() => {
        hitmarker.classList.remove('show');
        hitmarker.classList.remove('headshot');
    }, isHeadshot ? 200 : 100);
}

/**
 * PENETRATION EFFECT - Sparks and blood spray at penetration point
 */
function spawnPenetrationEffect(position) {
    if (!position) return; // Guard against undefined position

    // Bright sparks at penetration point
    for (let i = 0; i < 8; i++) {
        const spark = sparks.find(s => !s.active);
        if (spark && spark.mesh) {
            spark.active = true;
            spark.life = 0.3 + Math.random() * 0.2;
            spark.maxLife = spark.life;
            spark.mesh.position.copy(position);
            spark.mesh.visible = true;
            // Radial burst from penetration point
            const angle = Math.random() * Math.PI * 2;
            const upAngle = Math.random() * Math.PI - Math.PI / 2;
            spark.velocity.set(
                Math.cos(angle) * Math.cos(upAngle) * (8 + Math.random() * 6),
                Math.sin(upAngle) * 4 + Math.random() * 3,
                Math.sin(angle) * Math.cos(upAngle) * (8 + Math.random() * 6)
            );
            spark.mesh.material.color.setHex(0xffcc00); // Golden penetration sparks
        }
    }

    // Blood/impact spray using blood particle system
    const hitDir = new THREE.Vector3(
        (Math.random() - 0.5) * 2,
        Math.random(),
        (Math.random() - 0.5) * 2
    ).normalize();
    spawnBloodSpray(position, hitDir, 0.5);
}

/**
 * COLLATERAL NOTIFICATION - Show multi-kill announcement
 */
let collateralNotification = null;
let collateralTimeout = null;

function showCollateralNotification(killCount) {
    if (!collateralNotification) {
        collateralNotification = document.createElement('div');
        collateralNotification.style.cssText = `
            position: fixed;
            top: 35%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Segoe UI', sans-serif;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 4px;
            text-align: center;
            pointer-events: none;
            z-index: 200;
            opacity: 0;
            transition: opacity 0.15s ease;
        `;
        document.body.appendChild(collateralNotification);
    }

    const messages = {
        2: { text: 'DOUBLE KILL', color: '#ffcc00' },
        3: { text: 'TRIPLE KILL', color: '#ff6600' },
        4: { text: 'COLLATERAL!', color: '#ff0000' }
    };
    const msg = messages[Math.min(killCount, 4)];

    collateralNotification.innerHTML = `
        <div style="font-size: 32px; color: ${msg.color}; text-shadow: 0 0 20px ${msg.color}, 0 2px 4px rgba(0,0,0,0.8);">
            ${msg.text}
        </div>
        <div style="font-size: 16px; color: #fff; margin-top: 5px; text-shadow: 0 2px 4px rgba(0,0,0,0.8);">
            +${killCount * 50} BONUS
        </div>
    `;
    collateralNotification.style.opacity = '1';

    // Play satisfying collateral sound
    playSound('collateral');

    if (collateralTimeout) clearTimeout(collateralTimeout);
    collateralTimeout = setTimeout(() => {
        collateralNotification.style.opacity = '0';
    }, 1500);

    // Extra score for collateral
    addScore(killCount * 50);
}

// Power-up display element (created once)
let powerupsEl = null;
function ensurePowerupsEl() {
    if (!powerupsEl) {
        powerupsEl = document.createElement('div');
        powerupsEl.id = 'powerups-display';
        powerupsEl.style.cssText = `
            position: absolute; bottom: 60px; left: 20px;
            display: flex; gap: 10px; pointer-events: none;
        `;
        document.body.appendChild(powerupsEl);
    }
    return powerupsEl;
}

function updateHUD(force = false) {
    const dom = getCachedDOM();
    const remaining = zombiesThisWave - zombiesKilledThisWave;
    const healthPercent = Math.ceil(playerHealth);

    // Get current weapon's ammo
    const currentAmmo = currentWeapon === 'sniper' ? sniperAmmo :
                        (currentWeapon === 'shotgun' ? shotgunAmmo : ammo);
    const currentMagSize = currentWeapon === 'sniper' ? sniperMagSize :
                           (currentWeapon === 'shotgun' ? shotgunMagSize : 30);
    const lowAmmoThreshold = currentWeapon === 'sniper' ? 2 :
                             (currentWeapon === 'shotgun' ? 3 : 10);

    // Only update if values changed (or forced)
    if (force || lastHUDValues.ammo !== currentAmmo || lastHUDValues.reserve !== reserve || lastHUDValues.isReloading !== isReloading || lastHUDValues.weapon !== currentWeapon) {
        lastHUDValues.ammo = currentAmmo;
        lastHUDValues.reserve = reserve;
        lastHUDValues.isReloading = isReloading;
        lastHUDValues.weapon = currentWeapon;
        if (dom.ammoDisplay) {
            if (isReloading) {
                dom.ammoDisplay.innerText = 'RLD / âˆž';
            } else {
                dom.ammoDisplay.innerText = `${currentAmmo} / âˆž`;
            }

            // Micro-animation classes for ammo state
            dom.ammoDisplay.classList.remove('low-ammo', 'empty', 'reloading');
            if (isReloading) {
                dom.ammoDisplay.classList.add('reloading');
            } else if (currentAmmo === 0) {
                dom.ammoDisplay.classList.add('empty');
            } else if (currentAmmo <= lowAmmoThreshold) {
                dom.ammoDisplay.classList.add('low-ammo');
            }
        }
    }

    if (force || lastHUDValues.health !== healthPercent) {
        lastHUDValues.health = healthPercent;
        const pct = (playerHealth / maxPlayerHealth) * 100;

        if (dom.healthFill) {
            dom.healthFill.style.width = pct + '%';
            dom.healthFill.classList.remove('damaged', 'critical');
            // Only show damage colors when NOT regenerating
            if (!isRegenerating) {
                if (pct <= 25) {
                    dom.healthFill.classList.add('critical');
                } else if (pct <= 50) {
                    dom.healthFill.classList.add('damaged');
                }
            }
        }
        if (dom.healthText) {
            dom.healthText.textContent = healthPercent;
            // Don't show critical during regen
            dom.healthText.classList.toggle('critical', pct <= 25 && !isRegenerating);
        }

        // Health bar border animation
        const healthBar = document.getElementById('health-bar');
        if (healthBar) {
            healthBar.classList.toggle('critical', pct <= 25 && !isRegenerating);
        }
    }

    if (force || lastHUDValues.wave !== currentWave || lastHUDValues.remaining !== remaining) {
        const prevWave = lastHUDValues.wave;
        const prevRemaining = lastHUDValues.remaining;
        lastHUDValues.wave = currentWave;
        lastHUDValues.remaining = remaining;

        if (dom.waveDisplay) {
            if (betweenWaves && currentWave > 0) {
                dom.waveDisplay.textContent = `BREACH ${currentWave} CONTAINED`;
            } else if (betweenWaves) {
                dom.waveDisplay.textContent = `BREACH INCOMING...`;
            } else {
                dom.waveDisplay.textContent = `BREACH ${currentWave}`;
            }

            // New wave animation
            if (currentWave !== prevWave && currentWave > 0) {
                dom.waveDisplay.classList.remove('new-wave');
                void dom.waveDisplay.offsetWidth;
                dom.waveDisplay.classList.add('new-wave');
            }
        }
        if (dom.zombieCount) {
            dom.zombieCount.textContent = `${remaining} HOSTILES`;

            // Kill flash animation
            if (remaining < prevRemaining && remaining >= 0) {
                dom.zombieCount.classList.remove('kill-flash');
                void dom.zombieCount.offsetWidth;
                dom.zombieCount.classList.add('kill-flash');
            }
        }
    }

    if (force || lastHUDValues.score !== score) {
        lastHUDValues.score = score;
        if (dom.scoreDisplay) {
            dom.scoreDisplay.textContent = score.toString().padStart(8, '0');
        }
    }

    // Power-ups (throttled to whole seconds)
    const speedSec = Math.ceil(speedBoostTimer);
    const damageSec = Math.ceil(damageBoostTimer);
    const rapidSec = Math.ceil(rapidFireTimer);
    const infiniteSec = Math.ceil(infiniteAmmoTimer);
    const explosiveSec = Math.ceil(explosiveRoundsTimer);
    const penetratingSec = Math.ceil(penetratingRoundsTimer);
    const shieldSec = Math.ceil(shieldTimer);

    // Check if any power-up changed
    const powerupsChanged = force ||
        lastHUDValues.speedSec !== speedSec ||
        lastHUDValues.damageSec !== damageSec ||
        lastHUDValues.rapidSec !== rapidSec ||
        lastHUDValues.infiniteSec !== infiniteSec ||
        lastHUDValues.explosiveSec !== explosiveSec ||
        lastHUDValues.penetratingSec !== penetratingSec ||
        lastHUDValues.shieldSec !== shieldSec;

    if (powerupsChanged) {
        lastHUDValues.speedSec = speedSec;
        lastHUDValues.damageSec = damageSec;
        lastHUDValues.rapidSec = rapidSec;
        lastHUDValues.infiniteSec = infiniteSec;
        lastHUDValues.explosiveSec = explosiveSec;
        lastHUDValues.penetratingSec = penetratingSec;
        lastHUDValues.shieldSec = shieldSec;

        const pEl = ensurePowerupsEl();
        let html = '';

        // Active power-ups with icons and colors
        if (shieldSec > 0) html += `<div class="powerup-item shield-active"><span class="powerup-icon">ðŸ›¡ï¸</span> SHIELD ${shieldSec}s</div>`;
        if (speedSec > 0) html += `<div class="powerup-item speed-active"><span class="powerup-icon">âš¡</span> SPEED ${speedSec}s</div>`;
        if (damageSec > 0) html += `<div class="powerup-item damage-active"><span class="powerup-icon">ðŸ’€</span> 2X DMG ${damageSec}s</div>`;
        if (rapidSec > 0) html += `<div class="powerup-item rapid-active"><span class="powerup-icon">ðŸ”¥</span> RAPID FIRE ${rapidSec}s</div>`;
        if (infiniteSec > 0) html += `<div class="powerup-item infinite-active"><span class="powerup-icon">âˆž</span> INFINITE AMMO ${infiniteSec}s</div>`;
        if (explosiveSec > 0) html += `<div class="powerup-item explosive-active"><span class="powerup-icon">ðŸ’¥</span> EXPLOSIVE ${explosiveSec}s</div>`;
        if (penetratingSec > 0) html += `<div class="powerup-item penetrating-active"><span class="powerup-icon">ðŸŽ¯</span> ARMOR PIERCING ${penetratingSec}s</div>`;

        pEl.innerHTML = html;
    }
}

function shoot() {
    if (isGameOver || isPaused) return;

    // Handle sniper semi-auto .50 cal
    if (currentWeapon === 'sniper') {
        if (isReloading || sniperAmmo <= 0) {
            if (sniperAmmo <= 0 && !isReloading) playSound('empty');
            return;
        }
        const now = performance.now() / 1000;
        if (now - lastShotTime < sniperFireRate) return;

        lastShotTime = now;
        sniperAmmo--;
        updateHUD();
        playSound('sniperShoot');

        // Eject shell immediately for semi-auto
        setTimeout(() => {
            if (currentWeapon === 'sniper') {
                ejectSniperShell();
            }
        }, 50);
    } else if (currentWeapon === 'shotgun') {
        // PUMP-ACTION SHOTGUN - Devastating but slow, auto-pump
        // Tactical reload: can cancel reload to fire if we have ammo
        if (isReloading && shotgunAmmo > 0) {
            // Cancel reload to fire - tactical interrupt
            isReloading = false;
            // Quick weapon snap back to ready
            new TWEEN.Tween(shotgunRecoilGroup.rotation)
                .to({ z: 0, x: 0, y: Math.PI }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }
        if (isPumping || shotgunAmmo <= 0) {
            if (shotgunAmmo <= 0 && !isReloading && !isPumping && shotgunReserve > 0) {
                // Auto-reload when empty
                setTimeout(() => reload(), 100);
            } else if (shotgunAmmo <= 0 && !isReloading && !isPumping) {
                playSound('empty');
            }
            return;
        }
        const now = performance.now() / 1000;
        if (now - lastShotTime < shotgunFireRate) return;

        lastShotTime = now;
        shotgunAmmo--;
        updateHUD();
        playSound('shotgunShoot');

        // Auto-pump after a short delay for recoil to register
        setTimeout(() => {
            if (currentWeapon === 'shotgun' && !isPumping) {
                autoPumpShotgun();
            }
        }, 180);
    } else {
        // AK-47 behavior with power-up support
        if (isReloading || (ammo <= 0 && infiniteAmmoTimer <= 0)) {
            if (ammo <= 0 && !isReloading && infiniteAmmoTimer <= 0) playSound('empty');
            return;
        }
        const now = performance.now() / 1000;
        // Apply rapid fire multiplier
        const effectiveFireRate = rapidFireTimer > 0 ? fireRate / rapidFireMultiplier : fireRate;
        if (now - lastShotTime < effectiveFireRate) return;

        lastShotTime = now;
        // Infinite ammo prevents ammo consumption
        if (infiniteAmmoTimer <= 0) ammo--;
        updateHUD();
        playSound('shoot');
    }

    // ORGANIC RECOIL IMPULSE PHYSICS
    const isSniper = currentWeapon === 'sniper';
    const isShotgun = currentWeapon === 'shotgun';
    const aimMod = isAiming ? (isSniper ? 0.12 : (isShotgun ? 0.45 : 0.35)) : 1.0;
    const recoilMult = isSniper ? 2.5 : (isShotgun ? 1.8 : 1.0);

    // Randomize recoil slightly for organic feel (no two shots identical)
    const recoilVariance = 0.85 + Math.random() * 0.3;
    const horizontalBias = (Math.random() - 0.5) * (isSniper ? 0.15 : (isShotgun ? 0.25 : 0.4));

    if (isShotgun) {
        // === SHOTGUN RECOIL - Punchy but controlled ===
        // Pump shotgun: Strong kick that recovers quickly

        // Primary kick - backward slam (Restored visual kick for heavy mass)
        ShotgunSprings.recoilZ.impulse(-90 * aimMod * recoilVariance);

        // Muzzle climb
        ShotgunSprings.recoilX.impulse(-35 * aimMod * recoilVariance);

        // Vertical jump
        ShotgunSprings.recoilY.impulse(15 * aimMod * recoilVariance);

        // Rotational kick
        ShotgunSprings.recoilRoll.impulse((horizontalBias + (Math.random() - 0.5) * 0.4) * 10 * aimMod);
        ShotgunSprings.recoilTilt.impulse((Math.random() - 0.5) * 6 * aimMod);

        // Stock slam into shoulder
        ShotgunSprings.stockKick.impulse(50 * aimMod * recoilVariance);
        ShotgunSprings.stockRotate.impulse(-18 * aimMod * recoilVariance);

        // Barrel droop after the kick
        ShotgunSprings.barrelDroop.impulse(12 * recoilVariance);

        // Momentum
        ShotgunSprings.momentumX.impulse(horizontalBias * 25);
        ShotgunSprings.momentumZ.impulse(-40 * aimMod);

        // Recovery - fast return
        ShotgunSprings.recoveryZ.target = ShotgunSprings.recoilZ.position * 0.25;
        ShotgunSprings.recoveryX.target = ShotgunSprings.recoilX.position * 0.25;

        // Camera recoil - punchy snap
        cameraRecoil += 0.08 * aimMod * recoilVariance;

        // Screen shake (reduced from 10/8/5)
        Springs.shakeX.impulse((Math.random() - 0.5) * 5 * aimMod);
        Springs.shakeY.impulse((Math.random() - 0.2) * 4 * aimMod);
        Springs.shakeRoll.impulse((Math.random() - 0.5) * 2.5 * aimMod);

        // Body rocks from the kick
        Springs.bobZ.impulse(-5 * aimMod);
        Springs.bobY.impulse(-2 * aimMod);
        Springs.roll.impulse(horizontalBias * 1.5 * aimMod);
        Springs.tilt.impulse(-2.5 * aimMod);

    } else if (isSniper) {
        // === BRUTAL SNIPER RECOIL - VIOLENT JOLT ===
        // This thing KICKS. Hard. Like getting punched in the shoulder.

        // Primary kick - VIOLENT backward jolt (the gun SLAMS back)
        SniperSprings.heavyRecoilZ.impulse(-80 * aimMod * recoilVariance);

        // Muzzle SNAP up - aggressive climb
        SniperSprings.heavyRecoilX.impulse(-25 * aimMod * recoilVariance);

        // Vertical physical rise - whole gun jumps up
        SniperSprings.heavyRecoilY.impulse(8 * aimMod * recoilVariance);

        // Rotational torque - violent twist
        SniperSprings.heavyRecoilRoll.impulse((horizontalBias + (Math.random() - 0.5) * 0.4) * 4 * aimMod);

        // Stock compression - gun SLAMS into shoulder
        SniperSprings.stockCompress.impulse(40 * aimMod * recoilVariance);
        SniperSprings.stockRotate.impulse(-18 * aimMod * recoilVariance);

        // Scope shake - VIOLENT jitter (your view gets rocked)
        SniperSprings.scopeShakeX.impulse((Math.random() - 0.5) * 35 * aimMod);
        SniperSprings.scopeShakeY.impulse((Math.random() - 0.3) * 30 * aimMod);

        // Scope settle - crosshair wobbles for a while
        SniperSprings.scopeSettleX.impulse((Math.random() - 0.5) * 12);
        SniperSprings.scopeSettleY.impulse((Math.random() - 0.5) * 12);

        // Barrel droop - dramatic forward dip after the jolt
        SniperSprings.barrelDroop.impulse(8 * recoilVariance);

        // Heavy momentum - weapon gets THROWN back
        SniperSprings.heavyMomentumX.impulse(horizontalBias * 20);
        SniperSprings.heavyMomentumZ.impulse(-30 * aimMod);

        // Recovery targets - slow crawl back to neutral
        SniperSprings.recoveryZ.target = SniperSprings.heavyRecoilZ.position * 0.4;
        SniperSprings.recoveryX.target = SniperSprings.heavyRecoilX.position * 0.4;

        // BRUTAL camera recoil - your whole view gets PUNCHED
        cameraRecoil += 0.18 * aimMod * recoilVariance;

        // Screen shake - VIOLENT
        Springs.shakeX.impulse((Math.random() - 0.5) * 15 * aimMod);
        Springs.shakeY.impulse((Math.random() - 0.2) * 12 * aimMod);
        Springs.shakeRoll.impulse((Math.random() - 0.5) * 8 * aimMod);

        // Whole body rocks back HARD from the shot
        Springs.bobZ.impulse(-8 * aimMod);
        Springs.bobY.impulse(-3 * aimMod); // Body dips down from impact
        Springs.roll.impulse(horizontalBias * 2 * aimMod);
        Springs.tilt.impulse(-4 * aimMod); // Lean back from the kick

    } else {
        // === AK-47 RECOIL (unchanged - snappy and responsive) ===
        Springs.recoilZ.impulse(-14 * aimMod * recoilVariance);
        Springs.recoilX.impulse(-3.5 * aimMod * recoilVariance);
        Springs.recoilY.impulse(0.6 * aimMod * recoilVariance);
        Springs.recoilRoll.impulse((horizontalBias + (Math.random() - 0.5) * 0.3) * 0.8 * aimMod);
        Springs.roll.impulse(horizontalBias * 0.4 * aimMod);
        Springs.swayX.impulse(horizontalBias * 0.15 * aimMod);
        cameraRecoil += 0.025 * aimMod * recoilVariance;
        Springs.bobZ.impulse(-0.8 * aimMod);
    }

    // Crosshair pop with smooth animation
    if(!isAiming) {
        crosshair.style.width = '45px'; crosshair.style.height = '45px';
        crosshair.style.transition = 'width 0.05s, height 0.05s';
        setTimeout(() => {
            crosshair.style.width = '20px'; crosshair.style.height = '20px';
            crosshair.style.transition = 'width 0.15s ease-out, height 0.15s ease-out';
        }, 50);
    }

    // ENHANCED FLASH with variance
    const flashIntensity = (isSniper ? 1.1 : (isShotgun ? 1.2 : 0.9)) + Math.random() * 0.2;
    flashCoreMat.opacity = flashIntensity;
    flashMidMat.opacity = flashIntensity * 0.9;
    flashOuterMat.opacity = flashIntensity * 0.7;
    flashStreakMat.opacity = flashIntensity * 0.8;

    // Use correct weapon group for flash
    const activeGunGroup = isSniper ? sniperGroup : (isShotgun ? shotgunGroup : gunGroup);
    const activeFlashGroup = isSniper ? sniperFlashGroup : (isShotgun ? shotgunFlashGroup : flashGroup);
    activeFlashGroup.rotation.z = Math.random() * Math.PI;
    activeFlashGroup.scale.setScalar((isSniper ? 0.9 : (isShotgun ? 1.1 : 0.75)) + Math.random() * 0.5);

    const muzzleOffset = isSniper
        ? new THREE.Vector3(0, 0.024, -2.1)
        : (isShotgun ? new THREE.Vector3(0, 0.35, -11.0) : new THREE.Vector3(0, 0.3, -7.5));
    muzzleLight.position.copy(muzzleOffset.applyMatrix4(activeGunGroup.matrixWorld));
    muzzleLight.intensity = (isSniper ? 35 : (isShotgun ? 40 : 25)) + Math.random() * 10;
    muzzleLight.color.setHex(isShotgun ? 0xffbb55 : 0xffaa44); // Slightly warmer for shotgun

    // Spawn muzzle sparks
    spawnMuzzleSparks();

    // Dynamic post-processing punch (stronger for sniper)
    bloomIntensity = (isSniper ? 0.6 : 0.4) + Math.random() * 0.15;
    chromaticAmount = (isSniper ? 0.003 : 0.0015) + Math.random() * 0.001;

    // Screen shake - organic variance (stronger for sniper)
    const shakeIntensity = aimMod * recoilVariance * recoilMult;
    Springs.shakeX.impulse((Math.random() - 0.5) * 2.5 * shakeIntensity);
    Springs.shakeY.impulse((Math.random() - 0.3) * 2 * shakeIntensity); // Bias upward
    Springs.shakeRoll.impulse((Math.random() - 0.5) * 1.5 * shakeIntensity);

    // Bolt snap - spring-driven for smooth return (AK only, sniper/shotgun have manual actions)
    if (!isSniper && !isShotgun) {
        Springs.boltZ.impulse(8);
    }
    lastFireTime = performance.now();
    consecutiveShots++;

    // Shell ejection (AK ejects immediately, sniper/shotgun eject during pump/bolt cycle)
    if (!isSniper && !isShotgun) {
        ejectShell();
    }
    spawnSmoke();
    spawnMuzzleSmokeWisps();

    // Extra smoke puffs for shotgun (wider spread)
    if (isShotgun) {
        for (let i = 0; i < 3; i++) {
            setTimeout(() => spawnSmoke(), 20 * i);
        }
    }

    // RAYCAST - Handle shotgun pellet spread
    // Update world matrices for all zombies to ensure hitboxes are at correct positions
    // This is critical for penetration/collateral detection
    for (const zombie of zombies) {
        if (!zombie.isDead) {
            zombie.mesh.updateMatrixWorld(true);
        }
    }

    const muzzlePos = isSniper
        ? new THREE.Vector3(0, 0.024, -2.0).applyMatrix4(sniperGroup.matrixWorld)
        : (isShotgun ? new THREE.Vector3(0, 0.35, -11.0).applyMatrix4(shotgunGroup.matrixWorld)
            : new THREE.Vector3(0, 0.3, -6.5).applyMatrix4(gunGroup.matrixWorld));
    let hitPoint;

    // Track all hit bots for multi-pellet damage and collateral announcements
    const hitBots = new Set();
    const pelletHits = new Map(); // Track how many pellets hit each bot

    if (isShotgun) {
        // === SHOTGUN PELLET SPREAD ===
        // Fire multiple pellets in a cone pattern
        const baseDir = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
        const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
        const up = new THREE.Vector3(0, 1, 0).applyQuaternion(camera.quaternion);

        let furthestHitPoint = null;
        let maxDist = 0;

        for (let p = 0; p < shotgunPelletCount; p++) {
            // Random spread within cone
            const spreadX = (Math.random() - 0.5) * 2 * shotgunSpread;
            const spreadY = (Math.random() - 0.5) * 2 * shotgunSpread;

            const pelletDir = baseDir.clone()
                .add(right.clone().multiplyScalar(spreadX))
                .add(up.clone().multiplyScalar(spreadY))
                .normalize();

            raycaster.set(camera.position, pelletDir);
            const pelletHitList = raycaster.intersectObjects(targets);

            if (pelletHitList.length > 0) {
                const hit = pelletHitList[0];

                if (hit.object.userData.isTarget) {
                    const target = hit.object.userData.targetRef;
                    if (target && target.isUp) {
                        target.knockDown();
                        playSound('targetHit');
                    }
                } else if (hit.object.userData.isBot) {
                    const bot = hit.object.userData.botRef;
                    if (bot && !bot.isDead) {
                        // Track pellet hits per bot
                        if (!pelletHits.has(bot)) pelletHits.set(bot, 0);
                        pelletHits.set(bot, pelletHits.get(bot) + 1);
                        hitBots.add(bot);
                    }
                } else if (hit.face) {
                    spawnDecal(hit.point, hit.face.normal);
                }

                // Track furthest hit for tracer
                const dist = hit.distance;
                if (dist > maxDist) {
                    maxDist = dist;
                    furthestHitPoint = hit.point;
                }
            }

            // Spawn individual pellet tracer (thinner than normal)
            const pelletEnd = furthestHitPoint || camera.position.clone().add(pelletDir.multiplyScalar(50));
            spawnShotgunPelletTracer(muzzlePos.clone(), pelletEnd);
        }

        // Apply damage to all hit bots based on pellet count
        for (const [bot, pelletCount] of pelletHits) {
            const hitPointWorld = bot.mesh.position.clone();
            hitPointWorld.y += 1.5; // Approximate hit point

            // HEADSHOT: If pellets hit upper body/head zone
            // Brutes are immune to headshots (thick skull)
            const isHeadshot = !bot.headExploded && bot.type !== 'brute' && Math.random() < pelletCount * 0.12;

            if (isHeadshot) {
                const hitDir = new THREE.Vector3();
                hitDir.subVectors(hitPointWorld, camera.position).normalize();
                explodeHead(bot, hitPointWorld, hitDir);
                showHitmarker(true);
                addKillScore(100 + pelletCount * 15, true); // Headshot - applies multiplier
                bot.health = 0;
                bot.die();
            } else {
                // Cumulative damage from pellets
                const totalDamage = shotgunDamageMultiplier * pelletCount;
                bot.hit(hitPointWorld, totalDamage);
                showHitmarker(false);
            }
        }

        hitPoint = furthestHitPoint || camera.position.clone().add(baseDir.multiplyScalar(50));

        // Multi-kill announcement
        if (hitBots.size > 1) {
            showCollateralNotification(hitBots.size);
        }

    } else {
        // === SINGLE PROJECTILE (AK / SNIPER) ===
        raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
        const intersects = raycaster.intersectObjects(targets);

        // PENETRATION: Sniper always pierces, AK pierces with power-up
        const hasPenetration = isSniper || penetratingRoundsTimer > 0;
        const maxPenetrations = isSniper ? 3 : (penetratingRoundsTimer > 0 ? 2 : 1);
        let penetrationCount = 0;
        let lastHitPoint = null;

        if (intersects.length > 0) {
            for (let i = 0; i < intersects.length && penetrationCount < maxPenetrations; i++) {
                const hit = intersects[i];
                lastHitPoint = hit.point;

                if (hit.object.userData.isTarget) {
                    const target = hit.object.userData.targetRef;
                    if (target && target.isUp) {
                        target.knockDown();
                        playSound('targetHit');
                        penetrationCount++;
                        if (hasPenetration && penetrationCount < maxPenetrations) {
                            spawnPenetrationEffect(hit.point);
                        }
                    }
                } else if (hit.object.userData.isBot) {
                    const bot = hit.object.userData.botRef;
                    if (!bot || bot.isDead || hitBots.has(bot)) continue;
                    hitBots.add(bot);

                    const hitPointWorld = hit.point.clone();
                    const zombieBaseY = bot.mesh.position.y;
                    const hitLocalY = hitPointWorld.y - zombieBaseY;
                    // Brutes are immune to headshots (thick skull)
                    const isHeadshot = hitLocalY > 2.9 && !bot.headExploded && bot.type !== 'brute';

                    if (isHeadshot) {
                        const hitDir = new THREE.Vector3();
                        hitDir.subVectors(hitPointWorld, camera.position).normalize();
                        explodeHead(bot, hitPointWorld, hitDir);
                        showHitmarker(true);
                        const collateralBonus = penetrationCount > 0 ? 50 * penetrationCount : 0;
                        addKillScore((isSniper ? 200 : 150) + collateralBonus, true); // Headshot - applies multiplier
                        bot.health = 0;
                        bot.die();
                    } else {
                        bot.hit(hitPointWorld, isSniper ? sniperDamageMultiplier : 1.0);
                        showHitmarker(false);
                        if (penetrationCount > 0 && hasPenetration) {
                            addScore(25 * penetrationCount);
                        }
                    }

                    // EXPLOSIVE ROUNDS: AOE damage on hit
                    if (explosiveRoundsTimer > 0) {
                        spawnExplosion(hitPointWorld, 5, 2.0); // radius 5, damage multiplier 2.0
                    }

                    penetrationCount++;
                    if (hasPenetration && penetrationCount < maxPenetrations) {
                        spawnPenetrationEffect(hitPointWorld);
                    }

                } else if (hit.face) {
                    spawnDecal(hit.point, hit.face.normal);
                    // Explosive rounds create small explosion on surface hits too
                    if (explosiveRoundsTimer > 0) {
                        spawnExplosion(hit.point, 4, 1.5);
                    }
                    if (!hasPenetration) {
                        break; // Non-penetrating stops at first surface
                    }
                    // Penetrating: continue through surfaces
                }
            }

            hitPoint = lastHitPoint;

            if (hasPenetration && hitBots.size > 1) {
                showCollateralNotification(hitBots.size);
            }
        } else {
            hitPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
        }
        spawnTracer(muzzlePos, hitPoint);
    }
}

// Spawn individual shotgun pellet tracer (thinner, faster fade)
function spawnShotgunPelletTracer(start, end) {
    const dir = new THREE.Vector3().subVectors(end, start);
    const dist = dir.length();
    dir.normalize();

    const tracerGeo = new THREE.CylinderGeometry(0.015, 0.015, Math.min(dist, 4), 4);
    const tracerMat = new THREE.MeshBasicMaterial({
        color: 0xffdd88,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending
    });
    const tracer = new THREE.Mesh(tracerGeo, tracerMat);

    // Position at midpoint
    tracer.position.copy(start).add(dir.clone().multiplyScalar(dist / 2));
    tracer.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);

    scene.add(tracer);
    tracers.push({
        mesh: tracer,
        velocity: dir.clone().multiplyScalar(250),
        life: 0.08 // Very short life for pellet tracers
    });
}

/**
 * BOLT ACTION CYCLE - Manual bolt work after each sniper shot
 */
function cycleBolt() {
    if (!needsBoltCycle || isCyclingBolt || currentWeapon !== 'sniper') return;

    isCyclingBolt = true;
    boltCyclePhase = 1;
    document.getElementById('bolt-indicator').classList.remove('show');

    // Phase 1: Lift bolt handle (rotate up)
    playSound('boltLift');
    new TWEEN.Tween(sniperBoltHandle.rotation)
        .to({ z: -Math.PI / 3 }, 120)
        .easing(TWEEN.Easing.Cubic.Out)
        .onComplete(() => {
            boltCyclePhase = 2;

            // Phase 2: Pull bolt back (extract casing)
            playSound('boltPull');
            new TWEEN.Tween(sniperBoltHandle.position)
                .to({ z: sniperBoltHandle.position.z + 1.5 }, 180)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .onComplete(() => {
                    // Eject the spent casing during pull
                    ejectSniperShell();
                    boltCyclePhase = 3;

                    // Phase 3: Push bolt forward (chamber new round)
                    setTimeout(() => {
                        playSound('boltPush');
                        new TWEEN.Tween(sniperBoltHandle.position)
                            .to({ z: sniperBoltHandle.position.z - 1.5 }, 150)
                            .easing(TWEEN.Easing.Quadratic.In)
                            .onComplete(() => {
                                boltCyclePhase = 4;

                                // Phase 4: Lock bolt down
                                playSound('boltDown');
                                new TWEEN.Tween(sniperBoltHandle.rotation)
                                    .to({ z: 0 }, 100)
                                    .easing(TWEEN.Easing.Cubic.In)
                                    .onComplete(() => {
                                        boltCyclePhase = 0;
                                        isCyclingBolt = false;
                                        needsBoltCycle = false;

                                        // Slight weapon shake on bolt close
                                        Springs.recoilZ.impulse(-3);
                                        Springs.recoilX.impulse(-1);
                                    })
                                    .start();
                            })
                            .start();
                    }, 80);
                })
                .start();
        })
        .start();
}

// Sniper shell ejection (bigger brass)
function ejectSniperShell() {
    const shellGeoSniper = new THREE.CylinderGeometry(0.05, 0.05, 0.5, 8);
    const shell = new THREE.Mesh(shellGeoSniper, shellMat);
    shell.position.copy(new THREE.Vector3(0.08, 0.1, 0.08).applyMatrix4(sniperGroup.matrixWorld));
    shell.quaternion.copy(sniperGroup.quaternion);
    shell.rotation.z = Math.PI / 2;
    const velocity = new THREE.Vector3(0.15 + Math.random() * 0.1, 0.25 + Math.random() * 0.1, 0.1).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 3.0 };
    scene.add(shell);
    shells.push(shell);
}

// Shotgun shell ejection (red hull)
function ejectShotgunShell() {
    const shellGeo = new THREE.CylinderGeometry(0.04, 0.045, 0.35, 8);
    const shellMaterial = new THREE.MeshStandardMaterial({
        color: 0xcc2222, // Red hull
        roughness: 0.6,
        metalness: 0.2
    });
    const shell = new THREE.Mesh(shellGeo, shellMaterial);

    // Add brass rim
    const rimGeo = new THREE.CylinderGeometry(0.05, 0.05, 0.06, 8);
    const rim = new THREE.Mesh(rimGeo, new THREE.MeshStandardMaterial({
        color: 0xccaa44, roughness: 0.3, metalness: 0.8
    }));
    rim.position.y = -0.15;
    shell.add(rim);

    shell.position.copy(new THREE.Vector3(0.35, 0.3, -0.5).applyMatrix4(shotgunGroup.matrixWorld));
    shell.quaternion.copy(shotgunGroup.quaternion);
    shell.rotation.z = Math.PI / 2;

    // Eject to the right with spin
    const velocity = new THREE.Vector3(
        0.25 + Math.random() * 0.15,
        0.2 + Math.random() * 0.15,
        0.05 + Math.random() * 0.1
    ).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 3.0 };

    scene.add(shell);
    shells.push(shell);
}

/**
 * PUMP ACTION CYCLE - Satisfying "chk-chk" after each shotgun shot
 */
function pumpShotgun() {
    if (!needsPump || isPumping || currentWeapon !== 'shotgun') return;

    isPumping = true;
    pumpPhase = 1;

    const origPumpZ = sgPumpPivot.position.z;

    // Phase 1: Pull pump back (eject shell)
    playSound('pumpPull');

    // Pump slides back
    new TWEEN.Tween(sgPumpPivot.position)
        .to({ z: origPumpZ + 1.2 }, 140)
        .easing(TWEEN.Easing.Cubic.Out)
        .onComplete(() => {
            // Eject spent shell during pull
            ejectShotgunShell();

            // Weapon reacts to pump force
            ShotgunSprings.recoilZ.impulse(-8);
            ShotgunSprings.foreEndZ.impulse(-15);

            pumpPhase = 2;

            // Small pause at back of stroke
            setTimeout(() => {
                // Phase 2: Push pump forward (chamber new round)
                playSound('pumpPush');

                new TWEEN.Tween(sgPumpPivot.position)
                    .to({ z: origPumpZ }, 120)
                    .easing(TWEEN.Easing.Cubic.In)
                    .onComplete(() => {
                        pumpPhase = 0;
                        isPumping = false;
                        needsPump = false;
                        document.getElementById('pump-indicator').classList.remove('show');

                        // Satisfying thunk on close
                        ShotgunSprings.recoilZ.impulse(-4);
                        ShotgunSprings.stockKick.impulse(8);
                        Springs.bobY.impulse(-0.5);
                    })
                    .start();
            }, 60);
        })
        .start();
}

/**
 * AUTO PUMP - Called automatically after each shot, triggers reload when empty
 */
function autoPumpShotgun() {
    if (isPumping || currentWeapon !== 'shotgun') return;

    isPumping = true;
    pumpPhase = 1;

    const origPumpZ = sgPumpPivot.position.z;

    // Phase 1: Pull pump back (eject shell)
    playSound('pumpPull');

    // Pump slides back
    new TWEEN.Tween(sgPumpPivot.position)
        .to({ z: origPumpZ + 1.2 }, 140)
        .easing(TWEEN.Easing.Cubic.Out)
        .onComplete(() => {
            // Eject spent shell during pull
            ejectShotgunShell();

            // Weapon reacts to pump force
            ShotgunSprings.recoilZ.impulse(-8);
            ShotgunSprings.foreEndZ.impulse(-15);

            pumpPhase = 2;

            // Small pause at back of stroke
            setTimeout(() => {
                // Phase 2: Push pump forward (chamber new round)
                playSound('pumpPush');

                new TWEEN.Tween(sgPumpPivot.position)
                    .to({ z: origPumpZ }, 120)
                    .easing(TWEEN.Easing.Cubic.In)
                    .onComplete(() => {
                        pumpPhase = 0;
                        isPumping = false;

                        // Satisfying thunk on close
                        ShotgunSprings.recoilZ.impulse(-4);
                        ShotgunSprings.stockKick.impulse(8);
                        Springs.bobY.impulse(-0.5);

                        // Auto-reload when empty
                        if (shotgunAmmo <= 0 && shotgunReserve > 0 && !isReloading) {
                            setTimeout(() => reload(), 150);
                        }
                    })
                    .start();
            }, 60);
        })
        .start();
}

/**
 * WEAPON SWITCHING SYSTEM
 */
function getWeaponRecoilGroup(weapon) {
    if (weapon === 'ak') return recoilGroup;
    if (weapon === 'sniper') return sniperRecoilGroup;
    if (weapon === 'shotgun') return shotgunRecoilGroup;
    return recoilGroup;
}

function getWeaponHipPos(weapon) {
    if (weapon === 'ak') return hipPos;
    if (weapon === 'sniper') return sniperHipPos;
    if (weapon === 'shotgun') return shotgunHipPos;
    return hipPos;
}

function switchWeapon(targetWeapon) {
    if (isSwitchingWeapon || isReloading || isCyclingBolt || isPumping) return;
    if (targetWeapon === currentWeapon) return;

    isSwitchingWeapon = true;
    playSound('weaponSwitch');

    // Hide bolt indicator if switching away from sniper
    if (currentWeapon === 'sniper') {
        document.getElementById('bolt-indicator').classList.remove('show');
    }

    // Reset pump state if switching away from shotgun
    if (currentWeapon === 'shotgun') {
        needsPump = false;
        isPumping = false;
        document.getElementById('pump-indicator').classList.remove('show');
    }

    // Hide body when switching away from shotgun
    // DISABLED - body removed
    // if (currentWeapon === 'shotgun' && window.playerBodyGroup) {
    //     window.playerBodyGroup.visible = false;
    // }

    // Lower current weapon
    const currentRecoilGroup = getWeaponRecoilGroup(currentWeapon);
    new TWEEN.Tween(currentRecoilGroup.position)
        .to({ y: currentRecoilGroup.position.y - 2 }, 150)
        .easing(TWEEN.Easing.Cubic.In)
        .onComplete(() => {
            // Hide current weapon
            currentRecoilGroup.visible = false;

            // Switch weapon
            currentWeapon = targetWeapon;

            // Show body when switching to shotgun
            // DISABLED - body removed
            // if (targetWeapon === 'shotgun' && window.playerBodyGroup) {
            //     window.playerBodyGroup.visible = true;
            // }

            // Show and raise new weapon
            const newRecoilGroup = getWeaponRecoilGroup(currentWeapon);
            const newHipPos = getWeaponHipPos(currentWeapon);

            newRecoilGroup.visible = true;
            newRecoilGroup.position.copy(newHipPos);
            newRecoilGroup.position.y -= 2;

            new TWEEN.Tween(newRecoilGroup.position)
                .to({ y: newHipPos.y }, 200)
                .easing(TWEEN.Easing.Cubic.Out)
                .onComplete(() => {
                    isSwitchingWeapon = false;
                    updateHUD();
                    updateWeaponIndicator();
                })
                .start();
        })
        .start();
}

function updateWeaponIndicator() {
    const slots = document.querySelectorAll('.weapon-slot');
    slots.forEach(slot => {
        if (slot.dataset.weapon === currentWeapon) {
            slot.classList.add('active');
        } else {
            slot.classList.remove('active');
        }
    });
}

function dropMag() {
    const dMag = magPivot.clone(); // Clone pivot to preserve rotation
    scene.add(dMag);
    const wp = new THREE.Vector3(); const wq = new THREE.Quaternion();
    magPivot.getWorldPosition(wp); magPivot.getWorldQuaternion(wq);
    dMag.position.copy(wp); dMag.quaternion.copy(wq);
    // Inherit some velocity?
    dMag.userData = { vel: new THREE.Vector3(0, -2, 0), rot: new THREE.Vector3(1, 0, 0), life: 200 };
    mags.push(dMag);
}

function dropSniperMag() {
    const dMag = sniperMagPivot.clone(); // Clone pivot to preserve rotation
    scene.add(dMag);
    const wp = new THREE.Vector3(); const wq = new THREE.Quaternion();
    sniperMagPivot.getWorldPosition(wp); sniperMagPivot.getWorldQuaternion(wq);
    dMag.position.copy(wp); dMag.quaternion.copy(wq);
    // Tumbling fall with slight sideways velocity
    dMag.userData = {
        vel: new THREE.Vector3((Math.random() - 0.5) * 0.8, -1.5, (Math.random() - 0.5) * 0.5),
        rot: new THREE.Vector3(2 + Math.random(), Math.random() * 2, Math.random()),
        life: 250
    };
    mags.push(dMag);
}

/**
 * HIGH-END RELOAD SEQUENCE (Tween.js)
 */
function reload() {
    if (isGameOver) return;

    // Handle sniper reload (.50 cal semi-auto)
    if (currentWeapon === 'sniper') {
        if (isReloading || sniperAmmo === sniperMagSize) return;
        if (isAiming) isAiming = false;
        isReloading = true;
        updateHUD();

        // Store original positions
        const origPos = sniperRecoilGroup.position.clone();
        const magOrigY = sniperMagPivot.position.y;

        // === PHASE 1: Weapon lift and inspect (0-250ms) ===
        // Lift weapon up slightly, rotate to view mag well
        new TWEEN.Tween(sniperRecoilGroup.position)
            .to({ y: origPos.y + 0.15, x: origPos.x - 0.1 }, 250)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

        new TWEEN.Tween(sniperRecoilGroup.rotation)
            .to({ z: 0.35, x: 0.15, y: Math.PI + 0.1 }, 250)
            .easing(TWEEN.Easing.Quadratic.Out)
            .start();

        // === PHASE 2: Roll weapon and release mag (250-500ms) ===
        setTimeout(() => {
            // Deep roll to expose magazine
            new TWEEN.Tween(sniperRecoilGroup.rotation)
                .to({ z: 0.75, x: 0.35, y: Math.PI + 0.15 }, 280)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ y: origPos.y + 0.08, x: origPos.x - 0.2, z: origPos.z + 0.1 }, 280)
                .easing(TWEEN.Easing.Cubic.Out)
                .start();

            // Mag release click
            setTimeout(() => {
                playSound('mag_out');
                Springs.recoilZ.impulse(2);

                // Magazine swings out and drops
                new TWEEN.Tween(sniperMagPivot.rotation)
                    .to({ x: 1.8, z: 0.3 }, 200)
                    .easing(TWEEN.Easing.Quadratic.In)
                    .onComplete(() => {
                        // Spawn falling magazine
                        dropSniperMag();
                        sniperMagPivot.visible = false;
                        Springs.bobY.impulse(-2);
                    })
                    .start();
            }, 120);
        }, 250);

        // === PHASE 3: Hand reaches for new mag (500-850ms) ===
        setTimeout(() => {
            // Weapon dips down as hand reaches for mag
            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ y: origPos.y - 0.25, x: origPos.x - 0.15, z: origPos.z + 0.2 }, 350)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();

            new TWEEN.Tween(sniperRecoilGroup.rotation)
                .to({ z: 0.5, x: 0.5, y: Math.PI + 0.08 }, 350)
                .easing(TWEEN.Easing.Quadratic.InOut)
                .start();
        }, 550);

        // === PHASE 4: Bring up new mag (850-1150ms) ===
        setTimeout(() => {
            // Reset mag pivot and show new mag coming from below
            sniperMagPivot.visible = true;
            sniperMagPivot.rotation.set(-0.8, 0, -0.2);
            sniperMagPivot.position.y = magOrigY - 0.4;

            // Weapon lifts back up to receive mag
            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ y: origPos.y + 0.1, x: origPos.x - 0.12, z: origPos.z + 0.05 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sniperRecoilGroup.rotation)
                .to({ z: 0.6, x: 0.25, y: Math.PI + 0.05 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            // Mag rotates into position
            new TWEEN.Tween(sniperMagPivot.rotation)
                .to({ x: -0.2, z: 0 }, 280)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sniperMagPivot.position)
                .to({ y: magOrigY - 0.15 }, 280)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }, 900);

        // === PHASE 5: Seat magazine with satisfying click (1150-1400ms) ===
        setTimeout(() => {
            // Final mag insertion - quick and precise
            new TWEEN.Tween(sniperMagPivot.position)
                .to({ y: magOrigY }, 120)
                .easing(TWEEN.Easing.Back.Out)
                .onComplete(() => {
                    playSound('mag_in');
                    Springs.recoilZ.impulse(-3);
                    Springs.recoilX.impulse(-2);

                    // Mag settles with slight bounce
                    new TWEEN.Tween(sniperMagPivot.rotation)
                        .to({ x: 0.15, z: 0 }, 80)
                        .easing(TWEEN.Easing.Elastic.Out)
                        .start();
                })
                .start();

            // Weapon reacts to mag insertion
            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ y: origPos.y + 0.05 }, 120)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }, 1200);

        // === PHASE 6: Charging handle slap (1350-1550ms) ===
        setTimeout(() => {
            // Quick tap on weapon to chamber round
            new TWEEN.Tween(sniperRecoilGroup.rotation)
                .to({ z: 0.25, x: 0.08, y: Math.PI }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ y: origPos.y + 0.02, z: origPos.z - 0.05 }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    playSound('rack');
                    Springs.recoilZ.impulse(-2);
                    Springs.recoilX.impulse(-1);
                })
                .start();
        }, 1350);

        // === PHASE 7: Return to ready (1550-1900ms) ===
        setTimeout(() => {
            // Smooth return to idle with slight overshoot
            new TWEEN.Tween(sniperRecoilGroup.rotation)
                .to({ z: 0, x: 0, y: Math.PI }, 350)
                .easing(TWEEN.Easing.Elastic.Out)
                .start();

            new TWEEN.Tween(sniperRecoilGroup.position)
                .to({ x: origPos.x, y: origPos.y, z: origPos.z }, 350)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    sniperAmmo = sniperMagSize;
                    isReloading = false;
                    updateHUD();
                })
                .start();
        }, 1500);

        return;
    }

    // Handle shotgun reload (shell-by-shell tactical reload) - ULTRA SATISFYING VERSION
    if (currentWeapon === 'shotgun') {
        // Can't reload if already full or currently pumping
        if (shotgunAmmo >= shotgunMagSize || isPumping) return;
        if (shotgunReserve <= 0) return;

        // If already reloading, let it continue (don't restart)
        if (isReloading) return;

        if (isAiming) isAiming = false;
        isReloading = true;
        updateHUD();

        const origPos = shotgunRecoilGroup.position.clone();
        const origRot = shotgunRecoilGroup.rotation.clone();
        const origPumpZ = sgPumpPivot.position.z; // Store original pump position
        const wasEmpty = shotgunAmmo === 0; // Track if we need to rack after reload

        // Calculate how many shells to load
        const shellsToLoad = Math.min(shotgunMagSize - shotgunAmmo, shotgunReserve);
        let shellsLoaded = 0;

        // Reload position constants (tilted to expose loading port)
        const reloadPos = {
            x: origPos.x - 0.25,
            y: origPos.y + 0.15,
            z: origPos.z + 0.2
        };
        const reloadRot = {
            x: 0.35,
            y: Math.PI + 0.15,
            z: 0.65
        };

        // === PHASE 1: DRAMATIC WEAPON LIFT & TILT ===
        function beginReload() {
            // Quick snap up - feel the weight
            ShotgunSprings.recoilZ.impulse(8);
            ShotgunSprings.momentumX.impulse(-15);

            // Bring weapon up and rotate to expose loading port
            new TWEEN.Tween(shotgunRecoilGroup.position)
                .to({
                    x: origPos.x - 0.1,
                    y: origPos.y + 0.25,
                    z: origPos.z - 0.1
                }, 180)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // Settle into reload position with satisfying drop
                    ShotgunSprings.stockKick.impulse(-5);
                    new TWEEN.Tween(shotgunRecoilGroup.position)
                        .to(reloadPos, 220)
                        .easing(TWEEN.Easing.Back.Out)
                        .start();
                })
                .start();

            new TWEEN.Tween(shotgunRecoilGroup.rotation)
                .to({ z: 0.3, x: 0.15, y: Math.PI + 0.08 }, 180)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // Final tilt with flourish
                    new TWEEN.Tween(shotgunRecoilGroup.rotation)
                        .to(reloadRot, 220)
                        .easing(TWEEN.Easing.Back.Out)
                        .onComplete(() => {
                            // Small settle bounce
                            ShotgunSprings.recoilTilt.impulse(2);
                            setTimeout(() => loadNextShell(), 80);
                        })
                        .start();
                })
                .start();
        }

        // === PHASE 2: SHELL LOADING LOOP ===
        function loadNextShell() {
            if (shellsLoaded >= shellsToLoad || !isReloading || currentWeapon !== 'shotgun') {
                finishReload();
                return;
            }

            // Variation for natural feel
            const variation = (Math.random() - 0.5) * 0.02;
            const shellIndex = shellsLoaded;

            // === REACH FOR SHELL (hand motion simulation) ===
            // Weapon drops slightly as hand reaches for belt/shell holder
            const dropAmount = 0.08 + Math.random() * 0.03;

            new TWEEN.Tween(shotgunRecoilGroup.position)
                .to({
                    y: reloadPos.y - dropAmount,
                    z: reloadPos.z + 0.05
                }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            // Subtle rotation as hand moves
            new TWEEN.Tween(shotgunRecoilGroup.rotation)
                .to({
                    z: reloadRot.z + 0.08,
                    x: reloadRot.x - 0.05
                }, 100)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();

            ShotgunSprings.swayX.impulse(3 + Math.random() * 2);

            // === BRING SHELL TO LOADING PORT ===
            setTimeout(() => {
                // Weapon rises as shell approaches
                new TWEEN.Tween(shotgunRecoilGroup.position)
                    .to({
                        y: reloadPos.y + 0.02,
                        x: reloadPos.x + 0.03,
                        z: reloadPos.z
                    }, 80)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                new TWEEN.Tween(shotgunRecoilGroup.rotation)
                    .to({
                        z: reloadRot.z - 0.05,
                        x: reloadRot.x + 0.03
                    }, 80)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();

                // === INSERT SHELL - THE SATISFYING PART ===
                setTimeout(() => {
                    // Quick push motion
                    new TWEEN.Tween(shotgunRecoilGroup.position)
                        .to({
                            y: reloadPos.y + 0.06,
                            z: reloadPos.z - 0.04
                        }, 50)
                        .easing(TWEEN.Easing.Quadratic.In)
                        .start();

                    // Pump jiggles from impact
                    new TWEEN.Tween(sgPumpPivot.position)
                        .to({ z: origPumpZ + 0.15 }, 30)
                        .easing(TWEEN.Easing.Quadratic.Out)
                        .chain(
                            new TWEEN.Tween(sgPumpPivot.position)
                                .to({ z: origPumpZ }, 40)
                                .easing(TWEEN.Easing.Quadratic.In)
                        )
                        .start();

                    // Shell click sound
                    playSound('shellLoad');

                    // Spring impulses for CHUNKY feel
                    ShotgunSprings.recoilZ.impulse(-4);
                    ShotgunSprings.stockKick.impulse(-8);
                    ShotgunSprings.recoilTilt.impulse(3 + variation * 50);

                    // === SHELL SEATS - SATISFYING CLICK ===
                    setTimeout(() => {
                        // Weapon settles back with bounce
                        new TWEEN.Tween(shotgunRecoilGroup.position)
                            .to({
                                y: reloadPos.y,
                                x: reloadPos.x,
                                z: reloadPos.z
                            }, 100)
                            .easing(TWEEN.Easing.Elastic.Out)
                            .start();

                        new TWEEN.Tween(shotgunRecoilGroup.rotation)
                            .to(reloadRot, 100)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // Subtle bounce springs
                        ShotgunSprings.recoilY.impulse(-2);
                        ShotgunSprings.foreEndZ.impulse(-3);

                        // Update ammo
                        shotgunAmmo++;
                        shotgunReserve--;
                        shellsLoaded++;
                        updateHUD();

                        // Rhythm pause - slightly longer on last shell for anticipation
                        const isLastShell = shellsLoaded >= shellsToLoad;
                        const pauseTime = isLastShell ? 150 : (120 + Math.random() * 40);

                        setTimeout(() => {
                            if (isReloading && currentWeapon === 'shotgun') {
                                loadNextShell();
                            }
                        }, pauseTime);
                    }, 45);
                }, 70);
            }, 90);
        }

        // === PHASE 3: FINISH RELOAD - RETURN TO READY ===
        function finishReload() {
            // If was empty, need to rack a shell into the chamber
            if (wasEmpty && shotgunAmmo > 0) {
                // === EPIC PUMP RACK FINISH ===
                // First, return to more neutral position
                new TWEEN.Tween(shotgunRecoilGroup.rotation)
                    .to({ z: 0.15, x: 0.1, y: Math.PI }, 200)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .start();

                new TWEEN.Tween(shotgunRecoilGroup.position)
                    .to({
                        x: origPos.x - 0.1,
                        y: origPos.y + 0.05,
                        z: origPos.z + 0.15
                    }, 200)
                    .easing(TWEEN.Easing.Quadratic.InOut)
                    .onComplete(() => {
                        // === PUMP PULL - AGGRESSIVE ===
                        playSound('pumpPull');

                        // Hand grabs pump and YANKS back
                        new TWEEN.Tween(sgPumpPivot.position)
                            .to({ z: origPumpZ + 1.4 }, 100)
                            .easing(TWEEN.Easing.Cubic.Out)
                            .start();

                        // Weapon kicks back from pump force (Boosted for Mass 1.5)
                        ShotgunSprings.recoilZ.impulse(-35);
                        ShotgunSprings.stockKick.impulse(25);
                        ShotgunSprings.foreEndZ.impulse(-45);

                        // Screen shake on pump pull
                        Springs.shakeX.impulse((Math.random() - 0.5) * 8);
                        Springs.shakeY.impulse(-4);

                        new TWEEN.Tween(shotgunRecoilGroup.position)
                            .to({ z: origPos.z + 0.25 }, 100)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        new TWEEN.Tween(shotgunRecoilGroup.rotation)
                            .to({ x: -0.08 }, 100)
                            .easing(TWEEN.Easing.Quadratic.Out)
                            .start();

                        // === PUMP PUSH - SLAM HOME ===
                        setTimeout(() => {
                            playSound('pumpPush');

                            // SLAM pump forward
                            new TWEEN.Tween(sgPumpPivot.position)
                                .to({ z: origPumpZ }, 80)
                                .easing(TWEEN.Easing.Cubic.In)
                                .start();

                            // Weapon snaps forward (Boosted for Mass 1.5)
                            ShotgunSprings.recoilZ.impulse(-20);
                            ShotgunSprings.stockKick.impulse(40);
                            ShotgunSprings.foreEndZ.impulse(30);

                            // SATISFYING screen shake on slam
                            Springs.shakeX.impulse((Math.random() - 0.5) * 10);
                            Springs.shakeY.impulse(6);
                            Springs.shakeRoll.impulse((Math.random() - 0.5) * 2);

                            new TWEEN.Tween(shotgunRecoilGroup.position)
                                .to({ z: origPos.z - 0.05 }, 80)
                                .easing(TWEEN.Easing.Quadratic.In)
                                .start();

                            new TWEEN.Tween(shotgunRecoilGroup.rotation)
                                .to({ x: 0.05 }, 80)
                                .easing(TWEEN.Easing.Quadratic.In)
                                .start();

                            // === RETURN TO READY ===
                            setTimeout(() => {
                                returnToReady();
                            }, 100);
                        }, 130);
                    })
                    .start();
            } else {
                // No pump needed, just return smoothly
                returnToReady();
            }
        }

        function returnToReady() {
            // Satisfying return with slight overshoot
            ShotgunSprings.momentumZ.impulse(-8);
            ShotgunSprings.swayX.impulse(-5);

            new TWEEN.Tween(shotgunRecoilGroup.rotation)
                .to({ z: -0.05, x: -0.03, y: Math.PI }, 180)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // Final settle
                    new TWEEN.Tween(shotgunRecoilGroup.rotation)
                        .to({ z: 0, x: 0, y: Math.PI }, 150)
                        .easing(TWEEN.Easing.Quadratic.InOut)
                        .start();
                })
                .start();

            new TWEEN.Tween(shotgunRecoilGroup.position)
                .to({
                    x: origPos.x,
                    y: origPos.y - 0.03,
                    z: origPos.z - 0.05
                }, 180)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // Final position settle with bounce
                    new TWEEN.Tween(shotgunRecoilGroup.position)
                        .to({ x: origPos.x, y: origPos.y, z: origPos.z }, 150)
                        .easing(TWEEN.Easing.Elastic.Out)
                        .onComplete(() => {
                            isReloading = false;
                            updateHUD();
                            // Final satisfying spring settle
                            ShotgunSprings.recoilY.impulse(1);
                        })
                        .start();
                })
                .start();
        }

        // Start the reload sequence
        beginReload();
        return;
    }

    // AK-47 reload (original behavior)
    if (isReloading || ammo === 30) return;
    if (isAiming) isAiming = false;
    isReloading = true;
    updateHUD();

    // ANIMATION TWEENS
    // 1. Tilt Gun
    new TWEEN.Tween(recoilGroup.rotation)
        .to({ z: 0.8, x: 0.3 }, 300)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    // 2. Unlatch Mag (Fast)
    setTimeout(() => {
        playSound('mag_out');
        new TWEEN.Tween(magPivot.rotation)
            .to({ x: 1.5 }, 200)
            .easing(TWEEN.Easing.Back.In)
            .onComplete(() => {
                // 3. Drop
                dropMag();
                magPivot.visible = false;
                Springs.bobY.impulse(-2);
            })
            .start();

        // 4. Insert New Mag
        setTimeout(() => {
            magPivot.visible = true;
            magPivot.rotation.x = 0;
            magPivot.position.y = -4;

            new TWEEN.Tween(magPivot.position)
                .to({ y: -0.5 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // 5. Lock In
                    playSound('mag_in');
                    Springs.recoilX.impulse(-2);
                    Springs.roll.impulse(-0.2);

                    // 6. Rack Bolt
                    setTimeout(() => {
                        playSound('rack');
                        new TWEEN.Tween(bolt.position).to({ z: 0.5 }, 100).easing(TWEEN.Easing.Cubic.Out).start();
                        Springs.recoilZ.impulse(2);

                        setTimeout(() => {
                            new TWEEN.Tween(bolt.position).to({ z: -0.5 }, 80).easing(TWEEN.Easing.Exponential.In).start();
                            Springs.recoilZ.impulse(-5);

                            // 7. Return to Idle
                            new TWEEN.Tween(recoilGroup.rotation)
                                .to({ z: 0, x: 0 }, 400)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();

                            ammo = 30; // Infinite reserve, always full reload
                            isReloading = false;
                            updateHUD();
                        }, 150);
                    }, 200);
                })
                .start();
        }, 300);
    }, 250);
}

// Input
const keys = {};
document.addEventListener('keydown', (e) => {
    // ESC to pause/unpause
    if (e.code === 'Escape') {
        if (!isGameOver) togglePause();
        return;
    }

    // Don't process other keys when paused
    if (isPaused) return;

    keys[e.code] = true;
    if (e.code === 'KeyR') reload();
    if (e.code === 'KeyW') moveState.f = true;
    if (e.code === 'KeyS') moveState.b = true;
    if (e.code === 'KeyA') moveState.l = true;
    if (e.code === 'KeyD') moveState.r = true;
    if (e.code === 'ShiftLeft') moveState.sprint = true;
    if (e.code === 'Space') {
        if (isGrounded && canJump) {
            // First jump
            verticalVelocity = jumpForce;
            isGrounded = false;
            canJump = false;
            // Slight upward weapon motion on jump
            Springs.bobY.impulse(-1.5);
        } else if (!isGrounded && hasDoubleJump) {
            // Double jump - can override downward velocity
            verticalVelocity = doubleJumpForce;
            hasDoubleJump = false;
            // More dramatic feedback for double jump
            Springs.bobY.impulse(-2.0);
            Springs.roll.impulse((Math.random() - 0.5) * 0.1);
            playSound('doubleJump');
        }
    }
    // Weapon switching
    if (e.code === 'Digit1') switchWeapon('ak');
    if (e.code === 'Digit2') switchWeapon('sniper');
    if (e.code === 'Digit3') switchWeapon('shotgun');
    // Kick
    if (e.code === 'KeyV') kick();

    // Slide - press C while sprinting
    if (e.code === 'KeyC') {
        const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
        if (isSprinting && !isSliding && slideCooldown <= 0) {
            startSlide();
        }
    }
});

// Pause menu button handlers
document.getElementById('resume-btn')?.addEventListener('click', resumeGame);
document.getElementById('restart-btn')?.addEventListener('click', () => {
    resumeGame();
    restartGame();
});

// Mouse wheel for weapon switching (3-weapon cycle)
const weaponOrder = ['ak', 'sniper', 'shotgun'];
document.addEventListener('wheel', (e) => {
    if (document.pointerLockElement !== document.body) return;
    const currentIdx = weaponOrder.indexOf(currentWeapon);
    if (e.deltaY > 0) {
        // Scroll down - next weapon
        const nextIdx = (currentIdx + 1) % weaponOrder.length;
        switchWeapon(weaponOrder[nextIdx]);
    } else if (e.deltaY < 0) {
        // Scroll up - previous weapon
        const prevIdx = (currentIdx - 1 + weaponOrder.length) % weaponOrder.length;
        switchWeapon(weaponOrder[prevIdx]);
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (e.code === 'KeyW') moveState.f = false;
    if (e.code === 'KeyS') moveState.b = false;
    if (e.code === 'KeyA') moveState.l = false;
    if (e.code === 'KeyD') moveState.r = false;
    if (e.code === 'ShiftLeft') moveState.sprint = false;
    if (e.code === 'Space') canJump = true;
});
document.addEventListener('mousedown', (e) => {
    // Don't start game if clicking on audio controls
    if (e.target.closest('.audio-settings') || e.target.closest('.audio-slider')) {
        return;
    }

    if (document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
        document.getElementById('blocker').style.display = 'none';
        const mainMenu = document.getElementById('main-menu');
        if (mainMenu) {
            mainMenu.style.opacity = '0';
            mainMenu.style.transition = 'opacity 0.5s ease-out';
            setTimeout(() => { mainMenu.style.display = 'none'; }, 500);
        }
    } else {
        if(e.button === 0) isFiring = true;
        if(e.button === 2) isAiming = true;
    }
});
document.addEventListener('mouseup', (e) => {
    if(e.button === 0) isFiring = false;
    if(e.button === 2) isAiming = false;
});

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        // Reject abnormally large mouse deltas (prevents 180-flip glitch on focus/pointer lock changes)
        const MAX_DELTA = 150;
        let mx = e.movementX;
        let my = e.movementY;
        if (Math.abs(mx) > MAX_DELTA || Math.abs(my) > MAX_DELTA) {
            return; // Skip this frame entirely - it's a glitched input
        }

        const sens = isAiming ? 0.001 : 0.002;
        cameraYaw -= mx * sens;
        cameraPitch -= my * sens;
        cameraPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraPitch));

        // Keep yaw in reasonable range to prevent floating point issues
        if (cameraYaw > Math.PI * 4) cameraYaw -= Math.PI * 2;
        if (cameraYaw < -Math.PI * 4) cameraYaw += Math.PI * 2;

        // ULTRA FLUID Procedural Sway - multi-layered organic response
        const adsReduction = isAiming ? 0.4 : 1.0;

        // Primary sway - immediate response
        const swayAmount = 0.0025 * adsReduction;
        Springs.swayX.target = -mx * swayAmount;
        Springs.swayY.target = -my * swayAmount;

        // Roll with horizontal look - weapon tilts into turns
        const rollAmount = 0.005 * adsReduction;
        Springs.roll.target = -mx * rollAmount;

        // Tilt on vertical look - weapon dips/rises with view
        Springs.tilt.target += my * 0.0004 * adsReduction;

        // Secondary lag layers get impulses for organic trailing
        const moveSpeed = Math.sqrt(mx * mx + my * my);
        if (moveSpeed > 2) {
            Springs.swayLagX.impulse(-mx * 0.0008 * adsReduction);
            Springs.swayLagY.impulse(-my * 0.0008 * adsReduction);
            Springs.swayLag2X.impulse(-mx * 0.0004 * adsReduction);
            Springs.swayLag2Y.impulse(-my * 0.0004 * adsReduction);
        }

        // Fast movements add extra roll momentum
        if (Math.abs(mx) > 8) {
            Springs.roll.impulse(-mx * 0.0003 * adsReduction);
        }

        // Motion blur from camera rotation - more subtle
        motionBlurX = Math.min(0.012, Math.abs(mx) * 0.0004) * Math.sign(mx);
        motionBlurY = Math.min(0.008, Math.abs(my) * 0.0004) * Math.sign(my);
    }
});

function animate(time) {
    requestAnimationFrame(animate);

    // Track time even when paused to avoid dt spike on resume
    const realDt = Math.min((time - prevTime) / 1000, 0.1); // Cap dt
    prevTime = time;

    // When paused, just render the scene and return
    if (isPaused) {
        composer.render();
        return;
    }

    TWEEN.update(time); // TWEEN uses real time for reliable reload/swap animations
    const dt = realDt * timeScale; // Apply slow-motion to physics
    frameCount++;

    // Update slow-motion system (uses real time, not scaled)
    updateSlowmo(realDt);

    // Update kick cooldown
    if (kickCooldown > 0) kickCooldown -= realDt;

    // Throttled shadow updates (increased interval for performance)
    if (frameCount % (SHADOW_UPDATE_INTERVAL * 2) === 0) {
        renderer.shadowMap.needsUpdate = true;
    }

    // ADS Logic + Sprint FOV (weapon-specific)
    const isSniper = currentWeapon === 'sniper';
    const isShotgun = currentWeapon === 'shotgun';
    const activeRecoilGroup = isSniper ? sniperRecoilGroup : (isShotgun ? shotgunRecoilGroup : recoilGroup);
    const activeHipPos = isSniper ? sniperHipPos : (isShotgun ? shotgunHipPos : hipPos);
    const activeAimPos = isSniper ? sniperAimPos : (isShotgun ? shotgunAimPos : aimPos);
    const targetPos = isAiming ? activeAimPos : activeHipPos;
    const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded && !isSliding;

    // Weapon-specific FOV when scoped/aimed
    const baseFOV = 90;
    const sprintFOV = 100;
    const slideFOV = 105; // Even wider FOV during slide for speed feel
    const akAimFOV = 55;
    const sniperAimFOV = baseFOV / scopeZoomLevel; // 4x zoom = 22.5 FOV
    const shotgunAimFOV = 65; // Shotgun has less zoom - more situational awareness
    const targetFOV = isAiming ? (isSniper ? sniperAimFOV : (isShotgun ? shotgunAimFOV : akAimFOV)) :
                      (isSliding ? slideFOV : (isSprinting ? sprintFOV : baseFOV));

    // === NEW: ULTRA-FLUID TRANSITION EFFECTS ===
    if (isAiming && !lastIsAiming) {
        // Entering ADS
        if (isSniper) {
            // Sniper zoom punch - deliberate and powerful
            Springs.adsFov.impulse(-25); // STRONGER snap forward for better feel
            Springs.shakeY.impulse(3.5); // More pronounced jolt
            Springs.tilt.impulse(2.5); // Bracing for shot - tilt forward
            Springs.roll.impulse(1.2); // Slight organic roll
            chromaticAmount = 0.012; // Deeper lens distortion peak
            motionBlurY = 1.2; // Vertical zoom blur spike
            playSound('zoomIn');
        } else {
            // General ADS snap
            Springs.adsFov.impulse(-8);
            motionBlurY = 0.4;
        }
    } else if (!isAiming && lastIsAiming) {
        // Exiting ADS
        Springs.adsFov.impulse(isSniper ? 8 : 3); // Elastic snap back
        playSound('zoomOut');
    }
    lastIsAiming = isAiming;

    // Smooth transition for base position (Lerp is fine for macroscopic movements)
    activeRecoilGroup.position.lerp(targetPos, 15 * dt);
    
    // Spring-driven FOV for ultra-fluid sniper zoom
    Springs.adsFov.target = targetFOV;
    currentFOV = Springs.adsFov.update(dt);
    
    camera.fov = currentFOV;
    camera.updateProjectionMatrix();

    // Handle scope overlay for sniper
    const scopeOverlay = document.getElementById('scope-overlay');
    if (scopeOverlay) {
        if (isSniper && isAiming && currentFOV < 40) {
            scopeOverlay.classList.add('active');
            // Hide the sniper model when fully scoped
            sniperGroup.visible = currentFOV > 30;
        } else {
            scopeOverlay.classList.remove('active');
            if (isSniper) sniperGroup.visible = true;
        }
    }

    // Hide crosshair when aiming (always for sniper scope)
    crosshair.style.opacity = isAiming ? 0 : 1;

    // Track camera velocity for inertia
    camVelX = (cameraYaw - lastCamYaw) / Math.max(dt, 0.001);
    camVelY = (cameraPitch - lastCamPitch) / Math.max(dt, 0.001);
    lastCamYaw = cameraYaw;
    lastCamPitch = cameraPitch;

    // Update ALL Springs - Enhanced organic motion
    const recoilZ = Springs.recoilZ.update(dt);
    const recoilX = Springs.recoilX.update(dt);
    const recoilY = Springs.recoilY.update(dt);
    const recoilRoll = Springs.recoilRoll.update(dt);
    const recoilRecoverZ = Springs.recoilRecoverZ.update(dt);
    const recoilRecoverX = Springs.recoilRecoverX.update(dt);
    const swayX = Springs.swayX.update(dt);
    const swayY = Springs.swayY.update(dt);
    const swayLagX = Springs.swayLagX.update(dt);
    const swayLagY = Springs.swayLagY.update(dt);
    const swayLag2X = Springs.swayLag2X.update(dt);
    const swayLag2Y = Springs.swayLag2Y.update(dt);
    const bobY = Springs.bobY.update(dt);
    const bobX = Springs.bobX.update(dt);
    const bobZ = Springs.bobZ.update(dt);
    const roll = Springs.roll.update(dt);
    const tilt = Springs.tilt.update(dt);
    const breathe = Springs.breathe.update(dt);
    const idleSway = Springs.idleSway.update(dt);
    const heartbeat = Springs.heartbeat.update(dt);
    const momentumX = Springs.momentumX.update(dt);
    const momentumZ = Springs.momentumZ.update(dt);
    const shakeX = Springs.shakeX.update(dt);
    const shakeY = Springs.shakeY.update(dt);
    const shakeRoll = Springs.shakeRoll.update(dt);
    const camLagX = Springs.camLagX.update(dt);
    const camLagY = Springs.camLagY.update(dt);
    const adsTransition = Springs.adsTransition.update(dt);
    const sprintBob = Springs.sprintBob.update(dt);
    const sprintTilt = Springs.sprintTilt.update(dt);
    const sprintRoll = Springs.sprintRoll.update(dt);
    const landingTilt = Springs.landingTilt.update(dt);

    // === NEW: Attention to Detail Spring Updates ===
    const strafeTilt = Springs.strafeTilt.update(dt);
    const strafeRoll = Springs.strafeRoll.update(dt);
    const velocityDragX = Springs.velocityDragX.update(dt);
    const velocityDragY = Springs.velocityDragY.update(dt);
    const turnLagX = Springs.turnLagX.update(dt);
    const turnLagY = Springs.turnLagY.update(dt);
    const inspectRotX = Springs.inspectRotX.update(dt);
    const inspectRotY = Springs.inspectRotY.update(dt);
    const inspectRotZ = Springs.inspectRotZ.update(dt);
    const boltZ = Springs.boltZ.update(dt);
    const crosshairSpread = Springs.crosshairSpread.update(dt);

    // === SNIPER-SPECIFIC SPRING UPDATES ===
    // Update all sniper springs (only affect sniper weapon)
    const sniperHeavyRecoilZ = SniperSprings.heavyRecoilZ.update(dt);
    const sniperHeavyRecoilX = SniperSprings.heavyRecoilX.update(dt);
    const sniperHeavyRecoilY = SniperSprings.heavyRecoilY.update(dt);
    const sniperHeavyRecoilRoll = SniperSprings.heavyRecoilRoll.update(dt);
    const sniperStockCompress = SniperSprings.stockCompress.update(dt);
    const sniperStockRotate = SniperSprings.stockRotate.update(dt);
    const sniperScopeShakeX = SniperSprings.scopeShakeX.update(dt);
    const sniperScopeShakeY = SniperSprings.scopeShakeY.update(dt);
    const sniperScopeSettleX = SniperSprings.scopeSettleX.update(dt);
    const sniperScopeSettleY = SniperSprings.scopeSettleY.update(dt);
    const sniperBarrelDroop = SniperSprings.barrelDroop.update(dt);
    const sniperHeavySwayX = SniperSprings.heavySwayX.update(dt);
    const sniperHeavySwayY = SniperSprings.heavySwayY.update(dt);
    const sniperHeavyMomentumX = SniperSprings.heavyMomentumX.update(dt);
    const sniperHeavyMomentumZ = SniperSprings.heavyMomentumZ.update(dt);
    const sniperScopedBreath = SniperSprings.scopedBreath.update(dt);
    const sniperRecoveryZ = SniperSprings.recoveryZ.update(dt);
    const sniperRecoveryX = SniperSprings.recoveryX.update(dt);

    // Sniper bolt springs
    const sniperBoltRotate = SniperSprings.boltRotate.update(dt);
    const sniperBoltPull = SniperSprings.boltPull.update(dt);
    const sniperBoltPush = SniperSprings.boltPush.update(dt);
    const sniperBoltDown = SniperSprings.boltDown.update(dt);

    // === SHOTGUN-SPECIFIC SPRING UPDATES ===
    const shotgunRecoilZ = ShotgunSprings.recoilZ.update(dt);
    const shotgunRecoilX = ShotgunSprings.recoilX.update(dt);
    const shotgunRecoilY = ShotgunSprings.recoilY.update(dt);
    const shotgunRecoilRoll = ShotgunSprings.recoilRoll.update(dt);
    const shotgunRecoilTilt = ShotgunSprings.recoilTilt.update(dt);
    const shotgunStockKick = ShotgunSprings.stockKick.update(dt);
    const shotgunStockRotate = ShotgunSprings.stockRotate.update(dt);
    const shotgunPumpPull = ShotgunSprings.pumpPull.update(dt);
    const shotgunPumpPush = ShotgunSprings.pumpPush.update(dt);
    const shotgunPumpRotate = ShotgunSprings.pumpRotate.update(dt);
    const shotgunSwayX = ShotgunSprings.swayX.update(dt);
    const shotgunSwayY = ShotgunSprings.swayY.update(dt);
    const shotgunMomentumX = ShotgunSprings.momentumX.update(dt);
    const shotgunMomentumZ = ShotgunSprings.momentumZ.update(dt);
    const shotgunShellEject = ShotgunSprings.shellEject.update(dt);
    const shotgunRecoveryZ = ShotgunSprings.recoveryZ.update(dt);
    const shotgunRecoveryX = ShotgunSprings.recoveryX.update(dt);
    const shotgunBarrelDroop = ShotgunSprings.barrelDroop.update(dt);
    const shotgunForeEndZ = ShotgunSprings.foreEndZ.update(dt);
    const shotgunForeEndRotate = ShotgunSprings.foreEndRotate.update(dt);

    // === SLIDE SPRING UPDATES ===
    const slideY = Springs.slideY.update(dt);
    const slideTilt = Springs.slideTilt.update(dt);
    const slideRoll = Springs.slideRoll.update(dt);
    Springs.slideFOV.update(dt); // Update but don't store - FOV handled separately

    // Organic idle animations using layered noise
    const idleAnimTime = time * 0.001;
    const breatheWave = organicNoise(idleAnimTime, 0.8, 2) * 0.012;
    const idleSwayWave = organicNoise(idleAnimTime + 100, 0.3, 3) * 0.008;
    const microTremor = organicNoise(idleAnimTime * 3, 2.5, 2) * 0.002;

    Springs.breathe.target = breatheWave;
    Springs.idleSway.target = idleSwayWave;
    Springs.heartbeat.target = Math.sin(idleAnimTime * 1.2) * 0.003; // Subtle pulse

    // Feed camera velocity into multi-layer lag springs for organic weapon inertia
    Springs.swayLagX.target = swayX * 0.7;
    Springs.swayLagY.target = swayY * 0.7;
    Springs.swayLag2X.target = swayLagX * 0.6;
    Springs.swayLag2Y.target = swayLagY * 0.6;
    Springs.camLagX.target = -camVelX * 0.00025;
    Springs.camLagY.target = -camVelY * 0.00025;

    // Track movement for momentum-based weapon lag
    moveVelX = THREE.MathUtils.lerp(moveVelX, velocity.x, 0.08);
    moveVelZ = THREE.MathUtils.lerp(moveVelZ, velocity.z, 0.08);
    Springs.momentumX.target = -moveVelX * 0.003;
    Springs.momentumZ.target = -moveVelZ * 0.002;

    // === NEW: Strafe Tilt - Weapon leans into strafe direction ===
    const strafeInput = Number(moveState.r) - Number(moveState.l);
    if (strafeInput !== 0 && !isAiming) {
        Springs.strafeTilt.target = strafeInput * 0.04;  // Lean into strafe
        Springs.strafeRoll.target = -strafeInput * 0.06; // Weapon roll opposite
        lastStrafeInput = strafeInput;
    } else {
        Springs.strafeTilt.target = 0;
        Springs.strafeRoll.target = 0;
    }

    // === NEW: Turn Inertia - Weapon trails behind fast camera turns ===
    const turnSpeed = Math.abs(camVelX) + Math.abs(camVelY);
    Springs.turnLagX.target = -camVelX * 0.0004;
    Springs.turnLagY.target = -camVelY * 0.0003;

    // === NEW: Velocity Drag - Weapon trails behind fast movement ===
    const moveSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
    Springs.velocityDragX.target = -moveVelX * 0.005;
    Springs.velocityDragY.target = Math.abs(moveVelZ) * 0.002; // Slight bounce when moving

    // === NEW: Weapon Inspection - After idle for 5+ seconds ===
    if (!isFiring && !isReloading && !isAiming && moveSpeed < 0.5 && turnSpeed < 50) {
        idleTime += dt;
        if (idleTime > 5.0 && !isInspecting) {
            isInspecting = true;
            inspectPhase = 0;
        }
    } else {
        idleTime = 0;
        isInspecting = false;
        Springs.inspectRotX.target = 0;
        Springs.inspectRotY.target = 0;
        Springs.inspectRotZ.target = 0;
    }

    if (isInspecting) {
        inspectPhase += dt * 0.5; // Slow inspection cycle
        // Subtle inspection animation - look at the weapon
        Springs.inspectRotX.target = Math.sin(inspectPhase) * 0.15;
        Springs.inspectRotY.target = Math.sin(inspectPhase * 0.7) * 0.1 + 0.1;
        Springs.inspectRotZ.target = Math.cos(inspectPhase * 0.5) * 0.08;
        // Reset after full cycle
        if (inspectPhase > Math.PI * 4) {
            isInspecting = false;
            inspectPhase = 0;
        }
    }

    // === NEW: Bolt Carrier Animation - Smooth return after firing ===
    Springs.boltZ.target = 0; // Always return to closed position
    bolt.position.z = boltZ; // Apply spring-driven bolt position

    // === NEW: Dynamic Crosshair Spread ===
    let crosshairTarget = crosshairBaseSize;
    if (isFiring) {
        crosshairTarget += 25; // Expand on fire
        crosshair.classList.add('firing');
    } else {
        crosshair.classList.remove('firing');
    }
    if (moveSpeed > 2) {
        crosshairTarget += moveSpeed * 2; // Expand when moving
        crosshair.classList.add('moving');
    } else {
        crosshair.classList.remove('moving');
    }
    if (!isGrounded) {
        crosshairTarget += 15; // Expand in air
    }
    if (isAiming) {
        crosshairTarget = 0; // Hidden when ADS
    }
    Springs.crosshairSpread.target = crosshairTarget;
    crosshairCurrentSize = crosshairSpread;
    if (!isAiming) {
        crosshair.style.width = crosshairCurrentSize + 'px';
        crosshair.style.height = crosshairCurrentSize + 'px';
    }

    // === NEW: Low Health Visual Effects ===
    const lowHealthVignette = document.getElementById('low-health-vignette');
    if (lowHealthVignette) {
        if (playerHealth <= 30) {
            lowHealthPulse += dt * (1 + (30 - playerHealth) / 15); // Faster pulse at lower health
            const pulseIntensity = Math.max(0, 1 - playerHealth / 30);
            lowHealthVignette.style.opacity = 0.3 + Math.sin(lowHealthPulse * 3) * 0.2 * pulseIntensity;
            if (playerHealth <= 20) {
                lowHealthVignette.classList.add('pulse');
            } else {
                lowHealthVignette.classList.remove('pulse');
            }
        } else {
            lowHealthVignette.style.opacity = 0;
            lowHealthVignette.classList.remove('pulse');
            lowHealthPulse = 0;
        }
    }

    // === NEW: Damage Direction Indicator Fade ===
    if (damageIndicatorAlpha > 0) {
        damageIndicatorAlpha -= dt * 3; // Fade over ~0.33 seconds
        const arrows = document.querySelectorAll('.damage-arrow');
        arrows.forEach(a => a.style.opacity = 0);
        if (lastDamageDir && damageIndicatorAlpha > 0) {
            const arrow = document.querySelector('.damage-arrow.' + lastDamageDir);
            if (arrow) arrow.style.opacity = damageIndicatorAlpha;
        }
    }

    // Recoil recovery feeds into slower springs for organic settle
    Springs.recoilRecoverZ.target = recoilZ * 0.3;
    Springs.recoilRecoverX.target = recoilX * 0.3;

    // ADS smoothing
    Springs.adsTransition.target = isAiming ? 1 : 0;
    const adsAmount = adsTransition;
    const adsMultiplier = 1 - adsAmount * 0.6; // Reduce motion when ADS

    // Apply Springs to Gun - ULTRA FLUID layered organic motion
    // Position: recoil + bob + breathing + momentum + micro tremors + NEW effects
    const combinedRecoilZ = recoilZ + recoilRecoverZ * 0.5;
    const combinedRecoilX = recoilX + recoilRecoverX * 0.5;

    gunGroup.position.z = combinedRecoilZ * adsMultiplier + bobZ * adsMultiplier + breathe * 0.4 + momentumZ + velocityDragY;
    gunGroup.position.y = bobY * adsMultiplier + recoilY * adsMultiplier + breathe + heartbeat + microTremor + strafeTilt * 0.3;
    gunGroup.position.x = bobX * adsMultiplier + swayLag2X * 0.25 + momentumX + idleSway * 0.5 + velocityDragX + turnLagX;

    // Rotation: multi-layered sway + recoil + tilt + breathing + organic noise + NEW effects
    const totalSwayX = (swayX + swayLagX * 0.5 + swayLag2X * 0.3 + camLagX + turnLagX) * adsMultiplier;
    const totalSwayY = (swayY + swayLagY * 0.5 + swayLag2Y * 0.3 + camLagY + turnLagY) * adsMultiplier;

    gunGroup.rotation.x = combinedRecoilX * adsMultiplier + totalSwayY + tilt + breathe * 0.25 + landingTilt * 0.5 + sprintTilt + inspectRotX;
    gunGroup.rotation.y = Math.PI + totalSwayX + idleSway * 0.3 + strafeTilt + inspectRotY;
    gunGroup.rotation.z = (roll + recoilRoll) * adsMultiplier + totalSwayX * 0.35 + breathe * 0.15 + sprintRoll + microTremor * 2 + strafeRoll + inspectRotZ;

    // === SNIPER-SPECIFIC TRANSFORMS - Heavy, deliberate, powerful ===
    if (currentWeapon === 'sniper') {
        // Combine sniper recoil with recovery for slow, weighty return
        const sniperCombinedRecoilZ = sniperHeavyRecoilZ + sniperRecoveryZ * 0.3 + sniperStockCompress * 0.5;
        const sniperCombinedRecoilX = sniperHeavyRecoilX + sniperRecoveryX * 0.3 + sniperStockRotate * 0.4 + sniperBarrelDroop;

        // Sniper sway - heavier, more sluggish (high mass springs)
        const sniperTotalSwayX = (sniperHeavySwayX + sniperScopeSettleX + turnLagX * 1.5) * adsMultiplier;
        const sniperTotalSwayY = (sniperHeavySwayY + sniperScopeSettleY + turnLagY * 1.5) * adsMultiplier;

        // Scope shake layer (faster, jittery, separate from body)
        const scopeJitterX = (sniperScopeShakeX + sniperScopeSettleX) * 0.015;
        const scopeJitterY = (sniperScopeShakeY + sniperScopeSettleY) * 0.015;

        // Scoped breathing is more exaggerated
        const scopedBreathAmount = isAiming ? sniperScopedBreath * 2 : breathe;

        // Position: VIOLENT recoil jolt + sluggish momentum + breathing
        sniperGroup.position.z = sniperCombinedRecoilZ * adsMultiplier * 0.18 + // MUCH more backward jolt
                                  sniperHeavyMomentumZ * 0.25 +
                                  bobZ * adsMultiplier * 0.6 +
                                  scopedBreathAmount * 0.3;
        sniperGroup.position.y = sniperHeavyRecoilY * adsMultiplier * 0.15 + // More vertical jump
                                  bobY * adsMultiplier * 0.5 +
                                  scopedBreathAmount +
                                  heartbeat * 0.5 +
                                  microTremor * 0.5;
        sniperGroup.position.x = sniperHeavyMomentumX * 0.2 +
                                  bobX * adsMultiplier * 0.5 +
                                  sniperTotalSwayX * 0.4 +
                                  idleSway * 0.3 +
                                  scopeJitterX * 1.5; // More scope jitter visible

        // Rotation: BRUTAL muzzle snap + roll + scope shake
        sniperGroup.rotation.x = sniperCombinedRecoilX * adsMultiplier * 0.14 + // Much more muzzle flip
                                  sniperTotalSwayY * 0.8 +
                                  tilt * 0.7 +
                                  scopedBreathAmount * 0.2 +
                                  landingTilt * 0.3 +
                                  scopeJitterY * 1.5;
        sniperGroup.rotation.y = Math.PI + sniperTotalSwayX +
                                  idleSway * 0.2 +
                                  strafeTilt * 0.7;
        sniperGroup.rotation.z = (roll * 0.7 + sniperHeavyRecoilRoll * 0.18) * adsMultiplier + // More rotational kick
                                  sniperTotalSwayX * 0.25 +
                                  scopedBreathAmount * 0.1 +
                                  sprintRoll * 0.7 +
                                  microTremor +
                                  strafeRoll * 0.8;

        // Sniper spring target resets - slow decay to neutral
        SniperSprings.heavyRecoilZ.target = 0;
        SniperSprings.heavyRecoilX.target = 0;
        SniperSprings.heavyRecoilY.target = 0;
        SniperSprings.heavyRecoilRoll.target = 0;
        SniperSprings.stockCompress.target = 0;
        SniperSprings.stockRotate.target = 0;
        SniperSprings.scopeShakeX.target = 0;
        SniperSprings.scopeShakeY.target = 0;
        SniperSprings.scopeSettleX.target = 0;
        SniperSprings.scopeSettleY.target = 0;
        SniperSprings.barrelDroop.target = 0;
        SniperSprings.heavyMomentumX.target = -moveVelX * 0.008; // Heavier trailing
        SniperSprings.heavyMomentumZ.target = -moveVelZ * 0.006;

        // Heavy sway targets - weapon lags behind camera more
        SniperSprings.heavySwayX.target = -camVelX * 0.0008;
        SniperSprings.heavySwayY.target = -camVelY * 0.0006;

        // Scoped breathing amplification
        if (isAiming) {
            SniperSprings.scopedBreath.target = breatheWave * 2.5;
        } else {
            SniperSprings.scopedBreath.target = 0;
        }
    }

    // === SHOTGUN-SPECIFIC TRANSFORMS - Punchy, aggressive, weighty ===
    if (currentWeapon === 'shotgun') {
        // Combine shotgun recoil with recovery
        const sgCombinedRecoilZ = shotgunRecoilZ + shotgunRecoveryZ * 0.35 + shotgunStockKick * 0.4;
        const sgCombinedRecoilX = shotgunRecoilX + shotgunRecoveryX * 0.35 + shotgunStockRotate * 0.35 + shotgunBarrelDroop;

        // Shotgun sway - medium weight
        const sgTotalSwayX = (shotgunSwayX + turnLagX * 1.2) * adsMultiplier;
        const sgTotalSwayY = (shotgunSwayY + turnLagY * 1.2) * adsMultiplier;

        // Position: VIOLENT recoil + momentum
        shotgunGroup.position.z = sgCombinedRecoilZ * adsMultiplier * 0.35 +
                                   shotgunMomentumZ * 0.3 +
                                   bobZ * adsMultiplier * 0.7 +
                                   shotgunForeEndZ * 0.08; // Pump motion affects whole gun slightly
        shotgunGroup.position.y = shotgunRecoilY * adsMultiplier * 0.28 +
                                   bobY * adsMultiplier * 0.6 +
                                   breathe * 0.8 +
                                   heartbeat * 0.4 +
                                   microTremor * 0.4;
        shotgunGroup.position.x = shotgunMomentumX * 0.25 +
                                   bobX * adsMultiplier * 0.6 +
                                   sgTotalSwayX * 0.35 +
                                   idleSway * 0.25;

        // Rotation: AGGRESSIVE muzzle snap + roll
        shotgunGroup.rotation.x = sgCombinedRecoilX * adsMultiplier * 0.28 +
                                   sgTotalSwayY * 0.7 +
                                   tilt * 0.6 +
                                   breathe * 0.2 +
                                   landingTilt * 0.4 +
                                   shotgunRecoilTilt * 0.18;
        shotgunGroup.rotation.y = Math.PI + sgTotalSwayX +
                                   idleSway * 0.25 +
                                   strafeTilt * 0.8;
        shotgunGroup.rotation.z = (roll * 0.8 + shotgunRecoilRoll * 0.25) * adsMultiplier +
                                   sgTotalSwayX * 0.2 +
                                   breathe * 0.08 +
                                   sprintRoll * 0.8 +
                                   microTremor +
                                   strafeRoll * 0.9;

        // Shotgun spring target resets
        ShotgunSprings.recoilZ.target = 0;
        ShotgunSprings.recoilX.target = 0;
        ShotgunSprings.recoilY.target = 0;
        ShotgunSprings.recoilRoll.target = 0;
        ShotgunSprings.recoilTilt.target = 0;
        ShotgunSprings.stockKick.target = 0;
        ShotgunSprings.stockRotate.target = 0;
        ShotgunSprings.barrelDroop.target = 0;
        ShotgunSprings.momentumX.target = -moveVelX * 0.006;
        ShotgunSprings.momentumZ.target = -moveVelZ * 0.005;
        ShotgunSprings.swayX.target = -camVelX * 0.0006;
        ShotgunSprings.swayY.target = -camVelY * 0.0005;
        ShotgunSprings.foreEndZ.target = 0;
        ShotgunSprings.foreEndRotate.target = 0;
    }

    // Reset Spring Targets (decay to neutral)
    Springs.swayX.target = 0;
    Springs.swayY.target = 0;
    Springs.roll.target = 0;
    Springs.tilt.target = 0;
    Springs.recoilZ.target = 0;
    Springs.recoilX.target = 0;
    Springs.recoilY.target = 0;
    Springs.recoilRoll.target = 0;
    Springs.bobX.target = 0;
    Springs.bobZ.target = 0;
    Springs.sprintBob.target = 0;
    Springs.sprintTilt.target = 0;
    Springs.sprintRoll.target = 0;
    Springs.landingTilt.target = 0;
    Springs.slideY.target = 0;
    Springs.slideTilt.target = 0;
    Springs.slideRoll.target = 0;
    Springs.slideFOV.target = 0;

    // Camera Recoil Recovery + Screen Shake - more organic + strafe lean + slide tilt
    cameraRecoil = THREE.MathUtils.lerp(cameraRecoil, 0, 0.08); // Slower recovery
    camera.rotation.set(
        cameraPitch + cameraRecoil + shakeY * 0.018 + breathe * 0.1 + slideTilt * 0.5, // Add slide forward tilt
        cameraYaw + shakeX * 0.018,
        (roll + shakeRoll) * 0.08 + strafeTilt * 0.5 + slideRoll * 0.3, // Add slide roll wobble
        'YXZ'
    );

    // FLUID Movement (disabled during game over)
    if (document.pointerLockElement === document.body && !isGameOver) {
        // Update slide cooldown
        if (slideCooldown > 0) {
            slideCooldown -= dt;
        }

        // === SLIDE SYSTEM UPDATE ===
        if (isSliding) {
            slideTimer -= dt;

            // Smooth deceleration - starts fast, gently slows (keeps momentum feel)
            const slideProgress = 1 - (slideTimer / slideDuration);
            // Use smoothstep for natural deceleration curve
            const smoothProgress = slideProgress * slideProgress * (3 - 2 * slideProgress);
            const currentSlideSpeed = slideSpeed * (1 - smoothProgress * slideDeceleration / 2);

            // Update spring targets for active slide
            const cameraDropProgress = Math.sin(slideProgress * Math.PI); // Smooth rise and fall
            Springs.slideY.target = slideCameraDropMax * cameraDropProgress;
            Springs.slideTilt.target = 0.2 * (1 - smoothProgress); // Lean forward, ease out
            Springs.slideFOV.target = 5 * (1 - smoothProgress); // FOV boost

            // Subtle oscillation for ground scraping feel
            const slideWobble = Math.sin(slideTimer * 20) * 0.015 * (1 - smoothProgress);
            Springs.slideRoll.target = slideWobble;

            // Weapon animation during slide
            Springs.bobY.target = -1.2 * cameraDropProgress;
            Springs.tilt.target = 0.12 * (1 - smoothProgress);
            Springs.momentumZ.target = 1.5 * (1 - smoothProgress);

            // Apply slide movement (overrides normal movement)
            const oldX = camera.position.x;
            const oldZ = camera.position.z;
            const slideX = slideDirection.x * currentSlideSpeed * dt;
            const slideZ = slideDirection.z * currentSlideSpeed * dt;

            // Allow slight steering during slide (25% control)
            const rIn = Number(moveState.r) - Number(moveState.l);
            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
            const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
            const steerX = rgt.x * rIn * currentSlideSpeed * 0.25 * dt;
            const steerZ = rgt.z * rIn * currentSlideSpeed * 0.25 * dt;

            const finalX = oldX + slideX + steerX;
            const finalZ = oldZ + slideZ + steerZ;

            // Collision detection during slide
            const playerRadius = 0.5;
            const resolved = resolveCollision(oldX, oldZ, finalX, finalZ, playerRadius);
            camera.position.x = resolved.x;
            camera.position.z = resolved.z;

            // Push zombies out of the way while sliding
            for (const zombie of zombies) {
                if (zombie.isDead || zombie.isKnockedBack) continue;

                const zombiePos = zombie.mesh.position;
                const dx = zombiePos.x - camera.position.x;
                const dz = zombiePos.z - camera.position.z;
                const dist = Math.sqrt(dx * dx + dz * dz);

                if (dist < SLIDE_PUSH_RANGE && dist > 0.1) {
                    // Push direction - away from player along slide direction + outward
                    const pushX = dx / dist;
                    const pushZ = dz / dist;

                    // Blend slide direction with outward push for satisfying scatter
                    const blendedX = slideDirection.x * 0.6 + pushX * 0.4;
                    const blendedZ = slideDirection.z * 0.6 + pushZ * 0.4;
                    const blendMag = Math.sqrt(blendedX * blendedX + blendedZ * blendedZ);

                    const knockDir = new THREE.Vector3(
                        blendedX / blendMag,
                        0.25, // Slight upward pop
                        blendedZ / blendMag
                    ).normalize();

                    // Apply knockback (clone so knockDir stays normalized for gore)
                    zombie.knockbackVel = knockDir.clone().multiplyScalar(SLIDE_PUSH_KNOCKBACK);
                    zombie.isKnockedBack = true;
                    zombie.knockbackTime = 0.5;

                    // Light damage
                    zombie.health -= SLIDE_PUSH_DAMAGE;

                    // Stagger animation
                    zombie.mesh.rotation.x = -0.3;

                    // Hit feedback
                    if (typeof showHitmarker === 'function') showHitmarker(false);

                    // Check for kill - use proper die() for ragdoll physics
                    if (zombie.health <= 0 && !zombie.isDead) {
                        zombie.die();
                    }
                }
            }

            // End slide
            if (slideTimer <= 0) {
                isSliding = false;
                slideCooldown = slideCooldownTime;

                // Recovery spring impulses - snap back up
                Springs.slideY.impulse(-slideCameraDropMax * 1.2);
                Springs.slideTilt.impulse(-0.1);
                Springs.bobY.impulse(1.0);
                Springs.landingTilt.impulse(0.05);

                // Transfer remaining momentum to normal velocity (high transfer for smooth exit)
                const exitSpeed = currentSlideSpeed * 0.7; // Keep 70% of slide speed
                velocity.z = slideDirection.dot(fwd) * exitSpeed;
                velocity.x = slideDirection.dot(rgt) * exitSpeed;
            }
        } else {
            // === NORMAL MOVEMENT ===
            // Smoother deceleration for fluid feel
            const friction = isGrounded ? 8.0 : 3.0;
            velocity.x -= velocity.x * friction * dt;
            velocity.z -= velocity.z * friction * dt;

            const fIn = Number(moveState.f) - Number(moveState.b);
            const rIn = Number(moveState.r) - Number(moveState.l);

            // Sprinting logic - only when moving forward and not aiming
            const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
            const speedMultiplier = speedBoostTimer > 0 ? speedBoostMultiplier : 1;
            const currentSpeed = (isAiming ? baseSpeed * 0.5 : (isSprinting ? baseSpeed * sprintMultiplier : baseSpeed)) * speedMultiplier;

            // Smoother acceleration
            const accel = isGrounded ? 12.0 : 4.0;
            if (moveState.f || moveState.b) velocity.z += fIn * currentSpeed * accel * dt;
            if (moveState.l || moveState.r) velocity.x += rIn * currentSpeed * accel * dt;

            const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
            const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();

            // Store old position for collision resolution
            const oldX = camera.position.x;
            const oldZ = camera.position.z;

            // Calculate new position
            const newX = oldX + rgt.x * velocity.x * dt;
            const newZ = oldZ + rgt.z * velocity.x * dt;
            const finalX = newX + fwd.x * velocity.z * dt;
            const finalZ = newZ + fwd.z * velocity.z * dt;

            // Apply collision detection and resolution (player radius ~0.5)
            const playerRadius = 0.5;
            const resolved = resolveCollision(oldX, oldZ, finalX, finalZ, playerRadius);
            camera.position.x = resolved.x;
            camera.position.z = resolved.z;
        }

        // Calculate dynamic ground level based on terrain height at player position
        const terrainY = getTerrainHeight(camera.position.x, camera.position.z);
        currentGroundLevel = terrainY + 5; // Eye level is 5 units above terrain

        // Apply slide camera drop
        const slideCameraDrop = slideY;

        // ULTRA FLUID Jump physics
        if (!isGrounded) {
            verticalVelocity -= gravity * dt;
            playerHeight += verticalVelocity * dt;

            // Organic airborne weapon drift
            const airTime = Math.abs(verticalVelocity) / gravity; // Approximate time in air

            // Weapon tilts based on vertical velocity - rising vs falling feels different
            if (verticalVelocity > 0) {
                // Rising - weapon tips back slightly
                Springs.tilt.target = verticalVelocity * 0.008;
                Springs.bobY.target = -verticalVelocity * 0.004;
                Springs.bobZ.target = verticalVelocity * 0.003; // Weapon pulls back
            } else {
                // Falling - weapon tips forward, bracing for landing
                Springs.tilt.target = verticalVelocity * 0.012;
                Springs.bobY.target = -verticalVelocity * 0.006;
                Springs.bobZ.target = verticalVelocity * 0.002;
                // Pre-brace roll
                Springs.roll.target = Math.sin(playerHeight * 2) * 0.02;
            }

            // Subtle floating sway while airborne
            Springs.swayX.target += Math.sin(time * 0.003) * 0.005;
            Springs.idleSway.target = Math.cos(time * 0.002) * 0.01;

            // Landing - check against dynamic ground level
            if (playerHeight <= currentGroundLevel) {
                playerHeight = currentGroundLevel;
                const landingImpact = Math.abs(verticalVelocity);
                verticalVelocity = 0;
                isGrounded = true;
                hasDoubleJump = true; // Reset double jump on landing

                // ORGANIC landing effect based on fall speed
                if (landingImpact > 2) {
                    const impactScale = Math.min(landingImpact / 15, 1); // Normalize

                    // Main landing dip
                    Springs.landing.impulse(landingImpact * 0.25);

                    // Weapon drops and recovers
                    Springs.bobY.impulse(-landingImpact * 0.15);
                    Springs.bobZ.impulse(landingImpact * 0.08); // Weapon punches forward

                    // Tilt forward on impact
                    Springs.landingTilt.impulse(landingImpact * 0.025);
                    Springs.tilt.impulse(landingImpact * 0.015);

                    // Asymmetric roll for organic feel
                    Springs.roll.impulse((Math.random() - 0.4) * landingImpact * 0.025);

                    // Recoil springs add to the chaos
                    Springs.recoilY.impulse(-landingImpact * 0.08);

                    // Screen shake on harder landings
                    if (landingImpact > 6) {
                        Springs.shakeY.impulse(-landingImpact * 0.5);
                        Springs.shakeX.impulse((Math.random() - 0.5) * landingImpact * 0.25);
                        Springs.shakeRoll.impulse((Math.random() - 0.5) * landingImpact * 0.15);
                    }
                }
            }
        }

        // Apply landing spring
        const landingOffset = Springs.landing.update(dt);
        Springs.landing.target = 0;

        // When grounded, smoothly follow terrain height (for walking up/down hill)
        if (isGrounded) {
            playerHeight = THREE.MathUtils.lerp(playerHeight, currentGroundLevel, 0.15);
        }

        // Set camera Y position (base + jump height - landing dip - slide drop)
        camera.position.y = playerHeight - landingOffset * 0.1 - slideCameraDrop;

        // ULTRA FLUID Procedural Bobbing (Walking/Sprinting)
        const vLen = Math.sqrt(velocity.x*velocity.x + velocity.z*velocity.z);
        moveVelSmooth = THREE.MathUtils.lerp(moveVelSmooth, vLen, 0.08); // Smoother velocity tracking
        const currentIsSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded && !isSliding;
        const bobSpeed = currentIsSprinting ? 0.016 : 0.011;
        const bobIntensity = currentIsSprinting ? 0.1 : 0.06;
        const velRatio = Math.min(moveVelSmooth / baseSpeed, 1.5);

        if(moveVelSmooth > 0.1 && !isReloading && isGrounded) {
            // Phase offset for more natural gait
            const phase = time * bobSpeed;
            const phase2 = phase * 0.5;

            // Vertical bob - asymmetric for natural feel (footsteps aren't perfectly symmetric)
            const vertBob = Math.sin(phase) * 0.7 + Math.sin(phase * 2) * 0.3;
            Springs.bobY.target = vertBob * bobIntensity * velRatio;

            // Horizontal bob (side-to-side sway) - slower frequency
            const horizBob = Math.cos(phase2) + Math.sin(phase2 * 1.5) * 0.2;
            Springs.bobX.target = horizBob * bobIntensity * 0.35 * velRatio;

            // Forward/back bob - subtle push with each step
            Springs.bobZ.target = Math.sin(phase + 0.5) * bobIntensity * 0.2 * velRatio;

            // Hip sway rotation - figure-8 pattern for organic feel
            const hipSwayX = Math.cos(phase2) * 0.02 + Math.sin(phase * 0.7) * 0.008;
            Springs.swayX.target += hipSwayX * velRatio;

            // Roll with steps - asymmetric
            const stepRoll = Math.sin(phase) * 0.018 + Math.cos(phase * 1.3) * 0.006;
            Springs.roll.target += stepRoll * velRatio;

            // Forward tilt when moving - increases with speed
            Springs.tilt.target = -velRatio * 0.025;

            // Extra effects when sprinting - more dramatic
            if (currentIsSprinting) {
                // Exaggerated sprint bob
                Springs.sprintBob.target = Math.sin(phase * 1.2) * 0.08;
                Springs.bobY.target += Springs.sprintBob.position;

                // More aggressive roll
                Springs.sprintRoll.target = Math.sin(phase) * 0.035;

                // Strong forward lean
                Springs.sprintTilt.target = -0.055;
                Springs.tilt.target = -0.04;

                // Weapon pulls back slightly when sprinting
                Springs.bobZ.target -= 0.15;
            }
        } else if (isGrounded) {
            // Smooth return to idle
            Springs.bobY.target = 0;
            Springs.bobX.target = 0;
            Springs.bobZ.target = 0;
            Springs.tilt.target = 0;
        }
    }

    if (isFiring) shoot();

    // Decay Enhanced Flash
    if (flashCoreMat.opacity > 0.01) {
        flashCoreMat.opacity = Math.max(0, flashCoreMat.opacity - 0.25);
        flashMidMat.opacity = Math.max(0, flashMidMat.opacity - 0.2);
        flashOuterMat.opacity = Math.max(0, flashOuterMat.opacity - 0.15);
        flashStreakMat.opacity = Math.max(0, flashStreakMat.opacity - 0.2);
        muzzleLight.intensity = Math.max(0, muzzleLight.intensity - 4);
    } else {
        flashCoreMat.opacity = 0;
        flashMidMat.opacity = 0;
        flashOuterMat.opacity = 0;
        flashStreakMat.opacity = 0;
        muzzleLight.intensity = 0;
    }

    // Decay dynamic post-processing
    bloomIntensity = THREE.MathUtils.lerp(bloomIntensity, 0.12, 0.15);
    bloomPass.strength = bloomIntensity;
    
    // Dynamic chromatic aberration - pulses on shoot and zoom
    chromaticAmount = THREE.MathUtils.lerp(chromaticAmount, 0.0008, 0.1);
    if (chromaticPass && chromaticPass.uniforms) {
        chromaticPass.uniforms.amount.value = chromaticAmount;
    }

    // Update motion blur based on camera rotation velocity
    motionBlurX = THREE.MathUtils.lerp(motionBlurX, 0, 0.2);
    motionBlurY = THREE.MathUtils.lerp(motionBlurY, 0, 0.2);
    motionBlurPass.uniforms.velocityX.value = motionBlurX;
    motionBlurPass.uniforms.velocityY.value = motionBlurY;

    // Post-processing effects disabled for performance

    // Update sky shader time for animated clouds
    skyUniforms.time.value = time * 0.001;

    // Calculate sun screen position for god rays and lens flare
    const sunWorldPos = sun.position.clone();
    const sunScreenPosTemp = sunWorldPos.project(camera);
    sunScreenPos.set(
        (sunScreenPosTemp.x + 1) / 2,
        (sunScreenPosTemp.y + 1) / 2
    );

    // Check if sun is visible (in front of camera and on screen)
    const sunDir = sunWorldPos.clone().sub(camera.position).normalize();
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const sunDot = sunDir.dot(camDir);

    // Sun visibility based on angle and screen bounds
    sunVisible = sunDot > 0 &&
                 sunScreenPos.x > -0.3 && sunScreenPos.x < 1.3 &&
                 sunScreenPos.y > -0.3 && sunScreenPos.y < 1.3 ?
                 Math.pow(sunDot, 2) : 0;

    // God rays, lens flare, heat distortion disabled for performance

    // Reset screen shake targets
    Springs.shakeX.target = 0;
    Springs.shakeY.target = 0;
    
    // Bolt Recovery (Spring-ish)
    if (!isReloading && bolt.position.z < -0.5) bolt.position.z += 0.1;

    // Entity Updates - using swap-and-pop for O(1) removal
    // Shells
    for(let i = shells.length - 1; i >= 0; i--) {
        const s = shells[i];
        s.position.addScaledVector(s.userData.velocity, dt); // Fixed: removed * 60 multiplier
        s.userData.velocity.y -= 20 * dt; // Fixed: proper gravity (was 0.02 per frame, now 20 units/sec^2)
        s.rotation.x += 2 * dt; // Fixed: proper rotation speed
        if(s.position.y < -5) { s.position.y = -5; s.userData.velocity.set(0,0,0); }
        if(--s.userData.life <= 0) {
            scene.remove(s);
            shells[i] = shells[shells.length - 1];
            shells.pop();
        }
    }
    // Mags
    for(let i = mags.length - 1; i >= 0; i--) {
        const m = mags[i];
        m.position.addScaledVector(m.userData.vel, dt); // Fixed: removed * 60 multiplier
        m.rotation.x += m.userData.rot.x * dt; // Fixed: proper rotation speed
        m.userData.vel.y -= 20 * dt; // Fixed: proper gravity (was 0.02 per frame, now 20 units/sec^2)
        if(m.position.y < -5) { m.position.y = -5; m.userData.vel.set(0,0,0); }
        if(--m.userData.life <= 0) {
            scene.remove(m);
            mags[i] = mags[mags.length - 1];
            mags.pop();
        }
    }
    // Smoke particles with pooling
    for(let i = smokeParticles.length - 1; i >= 0; i--) {
        const s = smokeParticles[i];
        s.age += dt;
        const r = s.age / s.life;
        if(r >= 1) {
            scene.remove(s.mesh);
            smokePool.release(s.mesh);
            smokeParticles[i] = smokeParticles[smokeParticles.length - 1];
            smokeParticles.pop();
            continue;
        }
        s.mesh.position.addScaledVector(s.velocity, dt);
        if(s.hot) {
            s.mesh.scale.setScalar(0.3 + r * 1.5);
            s.mesh.material.opacity = 0.6 * (1 - r);
        } else {
            s.mesh.scale.setScalar(0.5 + r * 4);
            s.mesh.material.opacity = 0.5 * (1 - r);
        }
        s.velocity.y += 1.5 * dt;
        s.velocity.multiplyScalar(0.99);
    }

    // === NEW: Update muzzle smoke wisps ===
    updateMuzzleSmokeWisps(dt);

    // Sparks with pooling
    for(let i = sparks.length - 1; i >= 0; i--) {
        const sp = sparks[i];
        sp.userData.life -= dt;
        if(sp.userData.life <= 0) {
            scene.remove(sp);
            sparkPool.release(sp);
            sparks[i] = sparks[sparks.length - 1];
            sparks.pop();
            continue;
        }
        sp.position.addScaledVector(sp.userData.velocity, dt);
        sp.userData.velocity.y -= 20 * dt;
        sp.material.opacity = sp.userData.life * 3;
    }

    // Debris with pooling
    for(let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.userData.life -= dt; // Fixed: time-based instead of frame-based
        if(d.userData.life <= 0) {
            scene.remove(d);
            debrisPool.release(d);
            debris[i] = debris[debris.length - 1];
            debris.pop();
            continue;
        }
        d.position.addScaledVector(d.userData.velocity, dt);
        d.userData.velocity.y -= 15 * dt;
        d.rotation.x += d.userData.rotVel.x * dt;
        d.rotation.y += d.userData.rotVel.y * dt;
        d.rotation.z += d.userData.rotVel.z * dt;
        if(d.position.y < -4.9) {
            d.position.y = -4.9;
            d.userData.velocity.set(0, 0, 0);
            d.userData.rotVel.multiplyScalar(0.9);
        }
    }
    // Tracers
    for(let i = tracers.length - 1; i >= 0; i--) {
        const t = tracers[i];
        t.life -= dt; // Fixed: time-based instead of frame-based
        t.mesh.material.opacity = Math.max(0, t.life / 0.1); // Fixed: opacity based on time (0.1 seconds)
        if(t.life <= 0) {
            scene.remove(t.mesh);
            tracers[i] = tracers[tracers.length - 1];
            tracers.pop();
        }
    }
    // Decals
    for(let i = decals.length - 1; i >= 0; i--) {
        const d = decals[i];
        d.life -= dt; // Fixed: time-based instead of frame-based
        if(d.life < 1.0) d.mesh.material.opacity = d.life / 1.0; // Fixed: fade over last 1 second
        if(d.life <= 0) {
            scene.remove(d.mesh);
            decals[i] = decals[decals.length - 1];
            decals.pop();
        }
    }

    // Update shooting targets
    for (const target of shootingTargets) {
        target.update(dt);
    }

    // Update wave system (only if game is active)
    if (!isGameOver) {
        updateWaveSystem(dt);
        // updatePickups(dt, time); // DISABLED - power-ups removed
        updateDoors(dt);

        // Update power-up timers - DISABLED
        // if (speedBoostTimer > 0) {
        //     speedBoostTimer -= dt;
        //     if (speedBoostTimer <= 0) speedBoostTimer = 0;
        // }
        // if (damageBoostTimer > 0) {
        //     damageBoostTimer -= dt;
        //     if (damageBoostTimer <= 0) damageBoostTimer = 0;
        // }
        // if (rapidFireTimer > 0) {
        //     rapidFireTimer -= dt;
        //     if (rapidFireTimer <= 0) rapidFireTimer = 0;
        // }
        // if (infiniteAmmoTimer > 0) {
        //     infiniteAmmoTimer -= dt;
        //     if (infiniteAmmoTimer <= 0) infiniteAmmoTimer = 0;
        // }
        // if (explosiveRoundsTimer > 0) {
        //     explosiveRoundsTimer -= dt;
        //     if (explosiveRoundsTimer <= 0) explosiveRoundsTimer = 0;
        // }
        // if (penetratingRoundsTimer > 0) {
        //     penetratingRoundsTimer -= dt;
        //     if (penetratingRoundsTimer <= 0) penetratingRoundsTimer = 0;
        // }
        // if (shieldTimer > 0) {
        //     shieldTimer -= dt;
        //     if (shieldTimer <= 0) shieldTimer = 0;
        // }

        // Throttled HUD update (increased interval for performance)
        if (frameCount % (HUD_UPDATE_INTERVAL * 2) === 0) {
            updateHUD();
        }
    }

    // Update HiveMind (shared intelligence) - once per frame
    if (zombies.length > 0) {
        HiveMind.update(dt);
    }
    
    // Update all zombies every frame (no staggering - causes slow motion!)
    for (let i = 0; i < zombies.length; i++) {
        zombies[i].update(dt, time);
    }

    // Update blood and gore effects
    updateBloodEffects(dt);
    updateExplosions(dt);

    // Update damage flash
    if (damageFlashIntensity > 0) {
        damageFlashIntensity -= dt * 2;
        if (damageFlashIntensity < 0) damageFlashIntensity = 0;
        document.getElementById('damage-flash').style.opacity = damageFlashIntensity;
    }

    // Update kill multiplier decay
    if (killMultiplierTimer > 0) {
        killMultiplierTimer -= dt;
        updateMultiplierUI();

        if (killMultiplierTimer <= 0) {
            resetMultiplier();
        }
    }

    // Update score counting animation
    updateScoreDisplay();

    // Health regeneration system
    if (!isGameOver && playerHealth < maxPlayerHealth) {
        const timeSinceDamage = (performance.now() - lastDamageTime) / 1000;

        if (timeSinceDamage >= HEALTH_REGEN_DELAY) {
            // Start regenerating
            if (!isRegenerating) {
                isRegenerating = true;
                playRegenStartSound();
                setRegenUI(true);
            }

            // Regenerate health
            const oldHealth = playerHealth;
            playerHealth = Math.min(playerHealth + HEALTH_REGEN_RATE * dt, maxPlayerHealth);

            // Play tick sound periodically during regen
            if (Math.floor(oldHealth / 5) !== Math.floor(playerHealth / 5)) {
                playRegenTickSound();
            }

            updateHUD();

            // Stop regen when full
            if (playerHealth >= maxPlayerHealth) {
                isRegenerating = false;
                setRegenUI(false);
                playRegenCompleteSound();
            }
        } else {
            // Not enough time has passed
            if (isRegenerating) {
                isRegenerating = false;
                setRegenUI(false);
            }
        }
    } else if (isRegenerating) {
        // Player at max health or game over
        isRegenerating = false;
        setRegenUI(false);
    }

    // Animate dust particles (throttled to every 12 frames for better performance)
    if (frameCount % 12 === 0) {
        const dustPos = dustGeo.attributes.position.array;
        for(let i = 0; i < dustCount; i += 4) { // Process every 4th particle
            dustPos[i * 3 + 1] += Math.sin(time * 0.0002 + i) * 0.003; // Even slower movement
            const dx = dustPos[i * 3] - camera.position.x;
            const dz = dustPos[i * 3 + 2] - camera.position.z;
            if(Math.abs(dx) > 140) dustPos[i * 3] = camera.position.x + (Math.random() - 0.5) * 280;
            if(Math.abs(dz) > 140) dustPos[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 280;
        }
        dustGeo.attributes.position.needsUpdate = true;
    }

    // Render with post-processing
    composer.render();
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth / 2, window.innerHeight / 2); // Half resolution for performance
    // Update FXAA resolution
    const pr = renderer.getPixelRatio();
    fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * pr), 1 / (window.innerHeight * pr));
});

// Pre-cache all pickup meshes - DISABLED
// initPickupCache();

// Initialize HUD (force update all values)
updateHUD(true);

animate(performance.now());
</script>
</body>
</html>