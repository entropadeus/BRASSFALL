<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BRASSFALL</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.7); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            transition: width 0.1s, height 0.1s, opacity 0.2s;
        }
        #hitmarker {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            transform: translate(-50%, -50%); pointer-events: none;
            opacity: 0; transition: opacity 0.05s;
        }
        #hitmarker.show {
            opacity: 1;
        }
        .hm-line {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 2px;
            background: rgba(180, 180, 180, 0.5);
            transform-origin: center;
        }
        .hm-line:first-child {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        .hm-line:last-child {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        #hud {
            position: absolute; bottom: 20px; right: 20px; color: #0f0;
            font-size: 24px; pointer-events: none; user-select: none;
            text-shadow: 0 0 5px #0f0;
        }
        #controls {
            position: absolute; top: 20px; left: 20px; color: #888;
            font-size: 14px; pointer-events: none;
        }
        #blocker {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.8); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; cursor: pointer; z-index: 10;
        }
    </style>
</head>
<body>

<div id="blocker">
    <h1>BRASSFALL</h1>
    <p>Generating PBR Textures & Audio Buffers...</p>
    <p>Click to Capture Mouse</p>
    <p>WASD: Move | SHIFT: Sprint | SPACE: Jump | LMB: Shoot | RMB: Aim | R: Reload</p>
</div>
<div id="crosshair"></div>
<div id="hitmarker">
    <div class="hm-line"></div>
    <div class="hm-line"></div>
</div>
<div id="hud">30 / 90</div>
<div id="controls">
    Rendering: Post-Process Pipeline<br>
    Effects: Bloom / Vignette / Grain<br>
    Physics: Spring Animation System<br>
    Particles: Sparks / Smoke / Debris
</div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Post-processing -->
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<!-- TWEEN.js for complex curves -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * MOTION DESIGN UTILS
 * Spring physics for procedural weight.
 */
class Spring {
    constructor(stiffness, damping, mass) {
        this.stiffness = stiffness;
        this.damping = damping;
        this.mass = mass;
        this.position = 0;
        this.velocity = 0;
        this.target = 0;
    }

    update(dt) {
        const force = (this.target - this.position) * this.stiffness;
        const acc = force / this.mass;
        this.velocity = (this.velocity + acc * dt) * (1 - this.damping * dt); // Simple Euler
        this.position += this.velocity * dt;
        return this.position;
    }

    impulse(force) {
        this.velocity += force / this.mass;
    }
}

// Separate springs for different axes creates complex, organic motion
const Springs = {
    swayX: new Spring(150, 10, 1),
    swayY: new Spring(150, 10, 1),
    recoilZ: new Spring(300, 20, 1), // Tighter, harder kick (Stiffness 300)
    recoilX: new Spring(250, 15, 1), // Snappy muzzle climb (Stiffness 250)
    recoilY: new Spring(200, 15, 1), // Vertical damping
    bobY: new Spring(100, 8, 1),
    roll: new Spring(100, 10, 1),    // Movement roll
    // Screen shake springs
    shakeX: new Spring(400, 25, 1),
    shakeY: new Spring(400, 25, 1)
};

/**
 * CUSTOM POST-PROCESSING SHADERS
 */
const VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        intensity: { value: 0.4 },
        smoothness: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float intensity;
        uniform float smoothness;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 center = vUv - 0.5;
            float dist = length(center);
            float vignette = smoothstep(0.5, 0.5 - smoothness, dist * (intensity + 0.5));
            color.rgb *= vignette;
            gl_FragColor = color;
        }
    `
};

const ChromaticAberrationShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
    `
};

const FilmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.03 },
        speed: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        varying vec2 vUv;

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float grain = random(vUv + time) * 2.0 - 1.0;
            color.rgb += grain * intensity;
            gl_FragColor = color;
        }
    `
};

const MotionBlurShader = {
    uniforms: {
        tDiffuse: { value: null },
        velocityX: { value: 0.0 },
        velocityY: { value: 0.0 },
        samples: { value: 8 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float velocityX;
        uniform float velocityY;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 velocity = vec2(velocityX, velocityY);
            float speed = length(velocity);

            if (speed < 0.001) {
                gl_FragColor = texture2D(tDiffuse, vUv);
                return;
            }

            vec2 dir = velocity / speed;
            vec4 color = vec4(0.0);
            float total = 0.0;

            for (float i = 0.0; i < 16.0; i++) {
                if (i >= samples) break;
                float t = (i / (samples - 1.0)) - 0.5;
                vec2 offset = dir * t * speed;
                float weight = 1.0 - abs(t * 2.0);
                color += texture2D(tDiffuse, vUv + offset) * weight;
                total += weight;
            }

            gl_FragColor = color / total;
        }
    `
};

// Dynamic post-processing values
let bloomIntensity = 0.08;
let chromaticAmount = 0.0005;
let motionBlurX = 0.0;
let motionBlurY = 0.0;

/**
 * TEXTURE FACTORY
 */
const TextureFactory = {
    createCanvas: (size) => {
        const c = document.createElement('canvas');
        c.width = c.height = size;
        return { c, ctx: c.getContext('2d') };
    },
    
    noise: (ctx, w, h, opacity) => {
        const idata = ctx.getImageData(0,0,w,h);
        const data = idata.data;
        for(let i=0; i<data.length; i+=4) {
            const v = Math.random() * 255 * opacity;
            data[i] += v; data[i+1] += v; data[i+2] += v;
        }
        ctx.putImageData(idata, 0, 0);
    },

    wood: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.3;
        for(let i=0; i<150; i++) {
            ctx.strokeStyle = i%2===0 ? '#5d4037' : '#281a14';
            ctx.lineWidth = 1 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(0, Math.random()*size);
            ctx.bezierCurveTo(size/3, Math.random()*size, size*2/3, Math.random()*size, size, Math.random()*size);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.1);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    metal: (isDark) => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = isDark ? '#1a1a1a' : '#555555'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.1; ctx.strokeStyle = '#ffffff';
        for(let i=0; i<400; i++) {
            ctx.lineWidth = 0.5; ctx.beginPath();
            const x = Math.random()*size; const y = Math.random()*size;
            ctx.moveTo(x, y); ctx.lineTo(x + (Math.random()-0.5)*50, y + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.05);
        return new THREE.CanvasTexture(c);
    },

    concrete: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#888888'; ctx.fillRect(0,0,size,size);
        //Heavy noise for aggregate
        TextureFactory.noise(ctx, size, size, 0.4); 
        // Cracks
        ctx.strokeStyle = '#444444'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        for(let i=0; i<20; i++) {
             ctx.beginPath(); ctx.moveTo(Math.random()*size, Math.random()*size);
             for(let j=0; j<5; j++) ctx.lineTo(Math.random()*size, Math.random()*size);
             ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 20);
        return tex;
    },

    brick: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#301510'; ctx.fillRect(0,0,size,size); // Grout
        ctx.fillStyle = '#56302a'; // Brick color
        const brickW = 64; const brickH = 32;
        for(let y=0; y<size; y+=brickH+2) {
            const offset = (y/(brickH+2))%2 === 0 ? 0 : brickW/2;
            for(let x=-brickW; x<size; x+=brickW+2) {
                ctx.fillRect(x+offset, y, brickW, brickH);
            }
        }
        TextureFactory.noise(ctx, size, size, 0.2);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 5);
        return tex;
    },

    grid: () => {
        const size = 1024;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#080808'; ctx.fillRect(0,0,size,size); // Darker floor
        TextureFactory.noise(ctx, size, size, 0.2);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.globalAlpha = 1.0;
        const step = 128; // Bigger grid
        for(let i=0; i<=size; i+=step) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(size,i); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(50, 50);
        return tex;
    },

    // Procedural Bullet Hole
    impact: () => {
        const size = 128;
        const { c, ctx } = TextureFactory.createCanvas(size);
        // Alpha mask
        ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.clearRect(0,0,size,size);
        
        // Cracks
        ctx.beginPath();
        ctx.arc(64,64, 20, 0, Math.PI*2);
        ctx.fillStyle = '#050505'; ctx.fill();
        
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        for(let i=0; i<12; i++) {
            ctx.beginPath(); ctx.moveTo(64,64);
            ctx.lineTo(64 + Math.cos(i)*40 + (Math.random()-0.5)*10, 64 + Math.sin(i)*40 + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(c);
    }
};

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

// Improved Reverb
const convolver = actx.createConvolver();
const dryGain = actx.createGain();
const wetGain = actx.createGain();
dryGain.connect(actx.destination);
wetGain.connect(actx.destination);
wetGain.gain.value = 0.3; // Tighter reverb

const sampleRate = actx.sampleRate;
const length = sampleRate * 1.0; // Short, slap-back reverb
const impulse = actx.createBuffer(2, length, sampleRate);
for (let channel = 0; channel < 2; channel++) {
    const data = impulse.getChannelData(channel);
    for (let i = 0; i < length; i++) {
        // Exponential decay for metallic room sound
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 6);
    }
}
convolver.buffer = impulse;
convolver.connect(wetGain);

function playSound(type) {
    if (actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(dryGain);
    gain.connect(convolver);

    const now = actx.currentTime;

    if (type === 'shoot') {
        // Enhanced gunshot - layered sounds

        // Layer 1: Low thump (body)
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(20, now + 0.15);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        filter.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.2);

        // Layer 2: High crack
        const osc2 = actx.createOscillator();
        const gain2 = actx.createGain();
        const filter2 = actx.createBiquadFilter();
        osc2.connect(filter2); filter2.connect(gain2);
        gain2.connect(dryGain); gain2.connect(convolver);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(200, now);
        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.08);
        filter2.type = 'highpass';
        filter2.frequency.setValueAtTime(500, now);
        gain2.gain.setValueAtTime(0.5, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc2.start(now); osc2.stop(now + 0.1);

        // Layer 3: Noise burst (explosion)
        const nBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const out = nBuf.getChannelData(0);
        for (let i = 0; i < nBuf.length; i++) {
            const env = Math.exp(-i / (actx.sampleRate * 0.03));
            out[i] = (Math.random() * 2 - 1) * env;
        }
        const n = actx.createBufferSource(); n.buffer = nBuf;
        const nFilter = actx.createBiquadFilter();
        nFilter.type = 'bandpass';
        nFilter.frequency.setValueAtTime(2000, now);
        nFilter.Q.value = 1;
        const nG = actx.createGain();
        nG.gain.setValueAtTime(1.0, now);
        nG.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        n.connect(nFilter); nFilter.connect(nG);
        nG.connect(dryGain); nG.connect(convolver);
        n.start(now);

        // Layer 4: Mechanical click
        const osc3 = actx.createOscillator();
        const gain3 = actx.createGain();
        osc3.connect(gain3); gain3.connect(dryGain);
        osc3.type = 'square';
        osc3.frequency.setValueAtTime(1200, now + 0.02);
        gain3.gain.setValueAtTime(0.15, now + 0.02);
        gain3.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
        osc3.start(now + 0.02); osc3.stop(now + 0.05);

    } else if (type === 'targetHit') {
        // Metallic ping/clang for hitting target
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1000, now);
        filter.Q.value = 5;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add metallic noise
        const hitBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const hitOut = hitBuf.getChannelData(0);
        for (let i = 0; i < hitBuf.length; i++) hitOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.02));
        const hitN = actx.createBufferSource(); hitN.buffer = hitBuf;
        const hitG = actx.createGain();
        hitG.gain.setValueAtTime(0.3, now);
        hitG.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        hitN.connect(hitG); hitG.connect(dryGain);
        hitN.start(now);

    } else if (type === 'botHit') {
        // Fleshy impact sound for bot hits
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.1);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Thwack noise layer
        const thwackBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const thwackOut = thwackBuf.getChannelData(0);
        for (let i = 0; i < thwackBuf.length; i++) {
            thwackOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.015));
        }
        const thwackN = actx.createBufferSource(); thwackN.buffer = thwackBuf;
        const thwackFilter = actx.createBiquadFilter();
        thwackFilter.type = 'bandpass'; thwackFilter.frequency.value = 800; thwackFilter.Q.value = 1;
        const thwackG = actx.createGain();
        thwackG.gain.setValueAtTime(0.4, now);
        thwackN.connect(thwackFilter); thwackFilter.connect(thwackG);
        thwackG.connect(dryGain);
        thwackN.start(now);

    } else if (type === 'botDeath') {
        // Death grunt/thud
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.25);
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Body fall thud
        const thudOsc = actx.createOscillator();
        const thudGain = actx.createGain();
        thudOsc.connect(thudGain); thudGain.connect(dryGain); thudGain.connect(convolver);
        thudOsc.type = 'sine';
        thudOsc.frequency.setValueAtTime(80, now + 0.15);
        thudOsc.frequency.exponentialRampToValueAtTime(30, now + 0.35);
        thudGain.gain.setValueAtTime(0.6, now + 0.15);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        thudOsc.start(now + 0.15); thudOsc.stop(now + 0.45);

    } else if (type === 'empty') {
        osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    } else if (type === 'mag_out') {
        // Magazine release click
        osc.type = 'square';
        osc.frequency.setValueAtTime(2500, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.02);
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
        osc.start(now); osc.stop(now + 0.04);

        // Metal slide sound
        const slideOsc = actx.createOscillator();
        const slideGain = actx.createGain();
        const slideFilter = actx.createBiquadFilter();
        slideOsc.connect(slideFilter); slideFilter.connect(slideGain);
        slideGain.connect(dryGain); slideGain.connect(convolver);
        slideOsc.type = 'sawtooth';
        slideOsc.frequency.setValueAtTime(400, now + 0.02);
        slideOsc.frequency.linearRampToValueAtTime(150, now + 0.12);
        slideFilter.type = 'bandpass';
        slideFilter.frequency.value = 800;
        slideFilter.Q.value = 2;
        slideGain.gain.setValueAtTime(0.25, now + 0.02);
        slideGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        slideOsc.start(now + 0.02); slideOsc.stop(now + 0.15);

        // Metallic rattle noise
        const rattleBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const rattleOut = rattleBuf.getChannelData(0);
        for (let i = 0; i < rattleBuf.length; i++) {
            rattleOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.03)) * Math.sin(i * 0.3);
        }
        const rattleN = actx.createBufferSource(); rattleN.buffer = rattleBuf;
        const rattleFilter = actx.createBiquadFilter();
        rattleFilter.type = 'highpass';
        rattleFilter.frequency.value = 2000;
        const rattleG = actx.createGain();
        rattleG.gain.setValueAtTime(0.2, now + 0.03);
        rattleN.connect(rattleFilter); rattleFilter.connect(rattleG);
        rattleG.connect(dryGain);
        rattleN.start(now + 0.03);

    } else if (type === 'mag_in') {
        // Heavy metallic clunk - magazine seating

        // Initial impact
        osc.type = 'sine';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Sharp click
        const clickOsc = actx.createOscillator();
        const clickGain = actx.createGain();
        clickOsc.connect(clickGain); clickGain.connect(dryGain);
        clickOsc.type = 'square';
        clickOsc.frequency.setValueAtTime(3000, now);
        clickOsc.frequency.exponentialRampToValueAtTime(1500, now + 0.015);
        clickGain.gain.setValueAtTime(0.4, now);
        clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
        clickOsc.start(now); clickOsc.stop(now + 0.03);

        // Metal resonance
        const resOsc = actx.createOscillator();
        const resGain = actx.createGain();
        const resFilter = actx.createBiquadFilter();
        resOsc.connect(resFilter); resFilter.connect(resGain);
        resGain.connect(dryGain); resGain.connect(convolver);
        resOsc.type = 'triangle';
        resOsc.frequency.setValueAtTime(450, now);
        resOsc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        resFilter.type = 'bandpass';
        resFilter.frequency.value = 600;
        resFilter.Q.value = 8;
        resGain.gain.setValueAtTime(0.2, now + 0.01);
        resGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        resOsc.start(now + 0.01); resOsc.stop(now + 0.18);

        // Latch snap
        const snapBuf = actx.createBuffer(1, actx.sampleRate * 0.03, actx.sampleRate);
        const snapOut = snapBuf.getChannelData(0);
        for (let i = 0; i < snapBuf.length; i++) snapOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.005));
        const snapN = actx.createBufferSource(); snapN.buffer = snapBuf;
        const snapFilter = actx.createBiquadFilter();
        snapFilter.type = 'highpass'; snapFilter.frequency.value = 3000;
        const snapG = actx.createGain();
        snapG.gain.setValueAtTime(0.35, now);
        snapN.connect(snapFilter); snapFilter.connect(snapG); snapG.connect(dryGain);
        snapN.start(now);

    } else if (type === 'rack') {
        // Bolt/charging handle - metallic slide and slam

        // Slide back - scraping metal
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.08);
        filter.type = 'bandpass';
        filter.frequency.value = 1200;
        filter.Q.value = 3;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Metal scrape noise
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const env = Math.exp(-i / (actx.sampleRate * 0.04));
            scrapeOut[i] = (Math.random() * 2 - 1) * env * (0.5 + 0.5 * Math.sin(i * 0.05));
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 2500; scrapeFilter.Q.value = 2;
        const scrapeG = actx.createGain();
        scrapeG.gain.setValueAtTime(0.25, now);
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain); scrapeG.connect(convolver);
        scrapeN.start(now);

        // Bolt slam forward
        const slamOsc = actx.createOscillator();
        const slamGain = actx.createGain();
        slamOsc.connect(slamGain); slamGain.connect(dryGain); slamGain.connect(convolver);
        slamOsc.type = 'square';
        slamOsc.frequency.setValueAtTime(120, now + 0.1);
        slamOsc.frequency.exponentialRampToValueAtTime(40, now + 0.18);
        slamGain.gain.setValueAtTime(0.5, now + 0.1);
        slamGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        slamOsc.start(now + 0.1); slamOsc.stop(now + 0.2);

        // Sharp impact click
        const impactOsc = actx.createOscillator();
        const impactGain = actx.createGain();
        impactOsc.connect(impactGain); impactGain.connect(dryGain);
        impactOsc.type = 'square';
        impactOsc.frequency.setValueAtTime(4000, now + 0.1);
        impactOsc.frequency.exponentialRampToValueAtTime(1000, now + 0.12);
        impactGain.gain.setValueAtTime(0.35, now + 0.1);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.13);
        impactOsc.start(now + 0.1); impactOsc.stop(now + 0.15);

        // Metal ring after slam
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(800, now + 0.11);
        ringFilter.type = 'bandpass'; ringFilter.frequency.value = 800; ringFilter.Q.value = 15;
        ringGain.gain.setValueAtTime(0.15, now + 0.11);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        ringOsc.start(now + 0.11); ringOsc.stop(now + 0.4);
    }
}

/**
 * SCENE SETUP
 */
const scene = new THREE.Scene();
// Procedural Skybox (Bright Sunny Day)
const vertexShader = `
varying vec3 vWorldPosition;
void main() {
    vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
    vWorldPosition = worldPosition.xyz;
    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`;
const fragmentShader = `
uniform vec3 topColor;
uniform vec3 bottomColor;
uniform float offset;
uniform float exponent;
varying vec3 vWorldPosition;
void main() {
    float h = normalize( vWorldPosition + offset ).y;
    gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );
}`;
const uniforms = {
    topColor: { value: new THREE.Color(0x0077ff) }, // Azure Blue
    bottomColor: { value: new THREE.Color(0xffffff) }, // White Horizon
    offset: { value: 33 },
    exponent: { value: 0.6 }
};
const skyGeo = new THREE.SphereGeometry(500, 32, 15);
const skyMat = new THREE.ShaderMaterial({ vertexShader, fragmentShader, uniforms, side: THREE.BackSide });
const sky = new THREE.Mesh(skyGeo, skyMat);
scene.add(sky);

// Atmospheric fog with depth
scene.fog = new THREE.FogExp2(0xddeeff, 0.008);

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.1;
document.body.appendChild(renderer.domElement);

// POST-PROCESSING SETUP
const composer = new THREE.EffectComposer(renderer);
const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// Bloom for muzzle flash glow
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth, window.innerHeight),
    0.08,  // strength
    0.2,   // radius
    0.92   // threshold
);
composer.addPass(bloomPass);

// Motion Blur
const motionBlurPass = new THREE.ShaderPass(MotionBlurShader);
composer.addPass(motionBlurPass);

// Chromatic Aberration
const chromaticPass = new THREE.ShaderPass(ChromaticAberrationShader);
composer.addPass(chromaticPass);

// Film Grain
const grainPass = new THREE.ShaderPass(FilmGrainShader);
composer.addPass(grainPass);

// Create environment map for reflections
const envMapSize = 256;
const envMapCanvas = document.createElement('canvas');
envMapCanvas.width = envMapCanvas.height = envMapSize;
const envCtx = envMapCanvas.getContext('2d');
const envGrad = envCtx.createLinearGradient(0, 0, 0, envMapSize);
envGrad.addColorStop(0, '#0077ff');
envGrad.addColorStop(0.5, '#aaddff');
envGrad.addColorStop(1, '#ffffff');
envCtx.fillStyle = envGrad;
envCtx.fillRect(0, 0, envMapSize, envMapSize);
const envMapTex = new THREE.CanvasTexture(envMapCanvas);
envMapTex.mapping = THREE.EquirectangularReflectionMapping;

const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
scene.add(ambientLight);

// Hemisphere light for better ambient
const hemiLight = new THREE.HemisphereLight(0x88ccff, 0x444422, 0.4);
scene.add(hemiLight);

const dirLight = new THREE.DirectionalLight(0xffffee, 1.8); // Strong Sun
dirLight.position.set(50, 80, 30);
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; dirLight.shadow.bias = -0.0001;
// Increase shadow frustum to cover the larger bright map
dirLight.shadow.camera.left = -100;
dirLight.shadow.camera.right = 100;
dirLight.shadow.camera.top = 100;
dirLight.shadow.camera.bottom = -100;
scene.add(dirLight);

// Subtle blue fill from sky
const rimLight = new THREE.DirectionalLight(0x4466ff, 0.3);
rimLight.position.set(-5, 2, -5);
scene.add(rimLight);

const muzzleLight = new THREE.PointLight(0xffaa00, 0, 20);
muzzleLight.castShadow = false;
scene.add(muzzleLight);

// Secondary fill light that follows camera for gun visibility
const gunFillLight = new THREE.PointLight(0xffffff, 0.3, 10);
gunFillLight.position.set(0, 0, 0);
camera.add(gunFillLight);

// Initialize textures FIRST so they are available for everything
const concreteTex = TextureFactory.concrete();
const brickTex = TextureFactory.brick();
const woodTex = TextureFactory.wood();
const metalTexDark = TextureFactory.metal(true);
const metalTexLight = TextureFactory.metal(false);

// Concrete Floor (Bright)
const floorMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, 
    color: 0xdddddd, // Light grey
    roughness: 0.8, 
    metalness: 0.1,
    bumpMap: concreteTex,
    bumpScale: 0.05
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), floorMat);
floor.rotation.x = -Math.PI / 2; floor.position.y = -5; floor.receiveShadow = true;
scene.add(floor);

// Walls (Concrete/Light Brick)
const wallMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, // Switched to concrete to match photo style
    color: 0xbbbbbb,
    roughness: 0.9, 
    bumpMap: concreteTex, 
    bumpScale: 0.1 
});
const wallGeo = new THREE.PlaneGeometry(400, 50);
const wall1 = new THREE.Mesh(wallGeo, wallMat); wall1.position.set(0, 20, -200); wall1.receiveShadow = true; scene.add(wall1);
const wall2 = new THREE.Mesh(wallGeo, wallMat); wall2.position.set(0, 20, 200); wall2.rotation.y = Math.PI; wall2.receiveShadow = true; scene.add(wall2);
const wall3 = new THREE.Mesh(wallGeo, wallMat); wall3.position.set(-200, 20, 0); wall3.rotation.y = Math.PI/2; wall3.receiveShadow = true; scene.add(wall3);
const wall4 = new THREE.Mesh(wallGeo, wallMat); wall4.position.set(200, 20, 0); wall4.rotation.y = -Math.PI/2; wall4.receiveShadow = true; scene.add(wall4);

const targets = [];
targets.push(floor, wall1, wall2, wall3, wall4);

// Better Obstacles
const barrierMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
const drumMat = new THREE.MeshStandardMaterial({ map: metalTexDark, roughness: 0.4, metalness: 0.8, color: 0x553333 });
// Wood crates like the photo
const crateMat = new THREE.MeshStandardMaterial({ map: woodTex, color: 0x886644, roughness: 0.7 });
const obstacles = []; // Store obstacle references for target placement

for(let i=0; i<30; i++) {
    let mesh;
    const r = Math.random();
    if(r > 0.6) {
        // Wooden Crate
        mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), crateMat);
        mesh.position.y = -3.5;
    } else if (r > 0.3) {
        // Concrete Jersey Barrier
        mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 2.5, 1), barrierMat);
        mesh.position.y = -3.75;
    } else {
        // Steel Drum
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 16), drumMat);
        mesh.position.y = -3.5;
    }
    mesh.position.x = (Math.random() - 0.5) * 150;
    mesh.position.z = (Math.random() - 0.5) * 150;
    mesh.rotation.y = Math.random() * Math.PI;
    mesh.castShadow = true; mesh.receiveShadow = true;
    scene.add(mesh);
    targets.push(mesh);
    obstacles.push(mesh); // Store for target placement
}

// SHOOTING TARGETS
const shootingTargets = [];

// Create target geometry (silhouette shape)
function createTargetMesh() {
    const group = new THREE.Group();

    // Head
    const headGeo = new THREE.CircleGeometry(0.8, 16);
    const targetMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.8,
        side: THREE.DoubleSide
    });
    const head = new THREE.Mesh(headGeo, targetMat);
    head.position.y = 3.2;
    group.add(head);

    // Body (torso)
    const bodyGeo = new THREE.PlaneGeometry(1.6, 2.4);
    const body = new THREE.Mesh(bodyGeo, targetMat);
    body.position.y = 1.6;
    group.add(body);

    // Base/stand
    const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
    const standGeo = new THREE.BoxGeometry(0.15, 4.4, 0.15);
    const stand = new THREE.Mesh(standGeo, standMat);
    stand.position.y = 2.0;
    stand.position.z = 0.15;
    group.add(stand);

    const baseGeo = new THREE.BoxGeometry(1.2, 0.15, 0.8);
    const base = new THREE.Mesh(baseGeo, standMat);
    base.position.y = -0.05;
    group.add(base);

    return group;
}

// Target class
class ShootingTarget {
    constructor(position) {
        this.mesh = createTargetMesh();
        this.mesh.position.copy(position);
        this.mesh.position.y = -5; // Ground level

        this.pivotPoint = new THREE.Group();
        this.pivotPoint.position.copy(this.mesh.position);
        this.pivotPoint.add(this.mesh);
        this.mesh.position.set(0, 0, 0);

        scene.add(this.pivotPoint);

        this.isUp = false;
        this.isAnimating = false;
        this.rotation = 0;
        this.targetRotation = Math.PI / 2; // Fallen state

        // Add hitbox to raycast targets
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4, 0.5),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2;
        this.pivotPoint.add(this.hitbox);
        this.hitbox.userData.isTarget = true;
        this.hitbox.userData.targetRef = this;
        targets.push(this.hitbox);
    }

    popup(obstacle) {
        if (this.isAnimating) return;
        this.isAnimating = true;

        // Position behind obstacle
        const pos = obstacle.position.clone();
        pos.x += (Math.random() - 0.5) * 2;
        pos.z += (Math.random() > 0.5 ? 2 : -2);
        this.pivotPoint.position.set(pos.x, -5, pos.z);
        this.pivotPoint.rotation.y = Math.atan2(
            camera.position.x - pos.x,
            camera.position.z - pos.z
        );

        // Animate up
        this.targetRotation = 0;
        this.isUp = true;
    }

    knockDown() {
        if (!this.isUp || this.isAnimating) return;
        this.isAnimating = true;
        this.targetRotation = Math.PI / 2;
        this.isUp = false;

        // Schedule popup at new location
        setTimeout(() => {
            if (obstacles.length > 0) {
                const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                this.popup(randomObstacle);
            }
        }, 1500 + Math.random() * 2000);
    }

    update(dt) {
        // Smooth rotation animation
        const diff = this.targetRotation - this.rotation;
        if (Math.abs(diff) > 0.01) {
            this.rotation += diff * 8 * dt;
            this.pivotPoint.rotation.x = -this.rotation;
        } else {
            this.rotation = this.targetRotation;
            this.isAnimating = false;
        }
    }
}

// Create shooting targets
for (let i = 0; i < 8; i++) {
    const target = new ShootingTarget(new THREE.Vector3(0, -5, 0));
    shootingTargets.push(target);

    // Spawn at random obstacle after delay
    setTimeout(() => {
        if (obstacles.length > 0) {
            const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            target.popup(randomObstacle);
        }
    }, 1000 + i * 500);
}

// UNARMED BOTS
const bots = [];

// Bot materials
const skinMat = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.8 });

// Create shirt texture with "TALIBAN" text
const shirtTexCanvas = document.createElement('canvas');
shirtTexCanvas.width = 256; shirtTexCanvas.height = 256;
const shirtTexCtx = shirtTexCanvas.getContext('2d');
shirtTexCtx.fillStyle = '#2a2a2a';
shirtTexCtx.fillRect(0, 0, 256, 256);
shirtTexCtx.fillStyle = '#cc0000';
shirtTexCtx.font = 'bold 36px Arial';
shirtTexCtx.textAlign = 'center';
shirtTexCtx.textBaseline = 'middle';
shirtTexCtx.fillText('TALIBAN', 128, 128);
const shirtTex = new THREE.CanvasTexture(shirtTexCanvas);

const shirtMat = new THREE.MeshStandardMaterial({ map: shirtTex, roughness: 0.7 });
const pantsMat = new THREE.MeshStandardMaterial({ color: 0x333344, roughness: 0.7 });

function createBotMesh() {
    const group = new THREE.Group();
    const scale = 2.0; // Scale factor for larger bots

    // Head
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.35 * scale, 12, 8), skinMat);
    head.position.y = 1.85 * scale;
    head.castShadow = true;
    group.add(head);

    // Torso
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale), shirtMat);
    torso.position.y = 1.1 * scale;
    torso.castShadow = true;
    group.add(torso);

    // Arms
    const armGeo = new THREE.BoxGeometry(0.2 * scale, 0.7 * scale, 0.2 * scale);
    const leftArm = new THREE.Mesh(armGeo, skinMat);
    leftArm.position.set(-0.45 * scale, 1.1 * scale, 0);
    leftArm.castShadow = true;
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, skinMat);
    rightArm.position.set(0.45 * scale, 1.1 * scale, 0);
    rightArm.castShadow = true;
    group.add(rightArm);

    // Legs
    const legGeo = new THREE.BoxGeometry(0.25 * scale, 0.8 * scale, 0.25 * scale);
    const leftLeg = new THREE.Mesh(legGeo, pantsMat);
    leftLeg.position.set(-0.2 * scale, 0.4 * scale, 0);
    leftLeg.castShadow = true;
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, pantsMat);
    rightLeg.position.set(0.2 * scale, 0.4 * scale, 0);
    rightLeg.castShadow = true;
    group.add(rightLeg);

    return group;
}

class Bot {
    constructor(x, z) {
        this.mesh = createBotMesh();
        this.mesh.position.set(x, -5, z);
        scene.add(this.mesh);

        // AI state
        this.health = 3;
        this.isDead = false;
        this.deathTime = 0;
        this.respawnDelay = 5000;

        // Movement
        this.velocity = new THREE.Vector3();
        this.targetPos = new THREE.Vector3(x, -5, z);
        this.wanderTimer = 0;
        this.wanderInterval = 2 + Math.random() * 3;
        this.speed = 2 + Math.random() * 2;

        // Animation state
        this.walkCycle = Math.random() * Math.PI * 2;

        // Ragdoll parts (populated on death)
        this.ragdollParts = [];

        // Hitbox for raycasting (scaled to match larger bot)
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4.4, 1.0),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2.2;
        this.mesh.add(this.hitbox);
        this.hitbox.userData.isBot = true;
        this.hitbox.userData.botRef = this;
        targets.push(this.hitbox);
    }

    pickNewTarget() {
        // Wander to a random position within the arena
        this.targetPos.set(
            (Math.random() - 0.5) * 120,
            -5,
            (Math.random() - 0.5) * 120
        );
    }

    hit(hitPoint) {
        if (this.isDead) return;

        this.health--;
        playSound('botHit');

        // Flinch reaction
        this.mesh.rotation.x = -0.2;

        // Blood spray from hit point
        const bloodPos = hitPoint || this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        const bloodDir = new THREE.Vector3();
        bloodDir.subVectors(this.mesh.position, camera.position).normalize();
        spawnBloodSpray(bloodPos, bloodDir, this.health <= 0 ? 2.5 : 1);

        if (this.health <= 0) {
            this.die();
        }
    }

    die() {
        this.isDead = true;
        this.deathTime = performance.now();
        playSound('botDeath');

        // Remove hitbox from targets
        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);

        // Create ragdoll - detach body parts and give them physics
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        this.mesh.getWorldPosition(worldPos);
        this.mesh.getWorldQuaternion(worldQuat);

        // Get direction from camera to bot for death impulse
        const deathDir = new THREE.Vector3();
        deathDir.subVectors(this.mesh.position, camera.position).normalize();

        // Moderate gore effects
        const centerPos = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        spawnGoreChunks(centerPos, deathDir);
        spawnBloodSpray(centerPos, deathDir, 2);

        // Single blood pool
        spawnBloodPool(this.mesh.position.clone());

        // Detach each body part (skip hitbox at index 6)
        for (let i = 0; i < 6; i++) {
            const part = this.mesh.children[0]; // Always take first since we're removing
            if (!part) continue;

            // Get world position of part
            const partWorldPos = new THREE.Vector3();
            part.getWorldPosition(partWorldPos);

            // Remove from bot mesh and add to scene
            this.mesh.remove(part);
            scene.add(part);
            part.position.copy(partWorldPos);

            // Moderate velocity for ragdoll
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * 6 + deathDir.x * 4,
                Math.random() * 5 + 2,
                (Math.random() - 0.5) * 6 + deathDir.z * 4
            );

            // Moderate spinning
            const rotVel = new THREE.Vector3(
                (Math.random() - 0.5) * 12,
                (Math.random() - 0.5) * 12,
                (Math.random() - 0.5) * 12
            );

            this.ragdollParts.push({
                mesh: part,
                velocity: vel,
                rotVelocity: rotVel,
                grounded: false,
                bleedTimer: 0,
                canBleed: true
            });
        }

        // Hide the main mesh (hitbox is still there but invisible)
        this.mesh.visible = false;
    }

    respawn() {
        this.isDead = false;
        this.health = 3;

        // Clean up ragdoll parts
        for (const part of this.ragdollParts) {
            scene.remove(part.mesh);
        }
        this.ragdollParts = [];

        // Recreate the bot mesh
        const newMesh = createBotMesh();
        newMesh.position.set(
            (Math.random() - 0.5) * 120,
            -5,
            (Math.random() - 0.5) * 120
        );
        newMesh.rotation.y = Math.random() * Math.PI * 2;

        // Transfer hitbox to new mesh
        this.mesh.remove(this.hitbox);
        newMesh.add(this.hitbox);

        // Remove old mesh and use new one
        scene.remove(this.mesh);
        this.mesh = newMesh;
        this.mesh.visible = true;
        scene.add(this.mesh);

        this.pickNewTarget();

        // Re-add hitbox to targets
        if (!targets.includes(this.hitbox)) {
            targets.push(this.hitbox);
        }
    }

    update(dt, time) {
        if (this.isDead) {
            // Update ragdoll physics
            const groundY = -4.8;
            const friction = 0.85;
            const bounciness = 0.3;

            for (const part of this.ragdollParts) {
                if (!part.grounded) {
                    // Apply gravity
                    part.velocity.y -= 25 * dt;

                    // Update position
                    part.mesh.position.addScaledVector(part.velocity, dt);

                    // Update rotation
                    part.mesh.rotation.x += part.rotVelocity.x * dt;
                    part.mesh.rotation.y += part.rotVelocity.y * dt;
                    part.mesh.rotation.z += part.rotVelocity.z * dt;

                    // Ground collision
                    if (part.mesh.position.y < groundY) {
                        part.mesh.position.y = groundY;

                        // Bounce or settle
                        if (Math.abs(part.velocity.y) > 1) {
                            part.velocity.y *= -bounciness;
                            part.velocity.x *= friction;
                            part.velocity.z *= friction;
                            part.rotVelocity.multiplyScalar(0.7);
                        } else {
                            part.velocity.set(0, 0, 0);
                            part.rotVelocity.multiplyScalar(0.9);
                            if (part.rotVelocity.length() < 0.1) {
                                part.grounded = true;
                            }
                        }
                    }

                    // Air resistance
                    part.velocity.multiplyScalar(0.995);

                    // Blood dripping from body parts
                    if (part.canBleed) {
                        part.bleedTimer += dt;
                        if (part.bleedTimer > 0.08) {
                            part.bleedTimer = 0;
                            const dropMat = new THREE.SpriteMaterial({
                                map: bloodSpriteTex,
                                color: 0x880000,
                                transparent: true,
                                opacity: 0.9
                            });
                            const drop = new THREE.Sprite(dropMat);
                            drop.position.copy(part.mesh.position);
                            drop.scale.setScalar(0.1 + Math.random() * 0.1);
                            scene.add(drop);
                            bloodParticles.push({
                                mesh: drop,
                                velocity: new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.5,
                                    -1,
                                    (Math.random() - 0.5) * 0.5
                                ),
                                life: 0.8,
                                gravity: 20,
                                type: 'droplet'
                            });
                        }
                    }
                } else if (part.canBleed) {
                    // Grounded parts slowly stop bleeding
                    part.bleedTimer += dt;
                    if (part.bleedTimer > 2) {
                        part.canBleed = false;
                    }
                }
            }

            // Respawn after delay
            if (performance.now() - this.deathTime > this.respawnDelay) {
                this.respawn();
            }
            return;
        }

        // Recover from flinch
        this.mesh.rotation.x *= 0.9;

        // Wandering AI
        this.wanderTimer += dt;
        if (this.wanderTimer >= this.wanderInterval) {
            this.wanderTimer = 0;
            this.wanderInterval = 2 + Math.random() * 3;
            this.pickNewTarget();
        }

        // Move towards target
        const dx = this.targetPos.x - this.mesh.position.x;
        const dz = this.targetPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist > 1) {
            const moveX = (dx / dist) * this.speed * dt;
            const moveZ = (dz / dist) * this.speed * dt;
            this.mesh.position.x += moveX;
            this.mesh.position.z += moveZ;

            // Face movement direction
            this.mesh.rotation.y = Math.atan2(dx, dz);

            // Walk animation
            this.walkCycle += dt * 8;
            const leftLeg = this.mesh.children[4];
            const rightLeg = this.mesh.children[5];
            const leftArm = this.mesh.children[2];
            const rightArm = this.mesh.children[3];

            if (leftLeg && rightLeg) {
                leftLeg.rotation.x = Math.sin(this.walkCycle) * 0.4;
                rightLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.4;
            }
            if (leftArm && rightArm) {
                leftArm.rotation.x = Math.sin(this.walkCycle + Math.PI) * 0.3;
                rightArm.rotation.x = Math.sin(this.walkCycle) * 0.3;
            }
        } else {
            // Idle - reset limbs
            this.walkCycle = 0;
            for (let i = 2; i <= 5; i++) {
                if (this.mesh.children[i]) {
                    this.mesh.children[i].rotation.x *= 0.9;
                }
            }
        }

        // Keep within bounds
        this.mesh.position.x = Math.max(-180, Math.min(180, this.mesh.position.x));
        this.mesh.position.z = Math.max(-180, Math.min(180, this.mesh.position.z));
    }
}

// Spawn bots
for (let i = 0; i < 6; i++) {
    const x = (Math.random() - 0.5) * 100;
    const z = (Math.random() - 0.5) * 100;
    bots.push(new Bot(x, z));
}

// BLOOD & GORE SYSTEM
const bloodParticles = [];
const goreChunks = [];
const bloodDecals = [];
const bloodPools = [];

// Blood splatter texture (procedural)
const bloodTexCanvas = document.createElement('canvas');
bloodTexCanvas.width = 64; bloodTexCanvas.height = 64;
const bloodCtx = bloodTexCanvas.getContext('2d');
const bloodGrad = bloodCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
bloodGrad.addColorStop(0, 'rgba(180, 0, 0, 1)');
bloodGrad.addColorStop(0.3, 'rgba(120, 0, 0, 0.8)');
bloodGrad.addColorStop(0.7, 'rgba(80, 0, 0, 0.4)');
bloodGrad.addColorStop(1, 'rgba(40, 0, 0, 0)');
bloodCtx.fillStyle = bloodGrad;
bloodCtx.fillRect(0, 0, 64, 64);
const bloodSpriteTex = new THREE.CanvasTexture(bloodTexCanvas);

// Blood mist texture
const mistTexCanvas = document.createElement('canvas');
mistTexCanvas.width = 128; mistTexCanvas.height = 128;
const mistCtx = mistTexCanvas.getContext('2d');
const mistGrad = mistCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
mistGrad.addColorStop(0, 'rgba(150, 0, 0, 0.6)');
mistGrad.addColorStop(0.5, 'rgba(100, 0, 0, 0.3)');
mistGrad.addColorStop(1, 'rgba(60, 0, 0, 0)');
mistCtx.fillStyle = mistGrad;
mistCtx.fillRect(0, 0, 128, 128);
const bloodMistTex = new THREE.CanvasTexture(mistTexCanvas);

// Blood decal texture (splatter pattern)
const bloodDecalCanvas = document.createElement('canvas');
bloodDecalCanvas.width = 256; bloodDecalCanvas.height = 256;
const decalCtx = bloodDecalCanvas.getContext('2d');
decalCtx.fillStyle = 'rgba(0,0,0,0)';
decalCtx.fillRect(0, 0, 256, 256);
// Main splat
decalCtx.beginPath();
decalCtx.arc(128, 128, 60 + Math.random() * 20, 0, Math.PI * 2);
decalCtx.fillStyle = 'rgba(100, 0, 0, 0.9)';
decalCtx.fill();
// Splatter droplets
for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 40 + Math.random() * 80;
    const x = 128 + Math.cos(angle) * dist;
    const y = 128 + Math.sin(angle) * dist;
    const r = 3 + Math.random() * 12;
    decalCtx.beginPath();
    decalCtx.arc(x, y, r, 0, Math.PI * 2);
    decalCtx.fillStyle = `rgba(${80 + Math.random() * 40}, 0, 0, ${0.6 + Math.random() * 0.4})`;
    decalCtx.fill();
}
// Streaks
for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    decalCtx.beginPath();
    decalCtx.moveTo(128, 128);
    const len = 50 + Math.random() * 70;
    decalCtx.lineTo(128 + Math.cos(angle) * len, 128 + Math.sin(angle) * len);
    decalCtx.strokeStyle = `rgba(90, 0, 0, ${0.5 + Math.random() * 0.3})`;
    decalCtx.lineWidth = 2 + Math.random() * 4;
    decalCtx.stroke();
}
const bloodDecalTex = new THREE.CanvasTexture(bloodDecalCanvas);

// Gore materials
const goreMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.6 });
const boneMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.4 });
const organMat = new THREE.MeshStandardMaterial({ color: 0x4a0000, roughness: 0.7 });

// Blood spray on hit
function spawnBloodSpray(position, direction, intensity = 1) {
    const count = Math.floor(8 * intensity);

    // Blood droplets
    for (let i = 0; i < count; i++) {
        const spriteMat = new THREE.SpriteMaterial({
            map: bloodSpriteTex,
            color: new THREE.Color(0.5 + Math.random() * 0.3, 0, 0),
            transparent: true,
            opacity: 0.8,
            depthWrite: false
        });
        const sprite = new THREE.Sprite(spriteMat);
        sprite.position.copy(position);
        sprite.scale.setScalar(0.1 + Math.random() * 0.15);

        const vel = direction.clone().multiplyScalar(3 + Math.random() * 5);
        vel.add(new THREE.Vector3(
            (Math.random() - 0.5) * 4,
            Math.random() * 3,
            (Math.random() - 0.5) * 4
        ));

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: vel,
            life: 1.0 + Math.random() * 0.5,
            gravity: 15,
            type: 'droplet'
        });
    }

    // Light blood mist
    if (intensity > 1) {
        const mistMat = new THREE.SpriteMaterial({
            map: bloodMistTex,
            color: 0x660000,
            transparent: true,
            opacity: 0.4,
            depthWrite: false,
            blending: THREE.NormalBlending
        });
        const mist = new THREE.Sprite(mistMat);
        mist.position.copy(position);
        mist.scale.setScalar(0.4);

        scene.add(mist);
        bloodParticles.push({
            mesh: mist,
            velocity: direction.clone().multiplyScalar(2),
            life: 0.5,
            gravity: 0,
            type: 'mist',
            initialScale: mist.scale.x
        });
    }
}

// Spawn gore chunks on death
function spawnGoreChunks(position, direction) {
    const chunkCount = 5 + Math.floor(Math.random() * 4);

    for (let i = 0; i < chunkCount; i++) {
        let geo, mat;
        const type = Math.random();

        if (type < 0.6) {
            // Small meat chunk
            geo = new THREE.DodecahedronGeometry(0.08 + Math.random() * 0.08);
            mat = goreMat.clone();
        } else {
            // Bone fragment
            geo = new THREE.BoxGeometry(0.04, 0.12, 0.04);
            mat = boneMat.clone();
        }

        const chunk = new THREE.Mesh(geo, mat);
        chunk.position.copy(position);
        chunk.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        chunk.castShadow = true;

        const vel = direction.clone().multiplyScalar(3 + Math.random() * 5);
        vel.add(new THREE.Vector3(
            (Math.random() - 0.5) * 6,
            Math.random() * 5 + 2,
            (Math.random() - 0.5) * 6
        ));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 15,
            (Math.random() - 0.5) * 15,
            (Math.random() - 0.5) * 15
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 6 + Math.random() * 3,
            grounded: false,
            canBleed: Math.random() > 0.7,
            bleedTimer: 0
        });
    }
}

// Spawn blood decal on surface
function spawnBloodDecal(position, normal, size = 1) {
    const decalMat = new THREE.MeshBasicMaterial({
        map: bloodDecalTex,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -2
    });

    const decalSize = (1.5 + Math.random() * 1.5) * size;
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(decalSize, decalSize), decalMat);
    decal.position.copy(position);
    decal.position.y = -4.95; // Just above floor
    decal.rotation.x = -Math.PI / 2;
    decal.rotation.z = Math.random() * Math.PI * 2;

    scene.add(decal);
    bloodDecals.push({
        mesh: decal,
        life: 600 + Math.random() * 300
    });
}

// Spawn expanding blood pool under body
function spawnBloodPool(position) {
    const poolMat = new THREE.MeshBasicMaterial({
        color: 0x3a0000,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1
    });

    const pool = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), poolMat);
    pool.position.copy(position);
    pool.position.y = -4.98;
    pool.rotation.x = -Math.PI / 2;

    scene.add(pool);
    bloodPools.push({
        mesh: pool,
        targetSize: 1.2 + Math.random() * 1.0,
        currentSize: 0.1,
        growthRate: 0.5 + Math.random() * 0.3,
        life: 500 + Math.random() * 300
    });
}

// Update blood particle systems
function updateBloodEffects(dt) {
    // Update blood particles
    for (let i = bloodParticles.length - 1; i >= 0; i--) {
        const p = bloodParticles[i];
        p.life -= dt;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodParticles.splice(i, 1);
            continue;
        }

        if (p.type === 'droplet') {
            p.velocity.y -= p.gravity * dt;
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.mesh.material.opacity = Math.min(1, p.life);

            // Hit ground - spawn small splat
            if (p.mesh.position.y < -4.8) {
                if (Math.random() > 0.7) {
                    spawnBloodDecal(p.mesh.position.clone(), new THREE.Vector3(0, 1, 0), 0.3);
                }
                scene.remove(p.mesh);
                bloodParticles.splice(i, 1);
            }
        } else if (p.type === 'mist') {
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.velocity.multiplyScalar(0.95);
            p.mesh.scale.setScalar(p.initialScale * (1 + (1 - p.life) * 3));
            p.mesh.material.opacity = p.life * 0.5;
        }
    }

    // Update gore chunks
    for (let i = goreChunks.length - 1; i >= 0; i--) {
        const g = goreChunks[i];
        g.life -= dt;

        if (g.life <= 0) {
            scene.remove(g.mesh);
            goreChunks.splice(i, 1);
            continue;
        }

        if (!g.grounded) {
            g.velocity.y -= 20 * dt;
            g.mesh.position.addScaledVector(g.velocity, dt);
            g.mesh.rotation.x += g.rotVelocity.x * dt;
            g.mesh.rotation.y += g.rotVelocity.y * dt;
            g.mesh.rotation.z += g.rotVelocity.z * dt;

            // Ground collision
            if (g.mesh.position.y < -4.7) {
                g.mesh.position.y = -4.7;
                if (Math.abs(g.velocity.y) > 2) {
                    g.velocity.y *= -0.3;
                    g.velocity.x *= 0.7;
                    g.velocity.z *= 0.7;
                    g.rotVelocity.multiplyScalar(0.5);
                    // Splat on impact
                    spawnBloodDecal(g.mesh.position.clone(), new THREE.Vector3(0, 1, 0), 0.4);
                } else {
                    g.grounded = true;
                    g.velocity.set(0, 0, 0);
                }
            }
        }

        // Bleeding effect from chunks
        if (g.canBleed && !g.grounded) {
            g.bleedTimer += dt;
            if (g.bleedTimer > 0.05) {
                g.bleedTimer = 0;
                const dropMat = new THREE.SpriteMaterial({
                    map: bloodSpriteTex,
                    color: 0x880000,
                    transparent: true,
                    opacity: 0.8
                });
                const drop = new THREE.Sprite(dropMat);
                drop.position.copy(g.mesh.position);
                drop.scale.setScalar(0.08);
                scene.add(drop);
                bloodParticles.push({
                    mesh: drop,
                    velocity: new THREE.Vector3(0, 0, 0),
                    life: 0.6,
                    gravity: 25,
                    type: 'droplet'
                });
            }
        }

        // Fade out near end of life
        if (g.life < 2) {
            g.mesh.material.opacity = g.life / 2;
            g.mesh.material.transparent = true;
        }
    }

    // Update blood pools
    for (let i = bloodPools.length - 1; i >= 0; i--) {
        const p = bloodPools[i];
        p.life -= 1;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodPools.splice(i, 1);
            continue;
        }

        // Grow pool
        if (p.currentSize < p.targetSize) {
            p.currentSize += p.growthRate * dt;
            p.mesh.scale.setScalar(p.currentSize);
        }

        // Fade out
        if (p.life < 100) {
            p.mesh.material.opacity = (p.life / 100) * 0.9;
        }
    }

    // Update blood decals
    for (let i = bloodDecals.length - 1; i >= 0; i--) {
        const d = bloodDecals[i];
        d.life -= 1;

        if (d.life <= 0) {
            scene.remove(d.mesh);
            bloodDecals.splice(i, 1);
            continue;
        }

        if (d.life < 100) {
            d.mesh.material.opacity = (d.life / 100) * 0.85;
        }
    }
}

// ATMOSPHERIC DUST PARTICLES
const dustParticles = [];
const dustGeo = new THREE.BufferGeometry();
const dustCount = 500;
const dustPositions = new Float32Array(dustCount * 3);
for(let i = 0; i < dustCount; i++) {
    dustPositions[i * 3] = (Math.random() - 0.5) * 200;
    dustPositions[i * 3 + 1] = Math.random() * 30 - 5;
    dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
const dustMat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.15,
    transparent: true,
    opacity: 0.3,
    blending: THREE.AdditiveBlending,
    depthWrite: false
});
const dustCloud = new THREE.Points(dustGeo, dustMat);
scene.add(dustCloud);

/**
 * GUN CONSTRUCTION
 */
const gunGroup = new THREE.Group();
const recoilGroup = new THREE.Group();
recoilGroup.add(gunGroup);

// Enhanced gun materials with environment reflections
const woodMat = new THREE.MeshStandardMaterial({
    map: woodTex,
    roughness: 0.45,
    metalness: 0.05,
    bumpMap: woodTex,
    bumpScale: 0.03,
    envMap: envMapTex,
    envMapIntensity: 0.15
});

const metalMat = new THREE.MeshStandardMaterial({
    map: metalTexLight,
    color: 0xdddddd,
    roughness: 0.25,
    metalness: 0.95,
    bumpMap: metalTexLight,
    bumpScale: 0.008,
    envMap: envMapTex,
    envMapIntensity: 0.6
});

const darkMetalMat = new THREE.MeshStandardMaterial({
    map: metalTexDark,
    color: 0x1a1a1a,
    roughness: 0.5,
    metalness: 0.7,
    bumpMap: metalTexDark,
    bumpScale: 0.01,
    envMap: envMapTex,
    envMapIntensity: 0.3
});

const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 4), darkMetalMat);
receiver.castShadow = true; gunGroup.add(receiver);

const dustCover = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4, 16, 1, false, 0, Math.PI), darkMetalMat);
dustCover.rotation.set(Math.PI/2, Math.PI/2, 0); dustCover.position.y = 0.5; dustCover.castShadow = true; gunGroup.add(dustCover);

const stock = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 3), woodMat);
stock.position.set(0, -0.5, 3.5); stock.rotation.x = 0.2; stock.castShadow = true; gunGroup.add(stock);

const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 6, 12), metalMat);
barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.3, -4); barrel.castShadow = true; gunGroup.add(barrel);

const gasTube = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 3, 12), metalMat);
gasTube.rotation.x = Math.PI / 2; gasTube.position.set(0, 0.7, -3); gunGroup.add(gasTube);

const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 2.5), woodMat);
handguard.position.set(0, 0.2, -3); handguard.castShadow = true; gunGroup.add(handguard);

const grip = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.5, 0.8), woodMat);
grip.position.set(0, -1, 0.5); grip.rotation.x = -0.3; grip.castShadow = true; gunGroup.add(grip);

// Sights
const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.2), darkMetalMat);
frontSight.position.set(0, 0.8, -6.5); frontSight.castShadow = true; gunGroup.add(frontSight);

const rearSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), darkMetalMat);
rearSightBase.position.set(0, 0.9, -1.0); gunGroup.add(rearSightBase);
const rearSightL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightL.position.set(-0.15, 1.1, -1.0); gunGroup.add(rearSightL);
const rearSightR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightR.position.set(0.15, 1.1, -1.0); gunGroup.add(rearSightR);

const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.6), metalMat);
bolt.position.set(0.5, 0.4, -0.5); bolt.castShadow = true; gunGroup.add(bolt);

// Magazine Pivot Group (For cooler reloading arcs)
const magPivot = new THREE.Group();
magPivot.position.set(0, -0.5, -1);
gunGroup.add(magPivot);

const magGeo = new THREE.BoxGeometry(0.6, 2.5, 1.2);
const magCurve = new THREE.Mesh(magGeo, metalMat);
magCurve.rotation.x = 0.4; magCurve.position.y = -1.2; magCurve.castShadow = true;
magPivot.add(magCurve);

// ENHANCED MUZZLE FLASH VFX
const flashGroup = new THREE.Group();

// Core flash (bright white center)
const flashCoreMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
const flashCore = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), flashCoreMat);
flashGroup.add(flashCore);

// Mid flash (orange/yellow)
const flashMidMat = new THREE.MeshBasicMaterial({
    color: 0xffaa44, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    flashGroup.add(f);
}

// Outer flash (red/orange glow)
const flashOuterMat = new THREE.MeshBasicMaterial({
    color: 0xff6622, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<6; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), flashOuterMat);
    f.rotation.z = (Math.PI / 3) * i;
    flashGroup.add(f);
}

// Flash streaks (elongated for directional feel)
const flashStreakMat = new THREE.MeshBasicMaterial({
    color: 0xffcc66, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<3; i++) {
    const streak = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 3.0), flashStreakMat);
    streak.rotation.z = (Math.PI / 3) * i + Math.PI/6;
    streak.position.z = -0.5;
    flashGroup.add(streak);
}

flashGroup.position.set(0, 0.3, -7.2);
gunGroup.add(flashGroup);

// Legacy reference for compatibility
const flashMat = flashMidMat;

// Camera Rig
const hipPos = new THREE.Vector3(0.9, -1.1, -1.8);
const aimPos = new THREE.Vector3(0.0, -1.22, -0.5);
recoilGroup.position.copy(hipPos);
recoilGroup.rotation.y = Math.PI; 
camera.add(recoilGroup);
scene.add(camera);

/**
 * ENHANCED PARTICLE SYSTEMS
 */

// Improved Smoke
const smokeParticles = [];
const smokeTexCanvas = document.createElement('canvas'); smokeTexCanvas.width = 128; smokeTexCanvas.height = 128;
const stx = smokeTexCanvas.getContext('2d');
const sGrad = stx.createRadialGradient(64,64,0,64,64,64);
sGrad.addColorStop(0, 'rgba(200,200,200,0.6)');
sGrad.addColorStop(0.4, 'rgba(150,150,150,0.3)');
sGrad.addColorStop(1, 'rgba(100,100,100,0)');
stx.fillStyle = sGrad; stx.fillRect(0,0,128,128);
const smokeSpriteTex = new THREE.CanvasTexture(smokeTexCanvas);
const smokeMat = new THREE.SpriteMaterial({
    map: smokeSpriteTex, color: 0x888888, transparent: true,
    blending: THREE.NormalBlending, depthWrite: false
});

// Hot smoke (orange tint near muzzle)
const hotSmokeMat = new THREE.SpriteMaterial({
    map: smokeSpriteTex, color: 0xffaa66, transparent: true,
    blending: THREE.AdditiveBlending, depthWrite: false
});

function spawnSmoke() {
    // Hot smoke near muzzle
    for(let i=0; i<2; i++) {
        const s = new THREE.Sprite(hotSmokeMat.clone());
        s.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
        s.scale.setScalar(0.3 + Math.random() * 0.3);
        const vel = new THREE.Vector3(0, 0, -1).applyQuaternion(gunGroup.getWorldQuaternion(new THREE.Quaternion()));
        vel.add(new THREE.Vector3((Math.random()-0.5)*0.5, Math.random()*0.3, (Math.random()-0.5)*0.5)).multiplyScalar(3 + Math.random()*2);
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: vel, age: 0, life: 0.4 + Math.random()*0.3, hot: true });
    }
    // Regular smoke
    for(let i=0; i<3; i++) {
        const s = new THREE.Sprite(smokeMat.clone());
        s.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
        s.scale.setScalar(0.4 + Math.random() * 0.4);
        const vel = new THREE.Vector3(0, 0, -1).applyQuaternion(gunGroup.getWorldQuaternion(new THREE.Quaternion()));
        vel.add(new THREE.Vector3((Math.random()-0.5)*0.4, Math.random()*0.6, (Math.random()-0.5)*0.4)).multiplyScalar(1.5 + Math.random());
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: vel, age: 0, life: 1.2 + Math.random()*0.8, hot: false });
    }
}

// SPARK PARTICLES for muzzle and impacts
const sparks = [];
const sparkGeo = new THREE.SphereGeometry(0.02, 4, 4);
const sparkMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending });

function spawnMuzzleSparks() {
    for(let i=0; i<8; i++) {
        const spark = new THREE.Mesh(sparkGeo, sparkMat.clone());
        spark.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
        const vel = new THREE.Vector3(
            (Math.random()-0.5) * 8,
            Math.random() * 4,
            -Math.random() * 15
        ).applyQuaternion(camera.quaternion);
        spark.userData = { velocity: vel, life: 0.15 + Math.random()*0.2 };
        scene.add(spark);
        sparks.push(spark);
    }
}

function spawnImpactSparks(point, normal) {
    for(let i=0; i<12; i++) {
        const spark = new THREE.Mesh(sparkGeo, sparkMat.clone());
        spark.position.copy(point);
        // Sparks fly along normal with random spread
        const vel = normal.clone().multiplyScalar(5 + Math.random()*10);
        vel.add(new THREE.Vector3(
            (Math.random()-0.5) * 8,
            Math.random() * 5,
            (Math.random()-0.5) * 8
        ));
        spark.userData = { velocity: vel, life: 0.2 + Math.random()*0.3 };
        scene.add(spark);
        sparks.push(spark);
    }
}

// DEBRIS PARTICLES for impacts
const debris = [];
const debrisGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
const debrisMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });

function spawnDebris(point, normal) {
    for(let i=0; i<5; i++) {
        const d = new THREE.Mesh(debrisGeo, debrisMat);
        d.position.copy(point);
        const vel = normal.clone().multiplyScalar(2 + Math.random()*4);
        vel.add(new THREE.Vector3(
            (Math.random()-0.5) * 4,
            Math.random() * 3,
            (Math.random()-0.5) * 4
        ));
        d.userData = {
            velocity: vel,
            rotVel: new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10),
            life: 60 + Math.random()*60
        };
        scene.add(d);
        debris.push(d);
    }
}

const shells = [];
const mags = [];
const tracers = [];
const decals = [];
const decalTex = TextureFactory.impact();
const decalMat = new THREE.MeshBasicMaterial({ map: decalTex, transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
const shellGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
const shellMat = new THREE.MeshStandardMaterial({
    color: 0xd4af37,
    metalness: 1.0,
    roughness: 0.15,
    envMap: envMapTex,
    envMapIntensity: 0.8
});

const raycaster = new THREE.Raycaster();

function ejectShell() {
    const shell = new THREE.Mesh(shellGeo, shellMat);
    shell.position.copy(new THREE.Vector3(0.5, 0.4, 0).applyMatrix4(gunGroup.matrixWorld));
    shell.quaternion.copy(gunGroup.quaternion); shell.rotation.z = Math.PI/2;
    const velocity = new THREE.Vector3(0.1 + Math.random()*0.1, 0.2 + Math.random()*0.1, 0).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 150 };
    scene.add(shell); shells.push(shell);
}

function spawnTracer(start, end) {
    // Main tracer line
    const points = [start, end];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({
        color: 0xffff88,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    tracers.push({ mesh: line, life: 4 });

    // Glow tracer (wider, softer)
    const glowMat = new THREE.LineBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
    });
    const glowLine = new THREE.Line(geo.clone(), glowMat);
    scene.add(glowLine);
    tracers.push({ mesh: glowLine, life: 3 });
}

function spawnDecal(point, normal) {
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), decalMat);
    decal.position.copy(point);
    decal.position.addScaledVector(normal, 0.01);
    decal.lookAt(point.clone().add(normal));
    decal.rotation.z = Math.random() * Math.PI * 2;
    scene.add(decal);
    decals.push({ mesh: decal, life: 600 });

    // Spawn impact effects
    spawnImpactSparks(point, normal);
    spawnDebris(point, normal);
}

/**
 * LOGIC & STATE
 */
let ammo = 30;
let reserve = 90;
let isReloading = false;
let isFiring = false;
let isAiming = false;
let lastShotTime = 0;
const fireRate = 0.1;

const moveState = { f: false, b: false, l: false, r: false, sprint: false };
const velocity = new THREE.Vector3();
const baseSpeed = 15.0;
const sprintMultiplier = 1.8;
let prevTime = performance.now();

// Jump physics
let verticalVelocity = 0;
let playerHeight = 0; // Offset from ground (-5)
const groundLevel = 0;
const gravity = 35;
const jumpForce = 12;
let isGrounded = true;
let canJump = true;

// Smooth landing spring
Springs.landing = new Spring(200, 15, 1);

// CAMERA STATE
let cameraPitch = 0;
let cameraYaw = 0;
let cameraRecoil = 0;
let currentFOV = 90;

const hud = document.getElementById('hud');
const crosshair = document.getElementById('crosshair');
const hitmarker = document.getElementById('hitmarker');

let hitmarkerTimeout = null;
function showHitmarker() {
    hitmarker.classList.add('show');
    if (hitmarkerTimeout) clearTimeout(hitmarkerTimeout);
    hitmarkerTimeout = setTimeout(() => {
        hitmarker.classList.remove('show');
    }, 100);
}

function updateHUD() {
    hud.innerText = `${isReloading ? 'RLD' : ammo} / ${reserve}`;
    hud.style.color = ammo <= 5 ? '#ff3333' : '#0f0';
}

function shoot() {
    if (isReloading || ammo <= 0) {
        if (ammo <= 0 && !isReloading) playSound('empty');
        return;
    }
    const now = performance.now() / 1000;
    if (now - lastShotTime < fireRate) return;
    
    lastShotTime = now;
    ammo--;
    updateHUD();
    playSound('shoot');

    // IMPULSE PHYSICS (CORRECTED & TIGHTENED)
    const aimMod = isAiming ? 0.3 : 1.0;
    
    // Z: Negative impulse kicks the gun BACKWARDS into the shoulder (Correct)
    Springs.recoilZ.impulse(-15 * aimMod); 
    
    // X: NEGATIVE impulse rotates muzzle UP (Corrected direction)
    // Reduced magnitude slightly for "ever so slightly" up, but snappy
    Springs.recoilX.impulse(-4 * aimMod);
    
    // Y: Vertical physical rise (Reduced to be subtle)
    Springs.recoilY.impulse(0.5 * aimMod);
    
    Springs.roll.impulse((Math.random()-0.5) * 0.5);
    cameraRecoil += 0.03 * aimMod;

    // Crosshair pop
    if(!isAiming) {
        crosshair.style.width = '40px'; crosshair.style.height = '40px';
        setTimeout(() => { crosshair.style.width = '20px'; crosshair.style.height = '20px'; }, 80);
    }

    // ENHANCED FLASH
    flashCoreMat.opacity = 1.0;
    flashMidMat.opacity = 0.9;
    flashOuterMat.opacity = 0.7;
    flashStreakMat.opacity = 0.8;
    flashGroup.rotation.z = Math.random() * Math.PI;
    flashGroup.scale.setScalar(0.8 + Math.random() * 0.4);
    muzzleLight.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
    muzzleLight.intensity = 30;
    muzzleLight.color.setHex(0xffaa44);

    // Spawn muzzle sparks
    spawnMuzzleSparks();

    // Dynamic post-processing punch
    bloomIntensity = 0.2;
    chromaticAmount = 0.002;

    // Screen shake
    Springs.shakeX.impulse((Math.random()-0.5) * 3 * aimMod);
    Springs.shakeY.impulse((Math.random()-0.5) * 2 * aimMod);

    // Bolt snap
    bolt.position.z = 0.5; 
    
    ejectShell();
    spawnSmoke();

    // RAYCAST
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(targets);
    const muzzlePos = new THREE.Vector3(0, 0.3, -6.5).applyMatrix4(gunGroup.matrixWorld);
    let hitPoint;
    if (intersects.length > 0) {
        hitPoint = intersects[0].point;

        // Check if we hit a shooting target
        if (intersects[0].object.userData.isTarget) {
            const target = intersects[0].object.userData.targetRef;
            if (target && target.isUp) {
                target.knockDown();
                playSound('targetHit');
            }
        } else if (intersects[0].object.userData.isBot) {
            // Hit a bot
            const bot = intersects[0].object.userData.botRef;
            if (bot && !bot.isDead) {
                bot.hit(intersects[0].point.clone());
                showHitmarker();
            }
        } else if (intersects[0].face) {
            spawnDecal(intersects[0].point, intersects[0].face.normal);
        }
    } else {
        hitPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
    }
    spawnTracer(muzzlePos, hitPoint);
}

function dropMag() {
    const dMag = magPivot.clone(); // Clone pivot to preserve rotation
    scene.add(dMag);
    const wp = new THREE.Vector3(); const wq = new THREE.Quaternion();
    magPivot.getWorldPosition(wp); magPivot.getWorldQuaternion(wq);
    dMag.position.copy(wp); dMag.quaternion.copy(wq);
    // Inherit some velocity?
    dMag.userData = { vel: new THREE.Vector3(0, -2, 0), rot: new THREE.Vector3(1, 0, 0), life: 200 };
    mags.push(dMag);
}

/**
 * HIGH-END RELOAD SEQUENCE (Tween.js)
 */
function reload() {
    if (isReloading || ammo === 30 || reserve === 0) return;
    if (isAiming) isAiming = false;
    isReloading = true;
    updateHUD();

    // ANIMATION TWEENS
    // 1. Tilt Gun
    new TWEEN.Tween(recoilGroup.rotation)
        .to({ z: 0.8, x: 0.3 }, 300)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    // 2. Unlatch Mag (Fast)
    setTimeout(() => {
        playSound('mag_out');
        new TWEEN.Tween(magPivot.rotation)
            .to({ x: 1.5 }, 200)
            .easing(TWEEN.Easing.Back.In)
            .onComplete(() => {
                // 3. Drop
                dropMag();
                magPivot.visible = false;
                Springs.bobY.impulse(-2);
            })
            .start();

        // 4. Insert New Mag
        setTimeout(() => {
            magPivot.visible = true;
            magPivot.rotation.x = 0;
            magPivot.position.y = -4;

            new TWEEN.Tween(magPivot.position)
                .to({ y: -0.5 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // 5. Lock In
                    playSound('mag_in');
                    Springs.recoilX.impulse(-2);
                    Springs.roll.impulse(-0.2);

                    // 6. Rack Bolt
                    setTimeout(() => {
                        playSound('rack');
                        new TWEEN.Tween(bolt.position).to({ z: 0.5 }, 100).easing(TWEEN.Easing.Cubic.Out).start();
                        Springs.recoilZ.impulse(2);

                        setTimeout(() => {
                            new TWEEN.Tween(bolt.position).to({ z: -0.5 }, 80).easing(TWEEN.Easing.Exponential.In).start();
                            Springs.recoilZ.impulse(-5);

                            // 7. Return to Idle
                            new TWEEN.Tween(recoilGroup.rotation)
                                .to({ z: 0, x: 0 }, 400)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();

                            const needed = 30 - ammo;
                            if (reserve >= needed) { reserve -= needed; ammo = 30; }
                            else { ammo += reserve; reserve = 0; }
                            isReloading = false;
                            updateHUD();
                        }, 150);
                    }, 200);
                })
                .start();
        }, 300);
    }, 250);
}

// Input
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'KeyR') reload();
    if (e.code === 'KeyW') moveState.f = true;
    if (e.code === 'KeyS') moveState.b = true;
    if (e.code === 'KeyA') moveState.l = true;
    if (e.code === 'KeyD') moveState.r = true;
    if (e.code === 'ShiftLeft') moveState.sprint = true;
    if (e.code === 'Space' && isGrounded && canJump) {
        verticalVelocity = jumpForce;
        isGrounded = false;
        canJump = false;
        // Slight upward weapon motion on jump
        Springs.bobY.impulse(-1.5);
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (e.code === 'KeyW') moveState.f = false;
    if (e.code === 'KeyS') moveState.b = false;
    if (e.code === 'KeyA') moveState.l = false;
    if (e.code === 'KeyD') moveState.r = false;
    if (e.code === 'ShiftLeft') moveState.sprint = false;
    if (e.code === 'Space') canJump = true;
});
document.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
        document.getElementById('blocker').style.display = 'none';
    } else {
        if(e.button === 0) isFiring = true;
        if(e.button === 2) isAiming = true;
    }
});
document.addEventListener('mouseup', (e) => {
    if(e.button === 0) isFiring = false;
    if(e.button === 2) isAiming = false;
});

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        const sens = isAiming ? 0.001 : 0.002;
        cameraYaw -= e.movementX * sens;
        cameraPitch -= e.movementY * sens;
        cameraPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraPitch));

        // Procedural Sway Inputs
        Springs.swayX.target = -e.movementX * 0.002;
        Springs.swayY.target = -e.movementY * 0.002;
        Springs.roll.target = -e.movementX * 0.005;

        // Motion blur from camera rotation (subtle)
        motionBlurX = Math.min(0.012, Math.abs(e.movementX) * 0.0004) * Math.sign(e.movementX);
        motionBlurY = Math.min(0.008, Math.abs(e.movementY) * 0.0004) * Math.sign(e.movementY);
    }
});

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    const dt = Math.min((time - prevTime) / 1000, 0.1); // Cap dt
    prevTime = time;

    // ADS Logic + Sprint FOV
    const targetPos = isAiming ? aimPos : hipPos;
    const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
    const targetFOV = isAiming ? 55 : (isSprinting ? 100 : 90);

    // Smooth transition for base position (Lerp is fine for macroscopic movements)
    recoilGroup.position.lerp(targetPos, 15 * dt);
    currentFOV = THREE.MathUtils.lerp(currentFOV, targetFOV, 8 * dt);
    camera.fov = currentFOV;
    camera.updateProjectionMatrix();

    // Hide crosshair when aiming
    crosshair.style.opacity = isAiming ? 0 : 1;

    // Update Springs
    const recoilZ = Springs.recoilZ.update(dt);
    const recoilX = Springs.recoilX.update(dt);
    const recoilY = Springs.recoilY.update(dt);
    const swayX = Springs.swayX.update(dt);
    const swayY = Springs.swayY.update(dt);
    const bobY = Springs.bobY.update(dt);
    const roll = Springs.roll.update(dt);
    const shakeX = Springs.shakeX.update(dt);
    const shakeY = Springs.shakeY.update(dt);

    // Apply Springs to Gun
    // Z: Recoil kick + Bob
    gunGroup.position.z = recoilZ;
    
    // Y: Bob + Recoil Lift (Combined)
    gunGroup.position.y = bobY + recoilY;

    // Rotation: Recoil Rise + Sway + Roll
    gunGroup.rotation.x = recoilX + swayY;
    gunGroup.rotation.y = Math.PI + swayX;
    gunGroup.rotation.z = roll + swayX * 0.5;

    // Reset Spring Targets (Damping brings them to 0)
    Springs.swayX.target = 0;
    Springs.swayY.target = 0;
    Springs.roll.target = 0;
    Springs.recoilZ.target = 0;
    Springs.recoilX.target = 0;
    Springs.recoilY.target = 0;

    // Camera Recoil Recovery + Screen Shake
    cameraRecoil = THREE.MathUtils.lerp(cameraRecoil, 0, 0.1);
    camera.rotation.set(
        cameraPitch + cameraRecoil + shakeY * 0.02,
        cameraYaw + shakeX * 0.02,
        roll * 0.1,
        'YXZ'
    );

    // Movement
    if (document.pointerLockElement === document.body) {
        velocity.x -= velocity.x * 10.0 * dt;
        velocity.z -= velocity.z * 10.0 * dt;
        const fIn = Number(moveState.f) - Number(moveState.b);
        const rIn = Number(moveState.r) - Number(moveState.l);

        // Sprinting logic - only when moving forward and not aiming
        const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
        const currentSpeed = isAiming ? baseSpeed * 0.5 : (isSprinting ? baseSpeed * sprintMultiplier : baseSpeed);

        if (moveState.f || moveState.b) velocity.z += fIn * currentSpeed * 10.0 * dt;
        if (moveState.l || moveState.r) velocity.x += rIn * currentSpeed * 10.0 * dt;

        const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
        const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
        camera.position.addScaledVector(fwd, velocity.z * dt);
        camera.position.addScaledVector(rgt, velocity.x * dt);

        // Jump physics
        if (!isGrounded) {
            verticalVelocity -= gravity * dt;
            playerHeight += verticalVelocity * dt;

            // Landing
            if (playerHeight <= groundLevel) {
                playerHeight = groundLevel;
                const landingImpact = Math.abs(verticalVelocity);
                verticalVelocity = 0;
                isGrounded = true;

                // Smooth landing effect based on fall speed
                if (landingImpact > 5) {
                    Springs.landing.impulse(landingImpact * 0.15);
                    Springs.bobY.impulse(landingImpact * 0.08);
                    // Screen shake on hard landing
                    if (landingImpact > 10) {
                        Springs.shakeY.impulse(-landingImpact * 0.3);
                    }
                }
            }
        }

        // Apply landing spring
        const landingOffset = Springs.landing.update(dt);
        Springs.landing.target = 0;

        // Set camera Y position (base + jump height - landing dip)
        camera.position.y = playerHeight - landingOffset * 0.1;

        // Procedural Bobbing (Walking/Sprinting)
        const vLen = Math.sqrt(velocity.x*velocity.x + velocity.z*velocity.z);
        const bobSpeed = isSprinting ? 0.022 : 0.015;
        const bobIntensity = isSprinting ? 0.08 : 0.05;

        if(vLen > 0.1 && !isReloading && isGrounded) {
            Springs.bobY.target = Math.sin(time * bobSpeed) * bobIntensity * (vLen/baseSpeed);
            Springs.swayX.target += Math.cos(time * bobSpeed * 0.5) * 0.02 * (vLen/baseSpeed);
            // Extra roll when sprinting
            if (isSprinting) {
                Springs.roll.target += Math.sin(time * bobSpeed) * 0.015;
            }
        } else if (isGrounded) {
            Springs.bobY.target = 0;
        }
    }

    if (isFiring) shoot();

    // Decay Enhanced Flash
    if (flashCoreMat.opacity > 0.01) {
        flashCoreMat.opacity = Math.max(0, flashCoreMat.opacity - 0.25);
        flashMidMat.opacity = Math.max(0, flashMidMat.opacity - 0.2);
        flashOuterMat.opacity = Math.max(0, flashOuterMat.opacity - 0.15);
        flashStreakMat.opacity = Math.max(0, flashStreakMat.opacity - 0.2);
        muzzleLight.intensity = Math.max(0, muzzleLight.intensity - 4);
    } else {
        flashCoreMat.opacity = 0;
        flashMidMat.opacity = 0;
        flashOuterMat.opacity = 0;
        flashStreakMat.opacity = 0;
        muzzleLight.intensity = 0;
    }

    // Decay dynamic post-processing
    bloomIntensity = THREE.MathUtils.lerp(bloomIntensity, 0.08, 0.15);
    chromaticAmount = THREE.MathUtils.lerp(chromaticAmount, 0.0005, 0.1);
    bloomPass.strength = bloomIntensity;
    chromaticPass.uniforms.amount.value = chromaticAmount;

    // Update motion blur based on camera rotation velocity
    motionBlurX = THREE.MathUtils.lerp(motionBlurX, 0, 0.2);
    motionBlurY = THREE.MathUtils.lerp(motionBlurY, 0, 0.2);
    motionBlurPass.uniforms.velocityX.value = motionBlurX;
    motionBlurPass.uniforms.velocityY.value = motionBlurY;

    // Update film grain time
    grainPass.uniforms.time.value = time * 0.001;

    // Reset screen shake targets
    Springs.shakeX.target = 0;
    Springs.shakeY.target = 0;
    
    // Bolt Recovery (Spring-ish)
    if (!isReloading && bolt.position.z < -0.5) bolt.position.z += 0.1;

    // Entity Updates
    for(let s of shells) {
        s.position.addScaledVector(s.userData.velocity, dt * 60);
        s.userData.velocity.y -= 0.02; s.rotation.x += 0.2;
        if(s.position.y < -5) { s.position.y = -5; s.userData.velocity.set(0,0,0); }
        if(--s.userData.life <= 0) { scene.remove(s); shells.splice(shells.indexOf(s), 1); }
    }
    for(let m of mags) {
        m.position.addScaledVector(m.userData.vel, dt * 60);
        m.rotation.x += m.userData.rot.x * 0.1;
        m.userData.vel.y -= 0.02;
        if(m.position.y < -5) { m.position.y = -5; m.userData.vel.set(0,0,0); }
        if(--m.userData.life <= 0) { scene.remove(m); mags.splice(mags.indexOf(m), 1); }
    }
    for(let i = smokeParticles.length - 1; i >= 0; i--) {
        const s = smokeParticles[i];
        s.age += dt;
        const r = s.age / s.life;
        if(r >= 1) {
            scene.remove(s.mesh);
            smokeParticles.splice(i, 1);
            continue;
        }
        s.mesh.position.addScaledVector(s.velocity, dt);
        if(s.hot) {
            // Hot smoke fades faster and stays smaller
            s.mesh.scale.setScalar(0.3 + r * 1.5);
            s.mesh.material.opacity = 0.6 * (1 - r);
        } else {
            s.mesh.scale.setScalar(0.5 + r * 4);
            s.mesh.material.opacity = 0.5 * (1 - r);
        }
        s.velocity.y += 1.5 * dt;
        s.velocity.multiplyScalar(0.99); // Air resistance
    }

    // Update sparks
    for(let i = sparks.length - 1; i >= 0; i--) {
        const sp = sparks[i];
        sp.userData.life -= dt;
        if(sp.userData.life <= 0) {
            scene.remove(sp);
            sparks.splice(i, 1);
            continue;
        }
        sp.position.addScaledVector(sp.userData.velocity, dt);
        sp.userData.velocity.y -= 20 * dt; // Gravity
        sp.material.opacity = sp.userData.life * 3;
    }

    // Update debris
    for(let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.userData.life--;
        if(d.userData.life <= 0) {
            scene.remove(d);
            debris.splice(i, 1);
            continue;
        }
        d.position.addScaledVector(d.userData.velocity, dt);
        d.userData.velocity.y -= 15 * dt; // Gravity
        d.rotation.x += d.userData.rotVel.x * dt;
        d.rotation.y += d.userData.rotVel.y * dt;
        d.rotation.z += d.userData.rotVel.z * dt;
        // Stop at floor
        if(d.position.y < -4.9) {
            d.position.y = -4.9;
            d.userData.velocity.set(0, 0, 0);
            d.userData.rotVel.multiplyScalar(0.9);
        }
    }
    for(let i=tracers.length-1; i>=0; i--) {
        const t = tracers[i];
        t.life--;
        t.mesh.material.opacity = t.life / 3;
        if(t.life <= 0) { scene.remove(t.mesh); tracers.splice(i, 1); }
    }
    for(let i=decals.length-1; i>=0; i--) {
        const d = decals[i];
        d.life--;
        if(d.life < 60) d.mesh.material.opacity = d.life / 60;
        if(d.life <= 0) { scene.remove(d.mesh); decals.splice(i, 1); }
    }

    // Update shooting targets
    for (const target of shootingTargets) {
        target.update(dt);
    }

    // Update bots
    for (const bot of bots) {
        bot.update(dt, time);
    }

    // Update blood and gore effects
    updateBloodEffects(dt);

    // Animate dust particles (gentle drift)
    const dustPos = dustGeo.attributes.position.array;
    for(let i = 0; i < dustCount; i++) {
        dustPos[i * 3 + 1] += Math.sin(time * 0.0005 + i) * 0.002;
        // Wrap around camera
        const dx = dustPos[i * 3] - camera.position.x;
        const dz = dustPos[i * 3 + 2] - camera.position.z;
        if(Math.abs(dx) > 100) dustPos[i * 3] = camera.position.x + (Math.random() - 0.5) * 200;
        if(Math.abs(dz) > 100) dustPos[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 200;
    }
    dustGeo.attributes.position.needsUpdate = true;

    // Render with post-processing
    composer.render();
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth, window.innerHeight);
});

animate(performance.now());
</script>
</body>
</html>