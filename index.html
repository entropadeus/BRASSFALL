<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZOMBIE SURVIVAL</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.7); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            transition: width 0.1s, height 0.1s, opacity 0.2s;
        }
        #hitmarker {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            transform: translate(-50%, -50%); pointer-events: none;
            opacity: 0; transition: opacity 0.05s;
        }
        #hitmarker.show {
            opacity: 1;
        }
        #hitmarker.headshot .hm-line {
            background: rgba(255, 0, 0, 1);
            width: 28px; height: 3px;
            box-shadow: 0 0 10px #f00, 0 0 20px #f00;
        }
        .hm-line {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 2px;
            background: rgba(180, 180, 180, 0.5);
            transform-origin: center;
        }
        .hm-line:first-child {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        .hm-line:last-child {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        /* ============ MICRO-ANIMATION POLISHES ============ */
        @keyframes pulse-glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.3); }
        }
        @keyframes score-pop {
            0% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.15); }
            100% { transform: translateX(-50%) scale(1); }
        }
        @keyframes ammo-shake {
            0%, 100% { transform: translateX(0); }
            20% { transform: translateX(-2px); }
            40% { transform: translateX(2px); }
            60% { transform: translateX(-1px); }
            80% { transform: translateX(1px); }
        }
        @keyframes wave-entrance {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }
        @keyframes health-critical {
            0%, 100% { box-shadow: 0 0 5px #f00; }
            50% { box-shadow: 0 0 15px #f00, 0 0 25px #f00; }
        }
        @keyframes kill-flash {
            0% { color: #fff; text-shadow: 0 0 10px #fff; }
            100% { color: #888; text-shadow: none; }
        }
        @keyframes reload-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #ammo-display {
            position: absolute; bottom: 20px; right: 20px; color: #0f0;
            font-size: 28px; pointer-events: none; user-select: none;
            text-shadow: 0 0 5px #0f0;
            transition: all 0.15s ease-out;
        }
        #ammo-display.low-ammo {
            color: #f80; text-shadow: 0 0 8px #f80;
            animation: ammo-shake 0.3s ease-in-out;
        }
        #ammo-display.empty {
            color: #f00; text-shadow: 0 0 10px #f00;
            animation: pulse-glow 0.5s ease-in-out infinite;
        }
        #ammo-display.reloading {
            animation: reload-pulse 0.4s ease-in-out infinite;
        }
        #blocker, #game-over {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; cursor: pointer; z-index: 10;
        }
        #top-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center;
            pointer-events: none; user-select: none;
        }
        #wave-display {
            font-size: 32px; color: #f00; text-shadow: 0 0 10px #f00;
            letter-spacing: 4px;
            transition: all 0.3s ease-out;
        }
        #wave-display.new-wave {
            animation: wave-entrance 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #zombie-count {
            font-size: 16px; color: #888; margin-top: 5px;
            transition: color 0.2s;
        }
        #zombie-count.kill-flash {
            animation: kill-flash 0.3s ease-out;
        }
        #score-display {
            font-size: 20px; color: #ff0; text-shadow: 0 0 5px #ff0;
            margin-top: 10px; letter-spacing: 2px;
            transition: all 0.15s ease-out;
        }
        #score-display.score-bump {
            animation: score-pop 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        #health-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
            pointer-events: none; user-select: none;
        }
        #health-bar {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #0f0;
            overflow: hidden;
            transition: border-color 0.3s;
        }
        #health-bar.critical {
            border-color: #f00;
            animation: health-critical 0.8s ease-in-out infinite;
        }
        #health-fill {
            width: 100%; height: 100%;
            background: linear-gradient(90deg, #0f0, #0a0);
            transition: width 0.25s ease-out, background 0.3s;
        }
        #health-fill.damaged {
            background: linear-gradient(90deg, #f80, #a50);
        }
        #health-fill.critical {
            background: linear-gradient(90deg, #f00, #800);
        }
        #health-text {
            font-size: 24px; color: #0f0; text-shadow: 0 0 5px #0f0;
            min-width: 40px;
            transition: all 0.2s;
        }
        #health-text.critical {
            color: #f00; text-shadow: 0 0 8px #f00;
        }
        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%);
            pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }
        /* === DAMAGE DIRECTION INDICATOR === */
        #damage-direction {
            position: absolute; top: 50%; left: 50%; width: 300px; height: 300px;
            transform: translate(-50%, -50%);
            pointer-events: none; z-index: 50;
        }
        .damage-arrow {
            position: absolute; width: 80px; height: 40px;
            background: linear-gradient(90deg, transparent 0%, rgba(255,0,0,0.8) 50%, transparent 100%);
            opacity: 0; transition: opacity 0.1s;
            filter: blur(2px);
        }
        .damage-arrow.top { top: 0; left: 50%; transform: translateX(-50%) rotate(-90deg); }
        .damage-arrow.bottom { bottom: 0; left: 50%; transform: translateX(-50%) rotate(90deg); }
        .damage-arrow.left { left: 0; top: 50%; transform: translateY(-50%) rotate(180deg); }
        .damage-arrow.right { right: 0; top: 50%; transform: translateY(-50%); }
        .damage-arrow.top-left { top: 15%; left: 15%; transform: rotate(-135deg); }
        .damage-arrow.top-right { top: 15%; right: 15%; transform: rotate(-45deg); }
        .damage-arrow.bottom-left { bottom: 15%; left: 15%; transform: rotate(135deg); }
        .damage-arrow.bottom-right { bottom: 15%; right: 15%; transform: rotate(45deg); }
        /* === LOW HEALTH VIGNETTE === */
        #low-health-vignette {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; opacity: 0; z-index: 45;
            box-shadow: inset 0 0 150px rgba(255, 0, 0, 0.6);
            transition: opacity 0.3s;
        }
        #low-health-vignette.pulse {
            animation: lowHealthPulse 1s ease-in-out infinite;
        }
        @keyframes lowHealthPulse {
            0%, 100% { box-shadow: inset 0 0 100px rgba(255, 0, 0, 0.4); }
            50% { box-shadow: inset 0 0 180px rgba(255, 0, 0, 0.7); }
        }
        /* === DYNAMIC CROSSHAIR === */
        #crosshair {
            transition: width 0.08s ease-out, height 0.08s ease-out, opacity 0.2s, border-color 0.15s;
        }
        #crosshair.firing {
            border-color: rgba(255, 200, 0, 0.9);
        }
        #crosshair.moving {
            border-color: rgba(0, 200, 255, 0.7);
        }
        #restart-btn {
            transition: all 0.2s ease-out;
        }
        #restart-btn:hover {
            background: #500; box-shadow: 0 0 20px #f00;
            transform: scale(1.05);
        }
        #restart-btn:active {
            transform: scale(0.98);
        }
    </style>
</head>
<body>

<div id="blocker">
    <h1>ZOMBIE SURVIVAL</h1>
    <p style="color: #0f0; font-size: 18px;">Survive the zombie horde!</p>
    <p>Click to Start</p>
    <p style="color: #888;">WASD: Move | SHIFT: Sprint | SPACE: Jump | LMB: Shoot | RMB: Aim | R: Reload</p>
</div>

<div id="game-over" style="display: none;">
    <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">YOU DIED</h1>
    <p style="font-size: 24px;">SCORE: <span id="final-score">0</span></p>
    <p style="font-size: 18px;">Survived to Wave <span id="final-wave">1</span></p>
    <button id="restart-btn" onclick="restartGame()" style="margin-top: 20px; padding: 15px 40px; font-size: 20px; background: #300; color: #f00; border: 2px solid #f00; cursor: pointer; font-family: inherit;">RESTART</button>
</div>

<div id="crosshair"></div>
<div id="hitmarker">
    <div class="hm-line"></div>
    <div class="hm-line"></div>
</div>

<div id="damage-flash"></div>

<!-- Damage Direction Indicator -->
<div id="damage-direction">
    <div class="damage-arrow top"></div>
    <div class="damage-arrow bottom"></div>
    <div class="damage-arrow left"></div>
    <div class="damage-arrow right"></div>
    <div class="damage-arrow top-left"></div>
    <div class="damage-arrow top-right"></div>
    <div class="damage-arrow bottom-left"></div>
    <div class="damage-arrow bottom-right"></div>
</div>

<!-- Low Health Vignette -->
<div id="low-health-vignette"></div>

<!-- Top HUD - Wave and Score -->
<div id="top-hud">
    <div id="wave-display">GET READY...</div>
    <div id="zombie-count">0 ZOMBIES</div>
    <div id="score-display">00000000</div>
</div>

<!-- Bottom Left - Health -->
<div id="health-container">
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    <div id="health-text">100</div>
</div>

<!-- Bottom Right - Ammo -->
<div id="ammo-display">30 / 90</div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Post-processing -->
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/FXAAShader.js"></script>
<!-- TWEEN.js for complex curves -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * MOTION DESIGN UTILS
 * Spring physics for procedural weight.
 */
// Enhanced Spring class with better physics simulation
class Spring {
    constructor(stiffness, damping, mass) {
        this.stiffness = stiffness;
        this.damping = damping;
        this.mass = mass;
        this.position = 0;
        this.velocity = 0;
        this.target = 0;
    }

    // Semi-implicit Euler for more stable, organic motion
    update(dt) {
        const displacement = this.position - this.target;
        const springForce = -this.stiffness * displacement;
        const dampingForce = -this.damping * this.velocity;
        const acceleration = (springForce + dampingForce) / this.mass;

        this.velocity += acceleration * dt;
        this.position += this.velocity * dt;

        return this.position;
    }

    impulse(force) {
        this.velocity += force / this.mass;
    }

    // Smooth impulse over time for more organic feel
    softImpulse(force, smoothness = 0.5) {
        this.velocity += (force / this.mass) * smoothness;
        this.target += (force / this.mass) * (1 - smoothness) * 0.1;
    }
}

// Dual-spring system for extra organic lag
class DualSpring {
    constructor(primaryStiffness, primaryDamping, secondaryStiffness, secondaryDamping, mass) {
        this.primary = new Spring(primaryStiffness, primaryDamping, mass);
        this.secondary = new Spring(secondaryStiffness, secondaryDamping, mass * 1.5);
    }

    update(dt) {
        const primaryPos = this.primary.update(dt);
        this.secondary.target = primaryPos;
        return this.secondary.update(dt);
    }

    set target(val) { this.primary.target = val; }
    get target() { return this.primary.target; }

    impulse(force) {
        this.primary.impulse(force * 0.7);
        this.secondary.impulse(force * 0.3);
    }
}

// Separate springs for different axes - ULTRA FLUID & ORGANIC feel
const Springs = {
    // Gun sway - multi-layered for organic feel
    swayX: new Spring(65, 5, 1.4),       // Softer, more floaty
    swayY: new Spring(65, 5, 1.4),
    swayLagX: new Spring(30, 3.5, 1.8),  // More lag for fluidity
    swayLagY: new Spring(30, 3.5, 1.8),
    swayLag2X: new Spring(18, 2.5, 2.2), // Third layer of lag
    swayLag2Y: new Spring(18, 2.5, 2.2),

    // Recoil - snappy initial kick with soft follow-through
    recoilZ: new Spring(280, 14, 0.9),   // Quick snap back
    recoilX: new Spring(180, 9, 1.1),    // Muzzle climb - softer
    recoilY: new Spring(140, 8, 1.2),    // Vertical rise
    recoilRoll: new Spring(200, 12, 1),  // Rotational recoil

    // Recoil recovery (slower return to neutral)
    recoilRecoverZ: new Spring(40, 4, 2),
    recoilRecoverX: new Spring(35, 3.5, 2),

    // Movement feel - very organic
    bobY: new Spring(50, 4, 1.4),        // Floatier vertical bob
    bobX: new Spring(40, 3.5, 1.5),      // Side-to-side sway
    bobZ: new Spring(35, 3, 1.6),        // Forward/back bob (new)
    roll: new Spring(45, 4, 1.3),        // Hip roll
    tilt: new Spring(30, 3, 1.5),        // Forward lean

    // Momentum/inertia
    momentumX: new Spring(25, 2.5, 2),   // Weapon trails behind movement
    momentumZ: new Spring(25, 2.5, 2),

    // Breathing/idle - very subtle organic motion
    breathe: new Spring(15, 1.5, 2.5),   // Slow breathing
    idleSway: new Spring(8, 1, 3),       // Ultra slow idle drift
    heartbeat: new Spring(100, 8, 0.5),  // Subtle pulse

    // Screen shake - responsive but not jarring
    shakeX: new Spring(250, 16, 1),
    shakeY: new Spring(250, 16, 1),
    shakeRoll: new Spring(200, 14, 1),   // Rotational shake

    // Camera smoothing - cinematic lag
    camLagX: new Spring(80, 6, 1.2),
    camLagY: new Spring(80, 6, 1.2),

    // ADS transition smoothing
    adsTransition: new Spring(120, 10, 1),
    adsFov: new Spring(100, 8, 1),

    // Landing impact
    landing: new Spring(200, 15, 1),
    landingTilt: new Spring(150, 12, 1),

    // Sprinting effects
    sprintBob: new Spring(70, 5, 1.2),
    sprintTilt: new Spring(50, 4, 1.3),
    sprintRoll: new Spring(60, 4.5, 1.2),

    // === NEW: Attention to Detail Springs ===
    // Strafe lean - weapon and camera tilt when strafing
    strafeTilt: new Spring(80, 6, 1.2),
    strafeRoll: new Spring(60, 5, 1.3),

    // Velocity-based weapon drag (trails behind fast movements)
    velocityDragX: new Spring(40, 4, 1.5),
    velocityDragY: new Spring(40, 4, 1.5),

    // Turn inertia - weapon lags when spinning camera fast
    turnLagX: new Spring(50, 4.5, 1.4),
    turnLagY: new Spring(50, 4.5, 1.4),

    // Weapon inspection sway
    inspectRotX: new Spring(25, 3, 2),
    inspectRotY: new Spring(25, 3, 2),
    inspectRotZ: new Spring(20, 2.5, 2),

    // Bolt carrier
    boltZ: new Spring(400, 18, 0.8),

    // Dynamic crosshair
    crosshairSpread: new Spring(120, 10, 1)
};

// Velocity tracking for inertia effects
let lastCamYaw = 0;
let lastCamPitch = 0;
let camVelX = 0;
let camVelY = 0;
let moveVelSmooth = 0;
let moveVelX = 0;
let moveVelZ = 0;

// === NEW: Attention to Detail State ===
let lastStrafeInput = 0;
let idleTime = 0;                    // Time since last movement/action
let isInspecting = false;            // Weapon inspection mode
let inspectPhase = 0;                // Phase of inspection animation
let lastFireTime = 0;                // For muzzle smoke timing
let consecutiveShots = 0;            // For heat buildup
let crosshairBaseSize = 20;          // Base crosshair size
let crosshairCurrentSize = 20;       // Current crosshair size
let lastDamageDir = null;            // Direction of last damage taken
let damageIndicatorAlpha = 0;        // Fade for damage indicator
let lowHealthPulse = 0;              // Pulse phase for low health effects

// Organic noise for idle animations
function organicNoise(time, frequency, octaves = 3) {
    let value = 0;
    let amplitude = 1;
    let freq = frequency;
    for (let i = 0; i < octaves; i++) {
        value += Math.sin(time * freq) * amplitude;
        value += Math.cos(time * freq * 1.3) * amplitude * 0.5;
        freq *= 2.1;
        amplitude *= 0.5;
    }
    return value;
}

/**
 * CUSTOM POST-PROCESSING SHADERS
 */
const VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        intensity: { value: 0.4 },
        smoothness: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float intensity;
        uniform float smoothness;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 center = vUv - 0.5;
            float dist = length(center);
            float vignette = smoothstep(0.5, 0.5 - smoothness, dist * (intensity + 0.5));
            color.rgb *= vignette;
            gl_FragColor = color;
        }
    `
};

const ChromaticAberrationShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
    `
};

const FilmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.03 },
        speed: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        varying vec2 vUv;

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float grain = random(vUv + time) * 2.0 - 1.0;
            color.rgb += grain * intensity;
            gl_FragColor = color;
        }
    `
};

const MotionBlurShader = {
    uniforms: {
        tDiffuse: { value: null },
        velocityX: { value: 0.0 },
        velocityY: { value: 0.0 },
        samples: { value: 4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float velocityX;
        uniform float velocityY;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 velocity = vec2(velocityX, velocityY);
            float speed = length(velocity);

            if (speed < 0.001) {
                gl_FragColor = texture2D(tDiffuse, vUv);
                return;
            }

            vec2 dir = velocity / speed;
            vec4 color = vec4(0.0);
            float total = 0.0;

            for (float i = 0.0; i < 16.0; i++) {
                if (i >= samples) break;
                float t = (i / (samples - 1.0)) - 0.5;
                vec2 offset = dir * t * speed;
                float weight = 1.0 - abs(t * 2.0);
                color += texture2D(tDiffuse, vUv + offset) * weight;
                total += weight;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ SSAO (Screen Space Ambient Occlusion) ============
const SSAOShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        radius: { value: 0.5 },
        aoStrength: { value: 1.2 },
        falloff: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float radius;
        uniform float aoStrength;
        uniform float falloff;
        varying vec2 vUv;

        float readDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = (cameraNear * cameraFar) / ((cameraFar - cameraNear) * fragCoordZ - cameraFar);
            return viewZ;
        }

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = readDepth(vUv);

            if (depth > -1.0) {
                gl_FragColor = color;
                return;
            }

            float ao = 0.0;
            float sampleRadius = radius / abs(depth);

            const int samples = 16;
            for (int i = 0; i < samples; i++) {
                float angle = float(i) * 2.39996322973;
                float r = sampleRadius * (float(i + 1) / float(samples));
                vec2 offset = vec2(cos(angle), sin(angle)) * r;
                offset += (vec2(random(vUv + float(i)), random(vUv - float(i))) - 0.5) * sampleRadius * 0.25;

                float sampleDepth = readDepth(vUv + offset);
                float rangeCheck = smoothstep(0.0, 1.0, falloff / abs(depth - sampleDepth));
                ao += (sampleDepth > depth + 0.01 ? 1.0 : 0.0) * rangeCheck;
            }

            ao = 1.0 - (ao / float(samples)) * aoStrength;
            ao = clamp(ao, 0.0, 1.0);

            color.rgb *= ao;
            gl_FragColor = color;
        }
    `
};

// ============ VOLUMETRIC GOD RAYS ============
const GodRaysShader = {
    uniforms: {
        tDiffuse: { value: null },
        lightPositionOnScreen: { value: new THREE.Vector2(0.3, 0.7) },
        exposure: { value: 0.35 },
        decay: { value: 0.96 },
        density: { value: 0.8 },
        weight: { value: 0.6 },
        samples: { value: 60 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPositionOnScreen;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 texCoord = vUv;
            vec2 deltaTexCoord = texCoord - lightPositionOnScreen;
            deltaTexCoord *= 1.0 / samples * density;

            vec4 color = texture2D(tDiffuse, texCoord);
            float illuminationDecay = 1.0;
            vec4 accumulatedColor = vec4(0.0);

            for (int i = 0; i < 100; i++) {
                if (float(i) >= samples) break;
                texCoord -= deltaTexCoord;
                vec4 sampleColor = texture2D(tDiffuse, texCoord);
                float luminance = dot(sampleColor.rgb, vec3(0.299, 0.587, 0.114));
                sampleColor *= illuminationDecay * weight * luminance;
                accumulatedColor += sampleColor;
                illuminationDecay *= decay;
            }

            accumulatedColor *= exposure;
            accumulatedColor.rgb = clamp(accumulatedColor.rgb, 0.0, 1.0);

            gl_FragColor = color + accumulatedColor * vec4(1.0, 0.9, 0.7, 1.0);
        }
    `
};

// ============ DEPTH OF FIELD (Bokeh) ============
const DepthOfFieldShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        focusDistance: { value: 10.0 },
        focusRange: { value: 5.0 },
        bokehStrength: { value: 2.0 },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float focusDistance;
        uniform float focusRange;
        uniform float bokehStrength;
        uniform float cameraNear;
        uniform float cameraFar;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            float depth = getDepth(vUv);
            float blur = abs(depth - focusDistance) / focusRange;
            blur = clamp(blur * bokehStrength, 0.0, 1.0);

            vec2 texelSize = 1.0 / resolution;
            vec4 color = vec4(0.0);
            float total = 0.0;

            // Hexagonal bokeh pattern
            const int SAMPLES = 36;
            for (int i = 0; i < SAMPLES; i++) {
                float angle = float(i) * 6.28318530718 / float(SAMPLES);
                float dist = blur * 8.0 * (0.5 + 0.5 * fract(float(i) * 0.618));
                vec2 offset = vec2(cos(angle), sin(angle)) * texelSize * dist;
                color += texture2D(tDiffuse, vUv + offset);
                total += 1.0;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ LENS FLARE SHADER ============
const LensFlareShader = {
    uniforms: {
        tDiffuse: { value: null },
        sunPosition: { value: new THREE.Vector2(0.3, 0.7) },
        sunVisible: { value: 1.0 },
        flareStrength: { value: 0.4 },
        ghostStrength: { value: 0.3 },
        haloStrength: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 sunPosition;
        uniform float sunVisible;
        uniform float flareStrength;
        uniform float ghostStrength;
        uniform float haloStrength;
        varying vec2 vUv;

        vec3 flareColor(float t) {
            return mix(vec3(1.0, 0.6, 0.3), vec3(1.0, 0.9, 0.6), t);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            if (sunVisible < 0.01) {
                gl_FragColor = color;
                return;
            }

            vec2 sunToCenter = vec2(0.5) - sunPosition;
            vec2 flareVector = sunToCenter;

            // Main sun glow
            float distToSun = length(vUv - sunPosition);
            float glow = exp(-distToSun * 4.0) * flareStrength * sunVisible;
            color.rgb += flareColor(0.0) * glow;

            // Ghost flares (reflections along the flare vector)
            for (int i = 1; i < 6; i++) {
                float t = float(i) / 6.0;
                vec2 ghostPos = sunPosition + flareVector * (0.3 + t * 1.4);
                float ghostDist = length(vUv - ghostPos);
                float ghostSize = 0.05 + t * 0.03;
                float ghost = smoothstep(ghostSize, 0.0, ghostDist) * ghostStrength * sunVisible;
                ghost *= (1.0 - t * 0.5);
                color.rgb += flareColor(t) * ghost * 0.5;
            }

            // Halo ring
            float haloDist = abs(length(vUv - sunPosition) - 0.25);
            float halo = smoothstep(0.02, 0.0, haloDist) * haloStrength * sunVisible * 0.3;
            color.rgb += vec3(1.0, 0.8, 0.5) * halo;

            // Anamorphic streak
            float streakX = exp(-abs(vUv.y - sunPosition.y) * 30.0) * exp(-abs(vUv.x - sunPosition.x) * 2.0);
            color.rgb += vec3(1.0, 0.7, 0.4) * streakX * flareStrength * sunVisible * 0.3;

            gl_FragColor = color;
        }
    `
};

// ============ HEAT DISTORTION / HAZE ============
const HeatDistortionShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        distortionStrength: { value: 0.003 },
        heatLine: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float distortionStrength;
        uniform float heatLine;
        varying vec2 vUv;

        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);

            float a = noise(i);
            float b = noise(i + vec2(1.0, 0.0));
            float c = noise(i + vec2(0.0, 1.0));
            float d = noise(i + vec2(1.0, 1.0));

            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        void main() {
            // Heat distortion strongest near bottom of screen (ground level)
            float heatMask = smoothstep(heatLine + 0.15, heatLine, vUv.y);

            // Multi-octave noise for realistic heat waves
            float n1 = smoothNoise(vUv * 20.0 + vec2(time * 0.5, time * 0.3));
            float n2 = smoothNoise(vUv * 40.0 + vec2(-time * 0.3, time * 0.5));
            float n3 = smoothNoise(vUv * 80.0 + vec2(time * 0.4, -time * 0.2));

            float distortion = (n1 * 0.5 + n2 * 0.3 + n3 * 0.2) * 2.0 - 1.0;

            vec2 offset = vec2(distortion, distortion * 0.5) * distortionStrength * heatMask;

            vec4 color = texture2D(tDiffuse, vUv + offset);

            gl_FragColor = color;
        }
    `
};

// ============ COLOR GRADING / LUT ============
const ColorGradingShader = {
    uniforms: {
        tDiffuse: { value: null },
        contrast: { value: 1.15 },
        saturation: { value: 1.2 },
        brightness: { value: 1.0 },
        // Shadows, midtones, highlights color adjustments
        shadowColor: { value: new THREE.Vector3(0.1, 0.05, 0.15) },
        midtoneColor: { value: new THREE.Vector3(1.0, 0.95, 0.9) },
        highlightColor: { value: new THREE.Vector3(1.0, 0.9, 0.8) },
        // Lift, gamma, gain (standard color grading)
        lift: { value: new THREE.Vector3(0.0, 0.0, 0.02) },
        gamma: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
        gain: { value: new THREE.Vector3(1.0, 0.98, 0.95) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float contrast;
        uniform float saturation;
        uniform float brightness;
        uniform vec3 shadowColor;
        uniform vec3 midtoneColor;
        uniform vec3 highlightColor;
        uniform vec3 lift;
        uniform vec3 gamma;
        uniform vec3 gain;
        varying vec2 vUv;

        vec3 adjustSaturation(vec3 color, float sat) {
            float luma = dot(color, vec3(0.299, 0.587, 0.114));
            return mix(vec3(luma), color, sat);
        }

        vec3 adjustContrast(vec3 color, float con) {
            return (color - 0.5) * con + 0.5;
        }

        vec3 liftGammaGain(vec3 color, vec3 lift, vec3 gamma, vec3 gain) {
            vec3 lerpV = clamp(pow(color, 1.0 / gamma), 0.0, 1.0);
            return gain * lerpV + lift * (1.0 - lerpV);
        }

        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            vec3 color = texel.rgb;

            // Brightness
            color *= brightness;

            // Contrast
            color = adjustContrast(color, contrast);

            // Saturation
            color = adjustSaturation(color, saturation);

            // Lift/Gamma/Gain
            color = liftGammaGain(color, lift, gamma, gain);

            // Color tinting based on luminance
            float luma = dot(color, vec3(0.299, 0.587, 0.114));

            // Shadow tint (dark areas get cool/purple tint)
            float shadowMask = 1.0 - smoothstep(0.0, 0.3, luma);
            color = mix(color, color * shadowColor * 3.0, shadowMask * 0.3);

            // Highlight tint (bright areas get warm tint)
            float highlightMask = smoothstep(0.6, 1.0, luma);
            color = mix(color, color * highlightColor, highlightMask * 0.4);

            // Midtone tint
            float midtoneMask = 1.0 - abs(luma - 0.5) * 2.0;
            color *= mix(vec3(1.0), midtoneColor, midtoneMask * 0.2);

            gl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);
        }
    `
};

// ============ SCREEN SPACE REFLECTIONS (Simplified) ============
const SSRShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        reflectionStrength: { value: 0.3 },
        groundLevel: { value: 0.25 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float reflectionStrength;
        uniform float groundLevel;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Only apply reflections near ground level (bottom portion of screen)
            float reflectionMask = smoothstep(groundLevel + 0.1, groundLevel, vUv.y);

            if (reflectionMask > 0.01) {
                // Mirror UV for reflection
                vec2 reflectedUv = vec2(vUv.x, groundLevel + (groundLevel - vUv.y));

                if (reflectedUv.y >= 0.0 && reflectedUv.y <= 1.0) {
                    vec4 reflectedColor = texture2D(tDiffuse, reflectedUv);

                    // Fade reflection based on distance from ground
                    float fadeFactor = 1.0 - abs(vUv.y - groundLevel) * 4.0;
                    fadeFactor = clamp(fadeFactor, 0.0, 1.0);

                    // Blend with roughness simulation (blur)
                    float blur = (groundLevel - vUv.y) * 0.05;
                    vec4 blurredReflection = vec4(0.0);
                    float total = 0.0;
                    for (int i = -2; i <= 2; i++) {
                        for (int j = -2; j <= 2; j++) {
                            vec2 offset = vec2(float(i), float(j)) * blur;
                            blurredReflection += texture2D(tDiffuse, reflectedUv + offset);
                            total += 1.0;
                        }
                    }
                    reflectedColor = blurredReflection / total;

                    color.rgb = mix(color.rgb, reflectedColor.rgb, reflectionMask * reflectionStrength * fadeFactor);
                }
            }

            gl_FragColor = color;
        }
    `
};

// ============ ATMOSPHERIC SCATTERING ============
const AtmosphericScatteringShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        fogColor: { value: new THREE.Vector3(0.4, 0.2, 0.15) },
        fogDensity: { value: 0.015 },
        sunDirection: { value: new THREE.Vector3(-0.5, 0.2, -0.8) },
        sunColor: { value: new THREE.Vector3(1.0, 0.7, 0.4) },
        scatteringStrength: { value: 0.4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform vec3 fogColor;
        uniform float fogDensity;
        uniform vec3 sunDirection;
        uniform vec3 sunColor;
        uniform float scatteringStrength;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = getDepth(vUv);

            // Exponential fog
            float fogAmount = 1.0 - exp(-depth * fogDensity);
            fogAmount = clamp(fogAmount, 0.0, 1.0);

            // Add sun scattering based on view direction approximation
            vec2 screenCenter = vUv - 0.5;
            float viewSunDot = dot(normalize(vec3(screenCenter, 1.0)), normalize(sunDirection));
            viewSunDot = max(viewSunDot, 0.0);

            // Mie scattering (forward scattering from sun)
            float mie = pow(viewSunDot, 8.0) * scatteringStrength;

            vec3 scatterColor = mix(fogColor, sunColor, mie);

            color.rgb = mix(color.rgb, scatterColor, fogAmount);
            color.rgb += sunColor * mie * 0.2 * (1.0 - fogAmount);

            gl_FragColor = color;
        }
    `
};

// ============ CEL SHADING (Borderlands Style) ============
const CelShadingShader = {
    uniforms: {
        tDiffuse: { value: null },
        levels: { value: 4.0 },        // Number of color bands
        edgeIntensity: { value: 0.3 }, // How much to darken edges
        saturationBoost: { value: 1.2 } // Boost colors slightly
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float levels;
        uniform float edgeIntensity;
        uniform float saturationBoost;
        varying vec2 vUv;

        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Convert to HSV for better banding
            vec3 hsv = rgb2hsv(color.rgb);

            // Quantize value (brightness) into discrete levels
            float quantized = floor(hsv.z * levels + 0.5) / levels;

            // Boost saturation for that Borderlands pop
            hsv.y = min(hsv.y * saturationBoost, 1.0);
            hsv.z = quantized;

            // Convert back to RGB
            vec3 cel = hsv2rgb(hsv);

            gl_FragColor = vec4(cel, color.a);
        }
    `
};

const OutlineShader = {
    uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        outlineColor: { value: new THREE.Vector3(0.0, 0.0, 0.0) },
        thickness: { value: 1.0 },
        threshold: { value: 0.15 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform vec3 outlineColor;
        uniform float thickness;
        uniform float threshold;
        varying vec2 vUv;

        float luminance(vec3 color) {
            return dot(color, vec3(0.299, 0.587, 0.114));
        }

        void main() {
            vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y) * thickness;

            // Sample surrounding pixels (Sobel operator)
            float tl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, texel.y)).rgb);
            float t  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, texel.y)).rgb);
            float tr = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, texel.y)).rgb);
            float l  = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, 0.0)).rgb);
            float r  = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, 0.0)).rgb);
            float bl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, -texel.y)).rgb);
            float b  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, -texel.y)).rgb);
            float br = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, -texel.y)).rgb);

            // Sobel edge detection
            float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
            float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
            float edge = sqrt(gx*gx + gy*gy);

            vec4 color = texture2D(tDiffuse, vUv);

            // Apply outline where edges are detected
            if (edge > threshold) {
                // Blend toward outline color based on edge strength
                float blend = smoothstep(threshold, threshold + 0.1, edge);
                color.rgb = mix(color.rgb, outlineColor, blend * 0.9);
            }

            gl_FragColor = color;
        }
    `
};

// Dynamic post-processing values
let bloomIntensity = 0.15; // Warm sunset glow
let chromaticAmount = 0.0005;
let motionBlurX = 0.0;
let motionBlurY = 0.0;

// ============ PERFORMANCE: OBJECT POOLING ============
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = [];
        // Pre-allocate
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
        }
    }

    get() {
        let obj = this.pool.pop() || this.createFn();
        this.active.push(obj);
        return obj;
    }

    release(obj) {
        const idx = this.active.indexOf(obj);
        if (idx > -1) {
            this.active.splice(idx, 1);
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }

    releaseAll() {
        while (this.active.length > 0) {
            const obj = this.active.pop();
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }
}

// ============ INSTANCED PARTICLE SYSTEM ============
const MAX_BLOOD_PARTICLES = 120; // Reduced for performance
const MAX_SPARKS = 60; // Reduced for performance
const MAX_DEBRIS = 40; // Reduced for performance

// Reusable matrix and vectors for instanced updates
const _instanceMatrix = new THREE.Matrix4();
const _instancePos = new THREE.Vector3();
const _instanceQuat = new THREE.Quaternion();
const _instanceScale = new THREE.Vector3(1, 1, 1);
const _tempVec3 = new THREE.Vector3();

// Frame throttling for expensive operations
let frameCount = 0;
const SHADOW_UPDATE_INTERVAL = 3; // Update shadows every 3 frames
const HUD_UPDATE_INTERVAL = 2; // Update HUD every 2 frames
let lastHUDValues = { ammo: -1, reserve: -1, health: -1, score: -1, wave: -1 };

// Cached DOM references
let cachedDOM = null;
function getCachedDOM() {
    if (!cachedDOM) {
        cachedDOM = {
            ammoDisplay: document.getElementById('ammo-display'),
            healthFill: document.getElementById('health-fill'),
            healthText: document.getElementById('health-text'),
            waveDisplay: document.getElementById('wave-display'),
            zombieCount: document.getElementById('zombie-count'),
            scoreDisplay: document.getElementById('score-display'),
            damageFlash: document.getElementById('damage-flash')
        };
    }
    return cachedDOM;
}

/**
 * TEXTURE FACTORY
 */
const TextureFactory = {
    createCanvas: (size) => {
        const c = document.createElement('canvas');
        c.width = c.height = size;
        return { c, ctx: c.getContext('2d') };
    },
    
    noise: (ctx, w, h, opacity) => {
        const idata = ctx.getImageData(0,0,w,h);
        const data = idata.data;
        for(let i=0; i<data.length; i+=4) {
            const v = Math.random() * 255 * opacity;
            data[i] += v; data[i+1] += v; data[i+2] += v;
        }
        ctx.putImageData(idata, 0, 0);
    },

    wood: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.3;
        for(let i=0; i<150; i++) {
            ctx.strokeStyle = i%2===0 ? '#5d4037' : '#281a14';
            ctx.lineWidth = 1 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(0, Math.random()*size);
            ctx.bezierCurveTo(size/3, Math.random()*size, size*2/3, Math.random()*size, size, Math.random()*size);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.1);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    metal: (isDark) => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = isDark ? '#1a1a1a' : '#555555'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.1; ctx.strokeStyle = '#ffffff';
        for(let i=0; i<400; i++) {
            ctx.lineWidth = 0.5; ctx.beginPath();
            const x = Math.random()*size; const y = Math.random()*size;
            ctx.moveTo(x, y); ctx.lineTo(x + (Math.random()-0.5)*50, y + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.05);
        return new THREE.CanvasTexture(c);
    },

    concrete: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#888888'; ctx.fillRect(0,0,size,size);
        //Heavy noise for aggregate
        TextureFactory.noise(ctx, size, size, 0.4); 
        // Cracks
        ctx.strokeStyle = '#444444'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        for(let i=0; i<20; i++) {
             ctx.beginPath(); ctx.moveTo(Math.random()*size, Math.random()*size);
             for(let j=0; j<5; j++) ctx.lineTo(Math.random()*size, Math.random()*size);
             ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 20);
        return tex;
    },

    brick: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#301510'; ctx.fillRect(0,0,size,size); // Grout
        ctx.fillStyle = '#56302a'; // Brick color
        const brickW = 64; const brickH = 32;
        for(let y=0; y<size; y+=brickH+2) {
            const offset = (y/(brickH+2))%2 === 0 ? 0 : brickW/2;
            for(let x=-brickW; x<size; x+=brickW+2) {
                ctx.fillRect(x+offset, y, brickW, brickH);
            }
        }
        TextureFactory.noise(ctx, size, size, 0.2);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 5);
        return tex;
    },

    grid: () => {
        const size = 1024;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#080808'; ctx.fillRect(0,0,size,size); // Darker floor
        TextureFactory.noise(ctx, size, size, 0.2);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.globalAlpha = 1.0;
        const step = 128; // Bigger grid
        for(let i=0; i<=size; i+=step) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(size,i); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(50, 50);
        return tex;
    },

    // Procedural Bullet Hole
    impact: () => {
        const size = 128;
        const { c, ctx } = TextureFactory.createCanvas(size);
        // Alpha mask
        ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.clearRect(0,0,size,size);
        
        // Cracks
        ctx.beginPath();
        ctx.arc(64,64, 20, 0, Math.PI*2);
        ctx.fillStyle = '#050505'; ctx.fill();
        
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        for(let i=0; i<12; i++) {
            ctx.beginPath(); ctx.moveTo(64,64);
            ctx.lineTo(64 + Math.cos(i)*40 + (Math.random()-0.5)*10, 64 + Math.sin(i)*40 + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(c);
    }
};

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

// Improved Reverb
const convolver = actx.createConvolver();
const dryGain = actx.createGain();
const wetGain = actx.createGain();
dryGain.connect(actx.destination);
wetGain.connect(actx.destination);
wetGain.gain.value = 0.3; // Tighter reverb

const sampleRate = actx.sampleRate;
const length = sampleRate * 1.0; // Short, slap-back reverb
const impulse = actx.createBuffer(2, length, sampleRate);
for (let channel = 0; channel < 2; channel++) {
    const data = impulse.getChannelData(channel);
    for (let i = 0; i < length; i++) {
        // Exponential decay for metallic room sound
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 6);
    }
}
convolver.buffer = impulse;
convolver.connect(wetGain);

function playSound(type) {
    if (actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(dryGain);
    gain.connect(convolver);

    const now = actx.currentTime;

    if (type === 'shoot') {
        // BEEFY AK-47 SOUND - Maximum oomph

        // Layer 1: DEEP bass thump (chest punch)
        const bassOsc = actx.createOscillator();
        const bassGain = actx.createGain();
        const bassFilter = actx.createBiquadFilter();
        bassOsc.connect(bassFilter);
        bassFilter.connect(bassGain);
        bassGain.connect(dryGain);
        bassOsc.type = 'sine';
        bassOsc.frequency.setValueAtTime(60, now);
        bassOsc.frequency.exponentialRampToValueAtTime(25, now + 0.12);
        bassFilter.type = 'lowpass';
        bassFilter.frequency.value = 150;
        bassGain.gain.setValueAtTime(1.2, now);
        bassGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        bassOsc.start(now); bassOsc.stop(now + 0.2);

        // Layer 2: Mid punch (body of the shot)
        const midOsc = actx.createOscillator();
        const midGain = actx.createGain();
        midOsc.connect(midGain);
        midGain.connect(dryGain);
        midGain.connect(convolver);
        midOsc.type = 'sawtooth';
        midOsc.frequency.setValueAtTime(120, now);
        midOsc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        midGain.gain.setValueAtTime(0.7, now);
        midGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        midOsc.start(now); midOsc.stop(now + 0.15);

        // Layer 3: Sharp transient crack (the snap)
        const crackBuf = actx.createBuffer(1, actx.sampleRate * 0.05, actx.sampleRate);
        const crackData = crackBuf.getChannelData(0);
        for (let i = 0; i < crackBuf.length; i++) {
            const t = i / actx.sampleRate;
            crackData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 80) * 1.5;
        }
        const crackSrc = actx.createBufferSource();
        crackSrc.buffer = crackBuf;
        const crackFilter = actx.createBiquadFilter();
        crackFilter.type = 'highpass';
        crackFilter.frequency.value = 2000;
        const crackGain = actx.createGain();
        crackGain.gain.value = 0.9;
        crackSrc.connect(crackFilter);
        crackFilter.connect(crackGain);
        crackGain.connect(dryGain);
        crackSrc.start(now);

        // Layer 4: Explosion noise (the boom)
        const boomBuf = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const boomData = boomBuf.getChannelData(0);
        for (let i = 0; i < boomBuf.length; i++) {
            const t = i / actx.sampleRate;
            boomData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * 0.8;
        }
        const boomSrc = actx.createBufferSource();
        boomSrc.buffer = boomBuf;
        const boomFilter = actx.createBiquadFilter();
        boomFilter.type = 'bandpass';
        boomFilter.frequency.value = 800;
        boomFilter.Q.value = 0.5;
        const boomGain = actx.createGain();
        boomGain.gain.setValueAtTime(1.0, now);
        boomGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        boomSrc.connect(boomFilter);
        boomFilter.connect(boomGain);
        boomGain.connect(dryGain);
        boomGain.connect(convolver);
        boomSrc.start(now);

        // Layer 5: Mechanical clack (bolt action)
        const clackOsc = actx.createOscillator();
        const clackGain = actx.createGain();
        clackOsc.connect(clackGain);
        clackGain.connect(dryGain);
        clackOsc.type = 'square';
        clackOsc.frequency.setValueAtTime(1500, now + 0.015);
        clackOsc.frequency.exponentialRampToValueAtTime(800, now + 0.03);
        clackGain.gain.setValueAtTime(0.2, now + 0.015);
        clackGain.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
        clackOsc.start(now + 0.015); clackOsc.stop(now + 0.05);

        // Layer 6: Sub-bass rumble (feel it in your chest)
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(35, now);
        subOsc.frequency.exponentialRampToValueAtTime(20, now + 0.1);
        subGain.gain.setValueAtTime(0.8, now);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        subOsc.start(now); subOsc.stop(now + 0.15);

        return;

    } else if (type === 'targetHit') {
        // Metallic ping/clang for hitting target
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1000, now);
        filter.Q.value = 5;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add metallic noise
        const hitBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const hitOut = hitBuf.getChannelData(0);
        for (let i = 0; i < hitBuf.length; i++) hitOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.02));
        const hitN = actx.createBufferSource(); hitN.buffer = hitBuf;
        const hitG = actx.createGain();
        hitG.gain.setValueAtTime(0.3, now);
        hitG.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        hitN.connect(hitG); hitG.connect(dryGain);
        hitN.start(now);

    } else if (type === 'zombieHit') {
        // Fleshy impact sound for zombie hits
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.1);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Thwack noise layer
        const thwackBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const thwackOut = thwackBuf.getChannelData(0);
        for (let i = 0; i < thwackBuf.length; i++) {
            thwackOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.015));
        }
        const thwackN = actx.createBufferSource(); thwackN.buffer = thwackBuf;
        const thwackFilter = actx.createBiquadFilter();
        thwackFilter.type = 'bandpass'; thwackFilter.frequency.value = 800; thwackFilter.Q.value = 1;
        const thwackG = actx.createGain();
        thwackG.gain.setValueAtTime(0.4, now);
        thwackN.connect(thwackFilter); thwackFilter.connect(thwackG);
        thwackG.connect(dryGain);
        thwackN.start(now);

    } else if (type === 'zombieDeath') {
        // Zombie death groan
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
        filter.type = 'lowpass';
        filter.frequency.value = 250;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.start(now); osc.stop(now + 0.5);

        // Body fall thud
        const thudOsc = actx.createOscillator();
        const thudGain = actx.createGain();
        thudOsc.connect(thudGain); thudGain.connect(dryGain); thudGain.connect(convolver);
        thudOsc.type = 'sine';
        thudOsc.frequency.setValueAtTime(80, now + 0.2);
        thudOsc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
        thudGain.gain.setValueAtTime(0.6, now + 0.2);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        thudOsc.start(now + 0.2); thudOsc.stop(now + 0.55);

    } else if (type === 'zombieAttack') {
        // Zombie growl/bite sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.25);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add snarl noise
        const snarlBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const snarlOut = snarlBuf.getChannelData(0);
        for (let i = 0; i < snarlBuf.length; i++) {
            snarlOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.05)) * 0.5;
        }
        const snarlN = actx.createBufferSource(); snarlN.buffer = snarlBuf;
        const snarlFilter = actx.createBiquadFilter();
        snarlFilter.type = 'bandpass'; snarlFilter.frequency.value = 300; snarlFilter.Q.value = 2;
        const snarlG = actx.createGain();
        snarlG.gain.setValueAtTime(0.3, now);
        snarlN.connect(snarlFilter); snarlFilter.connect(snarlG);
        snarlG.connect(dryGain);
        snarlN.start(now);

    } else if (type === 'headshot') {
        // SATISFYING head explosion sound - wet pop + crunch
        // Initial pop
        osc.type = 'sine';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Wet splatter noise
        const splatBuf = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const splatOut = splatBuf.getChannelData(0);
        for (let i = 0; i < splatBuf.length; i++) {
            const t = i / actx.sampleRate;
            splatOut[i] = (Math.random() * 2 - 1) * Math.exp(-t * 15) * 0.8;
        }
        const splatN = actx.createBufferSource(); splatN.buffer = splatBuf;
        const splatFilter = actx.createBiquadFilter();
        splatFilter.type = 'lowpass'; splatFilter.frequency.value = 1500;
        const splatG = actx.createGain();
        splatG.gain.setValueAtTime(0.7, now);
        splatN.connect(splatFilter); splatFilter.connect(splatG);
        splatG.connect(dryGain); splatG.connect(convolver);
        splatN.start(now);

        // Bone crunch
        const crunchBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const crunchOut = crunchBuf.getChannelData(0);
        for (let i = 0; i < crunchBuf.length; i++) {
            const t = i / actx.sampleRate;
            // Crispy crackling sound
            crunchOut[i] = (Math.random() > 0.5 ? 1 : -1) * Math.random() * Math.exp(-t * 20) * 0.5;
        }
        const crunchN = actx.createBufferSource(); crunchN.buffer = crunchBuf;
        const crunchFilter = actx.createBiquadFilter();
        crunchFilter.type = 'highpass'; crunchFilter.frequency.value = 2000;
        const crunchG = actx.createGain();
        crunchG.gain.setValueAtTime(0.4, now + 0.02);
        crunchN.connect(crunchFilter); crunchFilter.connect(crunchG);
        crunchG.connect(dryGain);
        crunchN.start(now + 0.02);

    } else if (type === 'playerHurt') {
        // Pain sound - sharp impact
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.25);

        // Heartbeat thump
        const heartOsc = actx.createOscillator();
        const heartGain = actx.createGain();
        heartOsc.connect(heartGain); heartGain.connect(dryGain);
        heartOsc.type = 'sine';
        heartOsc.frequency.value = 40;
        heartGain.gain.setValueAtTime(0.4, now + 0.1);
        heartGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        heartOsc.start(now + 0.1); heartOsc.stop(now + 0.3);

    } else if (type === 'waveComplete') {
        // Victory fanfare - rising tones
        const freqs = [400, 500, 600, 800];
        freqs.forEach((freq, i) => {
            const victoryOsc = actx.createOscillator();
            const victoryGain = actx.createGain();
            victoryOsc.connect(victoryGain); victoryGain.connect(dryGain); victoryGain.connect(convolver);
            victoryOsc.type = 'sine';
            victoryOsc.frequency.value = freq;
            victoryGain.gain.setValueAtTime(0.2, now + i * 0.1);
            victoryGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
            victoryOsc.start(now + i * 0.1); victoryOsc.stop(now + i * 0.1 + 0.35);
        });
        // Don't start the main osc for this sound type
        return;

    } else if (type === 'doorOpen') {
        // Heavy metal door sliding open - industrial/horror vibe

        // Layer 1: Deep mechanical grind (servo motor)
        const grindOsc = actx.createOscillator();
        const grindGain = actx.createGain();
        const grindFilter = actx.createBiquadFilter();
        grindOsc.connect(grindFilter);
        grindFilter.connect(grindGain);
        grindGain.connect(dryGain);
        grindOsc.type = 'sawtooth';
        grindOsc.frequency.setValueAtTime(50, now);
        grindOsc.frequency.linearRampToValueAtTime(80, now + 0.3);
        grindFilter.type = 'lowpass';
        grindFilter.frequency.value = 200;
        grindGain.gain.setValueAtTime(0.4, now);
        grindGain.gain.linearRampToValueAtTime(0.3, now + 0.15);
        grindGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        grindOsc.start(now); grindOsc.stop(now + 0.4);

        // Layer 2: Metal scraping (high frequency noise)
        const scrapeBuffer = actx.createBuffer(1, actx.sampleRate * 0.3, actx.sampleRate);
        const scrapeData = scrapeBuffer.getChannelData(0);
        for (let i = 0; i < scrapeData.length; i++) {
            scrapeData[i] = (Math.random() * 2 - 1) * (1 - i / scrapeData.length) * 0.5;
        }
        const scrapeSource = actx.createBufferSource();
        scrapeSource.buffer = scrapeBuffer;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass';
        scrapeFilter.frequency.value = 3000;
        scrapeFilter.Q.value = 3;
        const scrapeGain = actx.createGain();
        scrapeSource.connect(scrapeFilter);
        scrapeFilter.connect(scrapeGain);
        scrapeGain.connect(dryGain);
        scrapeGain.gain.setValueAtTime(0.15, now);
        scrapeGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        scrapeSource.start(now);

        // Layer 3: Heavy thunk at the end (door hitting stop)
        const thunkOsc = actx.createOscillator();
        const thunkGain = actx.createGain();
        thunkOsc.connect(thunkGain);
        thunkGain.connect(dryGain);
        thunkGain.connect(convolver);
        thunkOsc.type = 'sine';
        thunkOsc.frequency.setValueAtTime(80, now + 0.25);
        thunkOsc.frequency.exponentialRampToValueAtTime(30, now + 0.35);
        thunkGain.gain.setValueAtTime(0, now);
        thunkGain.gain.setValueAtTime(0.5, now + 0.25);
        thunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.4);
        thunkOsc.start(now + 0.25); thunkOsc.stop(now + 0.45);

        // Layer 4: Hiss/pneumatic (air escaping)
        const hissBuffer = actx.createBuffer(1, actx.sampleRate * 0.2, actx.sampleRate);
        const hissData = hissBuffer.getChannelData(0);
        for (let i = 0; i < hissData.length; i++) {
            hissData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / hissData.length, 2);
        }
        const hissSource = actx.createBufferSource();
        hissSource.buffer = hissBuffer;
        const hissFilter = actx.createBiquadFilter();
        hissFilter.type = 'highpass';
        hissFilter.frequency.value = 4000;
        const hissGain = actx.createGain();
        hissSource.connect(hissFilter);
        hissFilter.connect(hissGain);
        hissGain.connect(dryGain);
        hissGain.gain.setValueAtTime(0.1, now);
        hissGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        hissSource.start(now);

        return;

    } else if (type === 'empty') {
        osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    } else if (type === 'mag_out') {
        // BEEFY MAG RELEASE - Heavy mechanical clunk

        // Layer 1: Deep thunk (weight of mag releasing)
        const thunkOsc = actx.createOscillator();
        const thunkGain = actx.createGain();
        thunkOsc.connect(thunkGain);
        thunkGain.connect(dryGain);
        thunkOsc.type = 'sine';
        thunkOsc.frequency.setValueAtTime(100, now);
        thunkOsc.frequency.exponentialRampToValueAtTime(40, now + 0.08);
        thunkGain.gain.setValueAtTime(0.7, now);
        thunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        thunkOsc.start(now); thunkOsc.stop(now + 0.12);

        // Layer 2: Sharp release click
        osc.type = 'square';
        osc.frequency.setValueAtTime(3500, now);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.015);
        filter.type = 'highpass';
        filter.frequency.value = 1500;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.025);
        osc.start(now); osc.stop(now + 0.03);

        // Layer 3: Metal slide/scrape
        const slideOsc = actx.createOscillator();
        const slideGain = actx.createGain();
        const slideFilter = actx.createBiquadFilter();
        slideOsc.connect(slideFilter); slideFilter.connect(slideGain);
        slideGain.connect(dryGain); slideGain.connect(convolver);
        slideOsc.type = 'sawtooth';
        slideOsc.frequency.setValueAtTime(500, now + 0.01);
        slideOsc.frequency.linearRampToValueAtTime(150, now + 0.15);
        slideFilter.type = 'bandpass';
        slideFilter.frequency.value = 1000;
        slideFilter.Q.value = 3;
        slideGain.gain.setValueAtTime(0.4, now + 0.01);
        slideGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        slideOsc.start(now + 0.01); slideOsc.stop(now + 0.18);

        // Layer 4: Metallic rattle (mag sliding out)
        const rattleBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const rattleOut = rattleBuf.getChannelData(0);
        for (let i = 0; i < rattleBuf.length; i++) {
            const t = i / actx.sampleRate;
            rattleOut[i] = (Math.random() * 2 - 1) * Math.exp(-t * 12) * Math.sin(i * 0.4) * 0.8;
        }
        const rattleN = actx.createBufferSource(); rattleN.buffer = rattleBuf;
        const rattleFilter = actx.createBiquadFilter();
        rattleFilter.type = 'bandpass';
        rattleFilter.frequency.value = 2500;
        rattleFilter.Q.value = 1;
        const rattleG = actx.createGain();
        rattleG.gain.setValueAtTime(0.35, now + 0.02);
        rattleN.connect(rattleFilter); rattleFilter.connect(rattleG);
        rattleG.connect(dryGain); rattleG.connect(convolver);
        rattleN.start(now + 0.02);

        // Layer 5: Low resonance (gun body vibration)
        const resOsc = actx.createOscillator();
        const resGain = actx.createGain();
        resOsc.connect(resGain);
        resGain.connect(dryGain);
        resOsc.type = 'triangle';
        resOsc.frequency.value = 80;
        resGain.gain.setValueAtTime(0.3, now);
        resGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        resOsc.start(now); resOsc.stop(now + 0.15);
        return;

    } else if (type === 'mag_in') {
        // BEEFY MAG INSERT - Satisfying heavy slam

        // Layer 1: Deep impact thump (mag slamming home)
        const impactOsc = actx.createOscillator();
        const impactGain = actx.createGain();
        const impactFilter = actx.createBiquadFilter();
        impactOsc.connect(impactFilter);
        impactFilter.connect(impactGain);
        impactGain.connect(dryGain);
        impactOsc.type = 'sine';
        impactOsc.frequency.setValueAtTime(80, now);
        impactOsc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        impactFilter.type = 'lowpass';
        impactFilter.frequency.value = 200;
        impactGain.gain.setValueAtTime(1.0, now);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        impactOsc.start(now); impactOsc.stop(now + 0.15);

        // Layer 2: Sharp latch click
        osc.type = 'square';
        osc.frequency.setValueAtTime(4000, now);
        osc.frequency.exponentialRampToValueAtTime(1500, now + 0.01);
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        gain.gain.setValueAtTime(0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
        osc.start(now); osc.stop(now + 0.025);

        // Layer 3: Metal-on-metal clunk
        const clunkOsc = actx.createOscillator();
        const clunkGain = actx.createGain();
        clunkOsc.connect(clunkGain);
        clunkGain.connect(dryGain);
        clunkGain.connect(convolver);
        clunkOsc.type = 'sawtooth';
        clunkOsc.frequency.setValueAtTime(200, now);
        clunkOsc.frequency.exponentialRampToValueAtTime(80, now + 0.06);
        clunkGain.gain.setValueAtTime(0.6, now);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        clunkOsc.start(now); clunkOsc.stop(now + 0.1);

        // Layer 4: Metallic ring/resonance
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(600, now);
        ringOsc.frequency.exponentialRampToValueAtTime(400, now + 0.2);
        ringFilter.type = 'bandpass';
        ringFilter.frequency.value = 500;
        ringFilter.Q.value = 12;
        ringGain.gain.setValueAtTime(0.25, now + 0.01);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        ringOsc.start(now); ringOsc.stop(now + 0.3);

        // Layer 5: Snap transient
        const snapBuf = actx.createBuffer(1, actx.sampleRate * 0.02, actx.sampleRate);
        const snapOut = snapBuf.getChannelData(0);
        for (let i = 0; i < snapBuf.length; i++) {
            snapOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.003)) * 1.2;
        }
        const snapN = actx.createBufferSource(); snapN.buffer = snapBuf;
        const snapFilter = actx.createBiquadFilter();
        snapFilter.type = 'highpass'; snapFilter.frequency.value = 3500;
        const snapG = actx.createGain();
        snapG.gain.setValueAtTime(0.5, now);
        snapN.connect(snapFilter); snapFilter.connect(snapG); snapG.connect(dryGain);
        snapN.start(now);

        // Layer 6: Sub-bass punch
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(50, now);
        subOsc.frequency.exponentialRampToValueAtTime(25, now + 0.08);
        subGain.gain.setValueAtTime(0.6, now);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        subOsc.start(now); subOsc.stop(now + 0.12);
        return;

    } else if (type === 'rack') {
        // BEEFY BOLT RACK - Aggressive charging handle slam

        // Layer 1: Pull back - heavy metal scrape
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200, now);
        osc.frequency.linearRampToValueAtTime(500, now + 0.1);
        filter.type = 'bandpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.14);

        // Layer 2: Aggressive scrape noise
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.12, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const t = i / actx.sampleRate;
            const env = Math.exp(-t * 10);
            scrapeOut[i] = (Math.random() * 2 - 1) * env * (0.6 + 0.4 * Math.sin(i * 0.08));
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 3000; scrapeFilter.Q.value = 1.5;
        const scrapeG = actx.createGain();
        scrapeG.gain.setValueAtTime(0.45, now);
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain); scrapeG.connect(convolver);
        scrapeN.start(now);

        // Layer 3: HEAVY bolt slam forward
        const slamOsc = actx.createOscillator();
        const slamGain = actx.createGain();
        slamOsc.connect(slamGain); slamGain.connect(dryGain); slamGain.connect(convolver);
        slamOsc.type = 'sine';
        slamOsc.frequency.setValueAtTime(100, now + 0.12);
        slamOsc.frequency.exponentialRampToValueAtTime(35, now + 0.22);
        slamGain.gain.setValueAtTime(0.9, now + 0.12);
        slamGain.gain.exponentialRampToValueAtTime(0.01, now + 0.24);
        slamOsc.start(now + 0.12); slamOsc.stop(now + 0.28);

        // Layer 4: Sharp metal impact
        const impOsc = actx.createOscillator();
        const impGain = actx.createGain();
        impOsc.connect(impGain); impGain.connect(dryGain);
        impOsc.type = 'square';
        impOsc.frequency.setValueAtTime(5000, now + 0.12);
        impOsc.frequency.exponentialRampToValueAtTime(1200, now + 0.14);
        impGain.gain.setValueAtTime(0.5, now + 0.12);
        impGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        impOsc.start(now + 0.12); impOsc.stop(now + 0.17);

        // Layer 5: Metal clunk body
        const clunkOsc = actx.createOscillator();
        const clunkGain = actx.createGain();
        clunkOsc.connect(clunkGain); clunkGain.connect(dryGain);
        clunkOsc.type = 'sawtooth';
        clunkOsc.frequency.setValueAtTime(150, now + 0.12);
        clunkOsc.frequency.exponentialRampToValueAtTime(60, now + 0.18);
        clunkGain.gain.setValueAtTime(0.5, now + 0.12);
        clunkGain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        clunkOsc.start(now + 0.12); clunkOsc.stop(now + 0.22);

        // Layer 6: Resonant metal ring
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(900, now + 0.13);
        ringFilter.type = 'bandpass'; ringFilter.frequency.value = 900; ringFilter.Q.value = 20;
        ringGain.gain.setValueAtTime(0.2, now + 0.13);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        ringOsc.start(now + 0.13); ringOsc.stop(now + 0.5);

        // Layer 7: Sub-bass slam punch
        const subOsc = actx.createOscillator();
        const subGain = actx.createGain();
        subOsc.connect(subGain);
        subGain.connect(dryGain);
        subOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(45, now + 0.12);
        subOsc.frequency.exponentialRampToValueAtTime(20, now + 0.2);
        subGain.gain.setValueAtTime(0.7, now + 0.12);
        subGain.gain.exponentialRampToValueAtTime(0.01, now + 0.22);
        subOsc.start(now + 0.12); subOsc.stop(now + 0.25);

        // Layer 8: Spring tension release noise
        const springBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const springOut = springBuf.getChannelData(0);
        for (let i = 0; i < springBuf.length; i++) {
            const t = i / actx.sampleRate;
            springOut[i] = Math.sin(i * 0.15) * Math.exp(-t * 30) * 0.4;
        }
        const springN = actx.createBufferSource(); springN.buffer = springBuf;
        const springFilter = actx.createBiquadFilter();
        springFilter.type = 'highpass'; springFilter.frequency.value = 1500;
        const springG = actx.createGain();
        springG.gain.value = 0.3;
        springN.connect(springFilter); springFilter.connect(springG);
        springG.connect(dryGain);
        springN.start(now + 0.12);
        return;

    } else if (type === 'pickup') {
        // Satisfying pickup chime
        const freqs = [600, 800, 1000];
        freqs.forEach((freq, i) => {
            const chimeOsc = actx.createOscillator();
            const chimeGain = actx.createGain();
            chimeOsc.connect(chimeGain); chimeGain.connect(dryGain); chimeGain.connect(convolver);
            chimeOsc.type = 'sine';
            chimeOsc.frequency.value = freq;
            chimeGain.gain.setValueAtTime(0.2, now + i * 0.05);
            chimeGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.2);
            chimeOsc.start(now + i * 0.05); chimeOsc.stop(now + i * 0.05 + 0.25);
        });
        return;

    } else if (type === 'nuke') {
        // Massive explosion
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, now);
        osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, now);
        filter.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
        osc.start(now); osc.stop(now + 1.2);

        // Massive noise burst
        const nukeBuf = actx.createBuffer(1, actx.sampleRate * 0.5, actx.sampleRate);
        const nukeOut = nukeBuf.getChannelData(0);
        for (let i = 0; i < nukeBuf.length; i++) {
            nukeOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.2));
        }
        const nukeN = actx.createBufferSource(); nukeN.buffer = nukeBuf;
        const nukeFilter = actx.createBiquadFilter();
        nukeFilter.type = 'lowpass'; nukeFilter.frequency.value = 600;
        const nukeG = actx.createGain();
        nukeG.gain.setValueAtTime(0.7, now);
        nukeG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        nukeN.connect(nukeFilter); nukeFilter.connect(nukeG);
        nukeG.connect(dryGain); nukeG.connect(convolver);
        nukeN.start(now);

        // High frequency sizzle
        const sizzleOsc = actx.createOscillator();
        const sizzleGain = actx.createGain();
        sizzleOsc.connect(sizzleGain); sizzleGain.connect(dryGain);
        sizzleOsc.type = 'sawtooth';
        sizzleOsc.frequency.setValueAtTime(2000, now);
        sizzleOsc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        sizzleGain.gain.setValueAtTime(0.3, now);
        sizzleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        sizzleOsc.start(now); sizzleOsc.stop(now + 0.4);
    }
}

/**
 * SCENE SETUP
 */
const scene = new THREE.Scene();
// ENHANCED Procedural Skybox - Epic Sunset with Volumetric Clouds
const skyVertexShader = `
varying vec3 vWorldPosition;
varying vec3 vDirection;
void main() {
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    vDirection = normalize(position);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

const skyFragmentShader = `
uniform vec3 topColor;
uniform vec3 midColor;
uniform vec3 bottomColor;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform float time;
varying vec3 vWorldPosition;
varying vec3 vDirection;

// Simplex noise functions for procedural clouds
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

float fbm(vec3 p) {
    float f = 0.0;
    float amplitude = 0.5;
    for (int i = 0; i < 5; i++) {
        f += amplitude * snoise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return f;
}

void main() {
    vec3 dir = normalize(vDirection);
    float h = dir.y;

    // More natural sunset gradient
    vec3 horizonColor = vec3(0.95, 0.5, 0.2);   // Warm orange at horizon
    vec3 lowerSkyColor = vec3(0.6, 0.35, 0.25); // Muted pink-orange

    vec3 skyColor;
    if (h < 0.0) {
        // Below horizon - dark
        skyColor = mix(vec3(0.03, 0.02, 0.02), bottomColor * 0.3, smoothstep(-0.2, 0.0, h));
    } else if (h < 0.15) {
        // Horizon band
        skyColor = mix(horizonColor, lowerSkyColor, smoothstep(0.0, 0.15, h));
    } else if (h < 0.4) {
        // Lower sky
        skyColor = mix(lowerSkyColor, midColor, smoothstep(0.15, 0.4, h));
    } else {
        // Upper sky fading to darker blue-purple
        skyColor = mix(midColor, topColor, smoothstep(0.4, 0.85, h));
    }

    // Sun glow - more natural
    float sunDot = dot(dir, normalize(sunDirection));
    float sunGlow = pow(max(sunDot, 0.0), 80.0);
    float sunHalo = pow(max(sunDot, 0.0), 12.0) * 0.3;
    float sunDisk = smoothstep(0.997, 0.999, sunDot);

    skyColor += sunColor * sunGlow * 1.5;
    skyColor += sunColor * sunHalo * 0.4;
    skyColor += sunColor * sunDisk * 2.0;

    // Subtle procedural clouds
    if (h > 0.0 && h < 0.5) {
        vec3 cloudPos = dir * 2.0 + vec3(time * 0.005, 0.0, time * 0.003);
        float cloud = fbm(cloudPos * 1.5);
        cloud = smoothstep(0.1, 0.5, cloud);

        // Clouds lit by sunset - muted colors
        vec3 cloudColor = mix(vec3(0.8, 0.5, 0.35), vec3(0.5, 0.3, 0.25), 1.0 - h * 2.0);

        // Light the clouds from sun direction
        float cloudLight = max(0.0, dot(dir, normalize(sunDirection)));
        cloudColor = mix(cloudColor * 0.5, cloudColor * 1.2, cloudLight);

        // Cloud density varies by height - less dense overall
        float cloudMask = smoothstep(0.0, 0.1, h) * smoothstep(0.5, 0.2, h);
        cloud *= cloudMask * 0.4; // Much less cloud coverage

        skyColor = mix(skyColor, cloudColor, cloud);
    }

    // Subtle atmospheric scattering
    float scatter = 1.0 - abs(h);
    scatter = pow(scatter, 4.0);
    skyColor = mix(skyColor, horizonColor * 0.8, scatter * 0.15);

    gl_FragColor = vec4(skyColor, 1.0);
}`;

const skyUniforms = {
    topColor: { value: new THREE.Color(0x1a1535) },     // Dark blue-purple night sky
    midColor: { value: new THREE.Color(0x4a3055) },     // Muted purple
    bottomColor: { value: new THREE.Color(0xdd6030) },  // Warm orange horizon
    sunColor: { value: new THREE.Color(0xffcc55) },     // Golden sun
    sunDirection: { value: new THREE.Vector3(-0.5, 0.12, -0.85).normalize() },
    time: { value: 0.0 }
};
const skyGeo = new THREE.SphereGeometry(500, 64, 32);
const skyMat = new THREE.ShaderMaterial({
    vertexShader: skyVertexShader,
    fragmentShader: skyFragmentShader,
    uniforms: skyUniforms,
    side: THREE.BackSide
});
const sky = new THREE.Mesh(skyGeo, skyMat);
// scene.add(sky); // Disabled - indoor arena with roof

// Sunset clouds - scattered wispy shapes
const cloudGroup = new THREE.Group();
for (let i = 0; i < 25; i++) {
    const cloudGeo = new THREE.PlaneGeometry(80 + Math.random() * 60, 15 + Math.random() * 20);
    const cloudMat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().lerpColors(
            new THREE.Color(0xff4020),
            new THREE.Color(0xff8040),
            Math.random()
        ),
        transparent: true,
        opacity: 0.3 + Math.random() * 0.3,
        side: THREE.DoubleSide
    });
    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
    const angle = Math.random() * Math.PI * 2;
    const height = 80 + Math.random() * 100;
    const dist = 200 + Math.random() * 200;
    cloud.position.set(
        Math.cos(angle) * dist,
        height,
        Math.sin(angle) * dist
    );
    cloud.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
    cloud.rotation.z = Math.random() * Math.PI;
    cloud.lookAt(0, height, 0);
    cloudGroup.add(cloud);
}
// scene.add(cloudGroup); // Disabled - indoor arena with roof

// Setting sun (disabled for indoor)
const sunGeo = new THREE.SphereGeometry(25, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
const sun = new THREE.Mesh(sunGeo, sunMat);
sun.position.set(-200, 40, -350);
// scene.add(sun); // Disabled - indoor arena

// Sun glow - large orange halo
const sunGlowGeo = new THREE.SphereGeometry(60, 32, 32);
const sunGlowMat = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.25
});
const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
sunGlow.position.copy(sun.position);
// scene.add(sunGlow); // Disabled - indoor arena

// Outer sun glow
const sunGlow2Geo = new THREE.SphereGeometry(100, 32, 32);
const sunGlow2Mat = new THREE.MeshBasicMaterial({
    color: 0xff4400,
    transparent: true,
    opacity: 0.1
});
const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
sunGlow2.position.copy(sun.position);
// scene.add(sunGlow2); // Disabled - indoor arena

// Indoor haze/dust fog (subtle)
scene.fog = new THREE.FogExp2(0x222225, 0.006);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 500); // Reduced FOV and far plane for performance
const renderer = new THREE.WebGLRenderer({
    antialias: true, // Enable for cleaner edges
    powerPreference: "high-performance",
    precision: "highp" // High precision for better visuals
});
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); // Higher quality
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft realistic shadows
renderer.shadowMap.autoUpdate = false; // Manual shadow update
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping; // Cinematic tone mapping
renderer.toneMappingExposure = 1.1; // Slightly brighter
renderer.physicallyCorrectLights = true; // PBR lighting
document.body.appendChild(renderer.domElement);

// POST-PROCESSING SETUP - ENHANCED GRAPHICS PIPELINE
const composer = new THREE.EffectComposer(renderer);

// Depth texture for depth-based effects
const depthTexture = new THREE.DepthTexture(window.innerWidth, window.innerHeight);
depthTexture.type = THREE.UnsignedShortType;
const depthRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat,
    depthTexture: depthTexture
});

const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// God Rays - DISABLED for performance (too expensive)
// const godRaysPass = new THREE.ShaderPass(GodRaysShader);
// composer.addPass(godRaysPass);

// Lens Flare - DISABLED for performance
// const lensFlarePass = new THREE.ShaderPass(LensFlareShader);
// composer.addPass(lensFlarePass);

// Heat Distortion - DISABLED for performance (very subtle anyway)
// const heatPass = new THREE.ShaderPass(HeatDistortionShader);
// composer.addPass(heatPass);

// Bloom for muzzle flash glow - optimized for performance
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth / 4, window.innerHeight / 4), // Quarter resolution for speed
    0.12,  // strength - reduced
    0.3,   // radius - tighter
    0.9    // threshold - higher
);
composer.addPass(bloomPass);

// Color Grading - DISABLED (ACES tone mapping provides good cinematic look)
// const colorGradingPass = new THREE.ShaderPass(ColorGradingShader);
// composer.addPass(colorGradingPass);

// Motion Blur
const motionBlurPass = new THREE.ShaderPass(MotionBlurShader);
composer.addPass(motionBlurPass);

// Chromatic Aberration - Subtle realism, increases during action
const chromaticPass = new THREE.ShaderPass(ChromaticAberrationShader);
chromaticPass.uniforms.amount.value = 0.001; // Very subtle base
composer.addPass(chromaticPass);

// Film Grain - DISABLED for cleaner look
// const grainPass = new THREE.ShaderPass(FilmGrainShader);
// grainPass.uniforms.intensity.value = 0.04;
// composer.addPass(grainPass);

// Vignette - DISABLED per user request
// const vignettePass = new THREE.ShaderPass(VignetteShader);
// composer.addPass(vignettePass);

// FXAA - Fast approximate anti-aliasing for cleaner edges
const fxaaPass = new THREE.ShaderPass(THREE.FXAAShader);
const pixelRatio = renderer.getPixelRatio();
fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * pixelRatio), 1 / (window.innerHeight * pixelRatio));
composer.addPass(fxaaPass);

// Sun screen position for god rays and lens flare (updated in animate loop)
let sunScreenPos = new THREE.Vector2(0.3, 0.7);
let sunVisible = 1.0;

// Create sunset environment map for reflections
const envMapSize = 256;
const envMapCanvas = document.createElement('canvas');
envMapCanvas.width = envMapCanvas.height = envMapSize;
const envCtx = envMapCanvas.getContext('2d');
const envGrad = envCtx.createLinearGradient(0, 0, 0, envMapSize);
envGrad.addColorStop(0, '#2a1030');   // Purple top
envGrad.addColorStop(0.4, '#ff6040'); // Orange mid
envGrad.addColorStop(1, '#ffaa60');   // Warm bottom
envCtx.fillStyle = envGrad;
envCtx.fillRect(0, 0, envMapSize, envMapSize);
const envMapTex = new THREE.CanvasTexture(envMapCanvas);
envMapTex.mapping = THREE.EquirectangularReflectionMapping;

// ============ INDOOR FLUORESCENT LIGHTING ============
// Brighter cool white ambient for indoor feel
const ambientLight = new THREE.AmbientLight(0xdddde8, 0.6);
scene.add(ambientLight);

// Hemisphere light - bright ceiling, lighter floor
const hemiLight = new THREE.HemisphereLight(0xffffff, 0x666677, 0.5);
scene.add(hemiLight);

// Main overhead light (like a big fluorescent panel) - straight down
const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
dirLight.position.set(0, 100, 0); // Straight above
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
dirLight.shadow.bias = -0.0002;
dirLight.shadow.normalBias = 0.02;
dirLight.shadow.radius = 3; // Softer shadows for fluorescent
dirLight.shadow.camera.left = -100;
dirLight.shadow.camera.right = 100;
dirLight.shadow.camera.top = 100;
dirLight.shadow.camera.bottom = -100;
dirLight.shadow.camera.near = 10;
dirLight.shadow.camera.far = 150;
scene.add(dirLight);

// Fluorescent strip lights array (for that warehouse look)
const fluorLights = [];
const FLUOR_ROWS = 5;
const FLUOR_COLS = 5;
const FLUOR_SPACING = 28;
const ROOF_HEIGHT = 30;

for (let row = 0; row < FLUOR_ROWS; row++) {
    for (let col = 0; col < FLUOR_COLS; col++) {
        const x = (col - (FLUOR_COLS - 1) / 2) * FLUOR_SPACING;
        const z = (row - (FLUOR_ROWS - 1) / 2) * FLUOR_SPACING;

        // Point light for each fluorescent fixture (brighter)
        const fluorLight = new THREE.PointLight(0xffffff, 1.0, 50, 2);
        fluorLight.position.set(x, ROOF_HEIGHT - 2, z);
        scene.add(fluorLight);
        fluorLights.push(fluorLight);

        // Visible fluorescent tube (emissive mesh)
        const tubeGeo = new THREE.BoxGeometry(8, 0.3, 1);
        const tubeMat = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            emissive: 0xeeffff,
            emissiveIntensity: 2
        });
        const tube = new THREE.Mesh(tubeGeo, tubeMat);
        tube.position.set(x, ROOF_HEIGHT - 1, z);
        scene.add(tube);
    }
}

// Subtle fill light for visibility
const rimLight = new THREE.DirectionalLight(0xaaaacc, 0.1);
rimLight.position.set(5, 10, 5);
scene.add(rimLight);

// Muzzle flash light
const muzzleLight = new THREE.PointLight(0xffaa00, 0, 30);
muzzleLight.castShadow = false;
scene.add(muzzleLight);

// Secondary fill light that follows camera for gun visibility (warm tint)
const gunFillLight = new THREE.PointLight(0xffaa77, 0.4, 15);
gunFillLight.position.set(0, -0.3, 0.5);
camera.add(gunFillLight);

// Initialize textures FIRST so they are available for everything
const concreteTex = TextureFactory.concrete();
const brickTex = TextureFactory.brick();
const woodTex = TextureFactory.wood();
const metalTexDark = TextureFactory.metal(true);
const metalTexLight = TextureFactory.metal(false);

// Concrete Floor (Bright)
const floorMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, 
    color: 0xdddddd, // Light grey
    roughness: 0.8, 
    metalness: 0.1,
    bumpMap: concreteTex,
    bumpScale: 0.05
});
// Larger arena for zombie swarms
const MAP_SIZE = 140;
const MAP_HALF = MAP_SIZE / 2;

const floor = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE, MAP_SIZE), floorMat);
floor.rotation.x = -Math.PI / 2; floor.position.y = -5; floor.receiveShadow = true;
scene.add(floor);

// ============ ROOF/CEILING ============
// Create industrial ceiling texture
const ceilingTexCanvas = document.createElement('canvas');
ceilingTexCanvas.width = 256;
ceilingTexCanvas.height = 256;
const ceilCtx = ceilingTexCanvas.getContext('2d');

// Base ceiling color (industrial gray)
ceilCtx.fillStyle = '#404045';
ceilCtx.fillRect(0, 0, 256, 256);

// Add ceiling tile grid pattern
ceilCtx.strokeStyle = '#353538';
ceilCtx.lineWidth = 2;
const tileSize = 64;
for (let x = 0; x <= 256; x += tileSize) {
    ceilCtx.beginPath();
    ceilCtx.moveTo(x, 0);
    ceilCtx.lineTo(x, 256);
    ceilCtx.stroke();
}
for (let y = 0; y <= 256; y += tileSize) {
    ceilCtx.beginPath();
    ceilCtx.moveTo(0, y);
    ceilCtx.lineTo(256, y);
    ceilCtx.stroke();
}

// Add some subtle variation/stains
for (let i = 0; i < 20; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 5 + Math.random() * 20;
    ceilCtx.fillStyle = `rgba(${Math.random() > 0.5 ? 50 : 30}, ${Math.random() > 0.5 ? 50 : 30}, ${Math.random() > 0.5 ? 52 : 32}, 0.3)`;
    ceilCtx.beginPath();
    ceilCtx.arc(x, y, radius, 0, Math.PI * 2);
    ceilCtx.fill();
}

const ceilingTex = new THREE.CanvasTexture(ceilingTexCanvas);
ceilingTex.wrapS = ceilingTex.wrapT = THREE.RepeatWrapping;
ceilingTex.repeat.set(4, 4);

const ceilingMat = new THREE.MeshStandardMaterial({
    map: ceilingTex,
    color: 0x555560,
    roughness: 0.9,
    side: THREE.BackSide // Visible from below
});

const ceiling = new THREE.Mesh(new THREE.PlaneGeometry(MAP_SIZE + 10, MAP_SIZE + 10), ceilingMat);
ceiling.rotation.x = -Math.PI / 2;
ceiling.position.y = ROOF_HEIGHT;
ceiling.receiveShadow = false;
scene.add(ceiling);

// ============ CENTRAL HILL ============
const HILL_RADIUS = 18;
const HILL_HEIGHT = 5;
const HILL_CENTER_X = 0;
const HILL_CENTER_Z = 0;

// Create smooth mound geometry (hemisphere-like)
const hillSegments = 32;
const hillGeo = new THREE.BufferGeometry();
const hillVertices = [];
const hillIndices = [];
const hillUvs = [];
const hillNormals = [];

// Generate vertices for a smooth dome/mound
for (let ring = 0; ring <= hillSegments; ring++) {
    const ringRatio = ring / hillSegments;
    const radius = HILL_RADIUS * ringRatio;
    const height = HILL_HEIGHT * Math.cos(ringRatio * Math.PI / 2); // Cosine falloff for smooth hill

    for (let seg = 0; seg <= hillSegments; seg++) {
        const angle = (seg / hillSegments) * Math.PI * 2;
        const x = Math.cos(angle) * radius;
        const z = Math.sin(angle) * radius;
        const y = height;

        hillVertices.push(x, y, z);
        hillUvs.push(seg / hillSegments, ring / hillSegments);

        // Calculate normal (pointing outward/upward)
        const nx = Math.cos(angle) * ringRatio * 0.5;
        const ny = 1 - ringRatio * 0.5;
        const nz = Math.sin(angle) * ringRatio * 0.5;
        const nLen = Math.sqrt(nx * nx + ny * ny + nz * nz);
        hillNormals.push(nx / nLen, ny / nLen, nz / nLen);
    }
}

// Generate indices (reversed winding for outward-facing normals)
for (let ring = 0; ring < hillSegments; ring++) {
    for (let seg = 0; seg < hillSegments; seg++) {
        const curr = ring * (hillSegments + 1) + seg;
        const next = curr + hillSegments + 1;

        // Correct winding order for visible from outside
        hillIndices.push(curr, curr + 1, next);
        hillIndices.push(curr + 1, next + 1, next);
    }
}

hillGeo.setAttribute('position', new THREE.Float32BufferAttribute(hillVertices, 3));
hillGeo.setAttribute('uv', new THREE.Float32BufferAttribute(hillUvs, 2));
hillGeo.setAttribute('normal', new THREE.Float32BufferAttribute(hillNormals, 3));
hillGeo.setIndex(hillIndices);

// Procedural grass texture for hill
const grassTexCanvas = document.createElement('canvas');
grassTexCanvas.width = 256;
grassTexCanvas.height = 256;
const grassCtx = grassTexCanvas.getContext('2d');

// Base grass green
grassCtx.fillStyle = '#3d5c28';
grassCtx.fillRect(0, 0, 256, 256);

// Add grass blade variations
for (let i = 0; i < 2000; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const length = 3 + Math.random() * 8;
    const angle = -Math.PI / 2 + (Math.random() - 0.5) * 0.6;

    // Vary green shades
    const shade = Math.floor(Math.random() * 40);
    const r = 45 + shade;
    const g = 80 + Math.floor(Math.random() * 30);
    const b = 30 + Math.floor(Math.random() * 20);

    grassCtx.strokeStyle = `rgb(${r}, ${g}, ${b})`;
    grassCtx.lineWidth = 1 + Math.random();
    grassCtx.beginPath();
    grassCtx.moveTo(x, y);
    grassCtx.lineTo(x + Math.cos(angle) * length, y + Math.sin(angle) * length);
    grassCtx.stroke();
}

// Add some darker patches for depth
for (let i = 0; i < 30; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 5 + Math.random() * 15;
    grassCtx.fillStyle = 'rgba(30, 50, 20, 0.3)';
    grassCtx.beginPath();
    grassCtx.arc(x, y, radius, 0, Math.PI * 2);
    grassCtx.fill();
}

// Add lighter highlights
for (let i = 0; i < 20; i++) {
    const x = Math.random() * 256;
    const y = Math.random() * 256;
    const radius = 3 + Math.random() * 10;
    grassCtx.fillStyle = 'rgba(100, 140, 60, 0.2)';
    grassCtx.beginPath();
    grassCtx.arc(x, y, radius, 0, Math.PI * 2);
    grassCtx.fill();
}

const grassTex = new THREE.CanvasTexture(grassTexCanvas);
grassTex.wrapS = grassTex.wrapT = THREE.RepeatWrapping;
grassTex.repeat.set(4, 4);

// Hill material - lush green grass
const hillMat = new THREE.MeshStandardMaterial({
    map: grassTex,
    color: 0x4a7030,
    roughness: 0.9,
    bumpMap: grassTex,
    bumpScale: 0.15
});

const hill = new THREE.Mesh(hillGeo, hillMat);
hill.position.set(HILL_CENTER_X, -5, HILL_CENTER_Z);
hill.receiveShadow = true;
hill.castShadow = true;
scene.add(hill);

// Terrain height function - returns Y position at any world X/Z
function getTerrainHeight(x, z) {
    const dx = x - HILL_CENTER_X;
    const dz = z - HILL_CENTER_Z;
    const dist = Math.sqrt(dx * dx + dz * dz);

    if (dist >= HILL_RADIUS) {
        return -5; // Base ground level
    }

    // Smooth cosine falloff for natural hill shape
    const ratio = dist / HILL_RADIUS;
    const height = HILL_HEIGHT * Math.cos(ratio * Math.PI / 2);
    return -5 + height;
}

// Check if a position is on the hill (for spawn avoidance)
function isOnHill(x, z, margin = 2) {
    const dx = x - HILL_CENTER_X;
    const dz = z - HILL_CENTER_Z;
    const dist = Math.sqrt(dx * dx + dz * dz);
    return dist < (HILL_RADIUS + margin);
}

// Walls (Concrete/Light Brick)
const wallMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, // Switched to concrete to match photo style
    color: 0xbbbbbb,
    roughness: 0.9, 
    bumpMap: concreteTex, 
    bumpScale: 0.1 
});
const wallGeo = new THREE.PlaneGeometry(MAP_SIZE, 50);
const wall1 = new THREE.Mesh(wallGeo, wallMat); wall1.position.set(0, 20, -MAP_HALF); wall1.receiveShadow = true; scene.add(wall1);
const wall2 = new THREE.Mesh(wallGeo, wallMat); wall2.position.set(0, 20, MAP_HALF); wall2.rotation.y = Math.PI; wall2.receiveShadow = true; scene.add(wall2);
const wall3 = new THREE.Mesh(wallGeo, wallMat); wall3.position.set(-MAP_HALF, 20, 0); wall3.rotation.y = Math.PI/2; wall3.receiveShadow = true; scene.add(wall3);
const wall4 = new THREE.Mesh(wallGeo, wallMat); wall4.position.set(MAP_HALF, 20, 0); wall4.rotation.y = -Math.PI/2; wall4.receiveShadow = true; scene.add(wall4);

// ============ SPAWN DOORS ============
const DOOR_WIDTH = 4;
const DOOR_HEIGHT = 6;
const DOOR_DEPTH = 1.5;

// Dark rusty metal door material
const doorMat = new THREE.MeshStandardMaterial({
    color: 0x1a1a1a,
    roughness: 0.7,
    metalness: 0.8,
    emissive: 0x000000
});

// Door frame material (slightly lighter)
const doorFrameMat = new THREE.MeshStandardMaterial({
    color: 0x2a2a2a,
    roughness: 0.6,
    metalness: 0.7
});

// Create door geometry
const doorGeo = new THREE.BoxGeometry(DOOR_WIDTH, DOOR_HEIGHT, DOOR_DEPTH);
const doorFrameGeo = new THREE.BoxGeometry(DOOR_WIDTH + 0.6, DOOR_HEIGHT + 0.4, DOOR_DEPTH + 0.2);

// Spawn doors array (stores door objects and spawn positions)
const spawnDoors = [];

// Create doors on each wall (2 per wall = 8 total)
function createSpawnDoor(x, z, rotationY, wallSide) {
    const doorGroup = new THREE.Group();

    // Door frame (dark background)
    const frame = new THREE.Mesh(doorFrameGeo, doorFrameMat);
    frame.position.y = 0;
    frame.castShadow = true;
    frame.receiveShadow = true;
    doorGroup.add(frame);

    // Left door panel
    const leftDoor = new THREE.Mesh(
        new THREE.BoxGeometry(DOOR_WIDTH / 2 - 0.1, DOOR_HEIGHT - 0.4, 0.3),
        doorMat.clone()
    );
    leftDoor.position.set(-DOOR_WIDTH / 4, 0, DOOR_DEPTH / 2 + 0.1);
    leftDoor.castShadow = true;
    leftDoor.userData.originalX = leftDoor.position.x;
    leftDoor.userData.isLeftDoor = true;
    doorGroup.add(leftDoor);

    // Right door panel
    const rightDoor = new THREE.Mesh(
        new THREE.BoxGeometry(DOOR_WIDTH / 2 - 0.1, DOOR_HEIGHT - 0.4, 0.3),
        doorMat.clone()
    );
    rightDoor.position.set(DOOR_WIDTH / 4, 0, DOOR_DEPTH / 2 + 0.1);
    rightDoor.castShadow = true;
    rightDoor.userData.originalX = rightDoor.position.x;
    rightDoor.userData.isRightDoor = true;
    doorGroup.add(rightDoor);

    // Red warning light above door
    const warningLight = new THREE.Mesh(
        new THREE.SphereGeometry(0.2, 8, 8),
        new THREE.MeshStandardMaterial({
            color: 0x330000,
            emissive: 0x330000,
            emissiveIntensity: 0.5
        })
    );
    warningLight.position.set(0, DOOR_HEIGHT / 2 + 0.5, DOOR_DEPTH / 2);
    doorGroup.add(warningLight);

    // Position the door group
    doorGroup.position.set(x, DOOR_HEIGHT / 2 - 5, z); // -5 is floor offset
    doorGroup.rotation.y = rotationY;
    scene.add(doorGroup);

    // Calculate spawn position (slightly in front of door)
    const spawnOffset = 3;
    let spawnX = x, spawnZ = z;
    switch (wallSide) {
        case 'north': spawnZ += spawnOffset; break;
        case 'south': spawnZ -= spawnOffset; break;
        case 'west': spawnX += spawnOffset; break;
        case 'east': spawnX -= spawnOffset; break;
    }

    spawnDoors.push({
        group: doorGroup,
        leftDoor: leftDoor,
        rightDoor: rightDoor,
        warningLight: warningLight,
        spawnX: spawnX,
        spawnZ: spawnZ,
        isOpen: false,
        openTimer: 0
    });
}

// Create doors on each wall (3 per wall for larger arena = 12 total)
// North wall (z = -MAP_HALF): 3 doors
createSpawnDoor(-40, -MAP_HALF + 0.5, 0, 'north');
createSpawnDoor(0, -MAP_HALF + 0.5, 0, 'north');
createSpawnDoor(40, -MAP_HALF + 0.5, 0, 'north');

// South wall (z = MAP_HALF): 3 doors
createSpawnDoor(-40, MAP_HALF - 0.5, Math.PI, 'south');
createSpawnDoor(0, MAP_HALF - 0.5, Math.PI, 'south');
createSpawnDoor(40, MAP_HALF - 0.5, Math.PI, 'south');

// West wall (x = -MAP_HALF): 3 doors
createSpawnDoor(-MAP_HALF + 0.5, -40, Math.PI / 2, 'west');
createSpawnDoor(-MAP_HALF + 0.5, 0, Math.PI / 2, 'west');
createSpawnDoor(-MAP_HALF + 0.5, 40, Math.PI / 2, 'west');

// East wall (x = MAP_HALF): 3 doors
createSpawnDoor(MAP_HALF - 0.5, -40, -Math.PI / 2, 'east');
createSpawnDoor(MAP_HALF - 0.5, 0, -Math.PI / 2, 'east');
createSpawnDoor(MAP_HALF - 0.5, 40, -Math.PI / 2, 'east');

// Door animation function
function openDoor(door) {
    if (door.isOpen) return;
    door.isOpen = true;
    door.openTimer = 0;

    // Flash warning light red
    door.warningLight.material.emissive.setHex(0xff0000);
    door.warningLight.material.emissiveIntensity = 2;

    // Play door sound
    playSound('doorOpen');
}

function updateDoors(dt) {
    for (const door of spawnDoors) {
        if (door.isOpen) {
            door.openTimer += dt;

            // Animate doors sliding open (0 to 0.3 seconds)
            const openProgress = Math.min(door.openTimer / 0.3, 1);
            const eased = 1 - Math.pow(1 - openProgress, 3); // ease out cubic

            door.leftDoor.position.x = door.leftDoor.userData.originalX - (DOOR_WIDTH / 2) * eased;
            door.rightDoor.position.x = door.rightDoor.userData.originalX + (DOOR_WIDTH / 2) * eased;

            // Close door after 1.5 seconds
            if (door.openTimer > 1.5) {
                door.isOpen = false;
                door.openTimer = 0;
                door.warningLight.material.emissive.setHex(0x330000);
                door.warningLight.material.emissiveIntensity = 0.5;
            }
        } else if (door.leftDoor.position.x !== door.leftDoor.userData.originalX) {
            // Animate closing
            door.openTimer += dt;
            const closeProgress = Math.min(door.openTimer / 0.5, 1);
            const eased = 1 - Math.pow(1 - closeProgress, 2);

            door.leftDoor.position.x = door.leftDoor.userData.originalX - (DOOR_WIDTH / 2) * (1 - eased);
            door.rightDoor.position.x = door.rightDoor.userData.originalX + (DOOR_WIDTH / 2) * (1 - eased);

            if (closeProgress >= 1) {
                door.openTimer = 0;
            }
        }
    }
}

const targets = [];
targets.push(floor, hill, wall1, wall2, wall3, wall4);

// ============ COLLISION SYSTEM ============
// Get bounding box for an object (handles world transforms)
function getBoundingBox(obj) {
    const box = new THREE.Box3();
    box.setFromObject(obj);
    return box;
}

// Check if a circular entity at (x, z) with radius collides with walls or obstacles
function checkCollision(x, z, radius, excludeObj = null) {
    // Check walls (map boundaries)
    if (Math.abs(x) + radius > MAP_HALF || Math.abs(z) + radius > MAP_HALF) {
        return true;
    }
    
    // Check obstacles
    for (const obstacle of obstacles) {
        if (obstacle === excludeObj) continue;
        
        const box = getBoundingBox(obstacle);
        const centerX = (box.min.x + box.max.x) / 2;
        const centerZ = (box.min.z + box.max.z) / 2;
        const sizeX = box.max.x - box.min.x;
        const sizeZ = box.max.z - box.min.z;
        const obstacleRadius = Math.max(sizeX, sizeZ) / 2;
        
        const dx = x - centerX;
        const dz = z - centerZ;
        const dist = Math.sqrt(dx * dx + dz * dz);
        
        if (dist < radius + obstacleRadius) {
            return true;
        }
    }
    
    return false;
}

// Resolve collision by sliding along walls/obstacles
function resolveCollision(oldX, oldZ, newX, newZ, radius, excludeObj = null) {
    // Try new position
    if (!checkCollision(newX, newZ, radius, excludeObj)) {
        return { x: newX, z: newZ, collided: false };
    }
    
    // Try sliding along X axis only
    if (!checkCollision(newX, oldZ, radius, excludeObj)) {
        return { x: newX, z: oldZ, collided: true };
    }
    
    // Try sliding along Z axis only
    if (!checkCollision(oldX, newZ, radius, excludeObj)) {
        return { x: oldX, z: newZ, collided: true };
    }
    
    // Can't move, stay at old position
    return { x: oldX, z: oldZ, collided: true };
}

// Better Obstacles
const barrierMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
const drumMat = new THREE.MeshStandardMaterial({ map: metalTexDark, roughness: 0.4, metalness: 0.8, color: 0x553333 });
// Wood crates like the photo
const crateMat = new THREE.MeshStandardMaterial({ map: woodTex, color: 0x886644, roughness: 0.7 });
const obstacles = []; // Store obstacle references for target placement

for(let i=0; i<30; i++) {
    let mesh;
    const r = Math.random();
    if(r > 0.6) {
        // Wooden Crate
        mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), crateMat);
        mesh.position.y = -3.5;
    } else if (r > 0.3) {
        // Concrete Jersey Barrier
        mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 2.5, 1), barrierMat);
        mesh.position.y = -3.75;
    } else {
        // Steel Drum
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 16), drumMat);
        mesh.position.y = -3.5;
    }
    mesh.position.x = (Math.random() - 0.5) * (MAP_SIZE - 10); // Keep obstacles away from walls
    mesh.position.z = (Math.random() - 0.5) * (MAP_SIZE - 10);
    mesh.rotation.y = Math.random() * Math.PI;
    mesh.castShadow = true; mesh.receiveShadow = true;
    scene.add(mesh);
    targets.push(mesh);
    obstacles.push(mesh); // Store for target placement
}

// SHOOTING TARGETS
const shootingTargets = [];

// Create target geometry (silhouette shape)
function createTargetMesh() {
    const group = new THREE.Group();

    // Head
    const headGeo = new THREE.CircleGeometry(0.8, 16);
    const targetMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.8,
        side: THREE.DoubleSide
    });
    const head = new THREE.Mesh(headGeo, targetMat);
    head.position.y = 3.2;
    group.add(head);

    // Body (torso)
    const bodyGeo = new THREE.PlaneGeometry(1.6, 2.4);
    const body = new THREE.Mesh(bodyGeo, targetMat);
    body.position.y = 1.6;
    group.add(body);

    // Base/stand
    const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
    const standGeo = new THREE.BoxGeometry(0.15, 4.4, 0.15);
    const stand = new THREE.Mesh(standGeo, standMat);
    stand.position.y = 2.0;
    stand.position.z = 0.15;
    group.add(stand);

    const baseGeo = new THREE.BoxGeometry(1.2, 0.15, 0.8);
    const base = new THREE.Mesh(baseGeo, standMat);
    base.position.y = -0.05;
    group.add(base);

    return group;
}

// Target class
class ShootingTarget {
    constructor(position) {
        this.mesh = createTargetMesh();
        this.mesh.position.copy(position);
        this.mesh.position.y = -5; // Ground level

        this.pivotPoint = new THREE.Group();
        this.pivotPoint.position.copy(this.mesh.position);
        this.pivotPoint.add(this.mesh);
        this.mesh.position.set(0, 0, 0);

        scene.add(this.pivotPoint);

        this.isUp = false;
        this.isAnimating = false;
        this.rotation = 0;
        this.targetRotation = Math.PI / 2; // Fallen state

        // Add hitbox to raycast targets
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4, 0.5),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2;
        this.pivotPoint.add(this.hitbox);
        this.hitbox.userData.isTarget = true;
        this.hitbox.userData.targetRef = this;
        targets.push(this.hitbox);
    }

    popup(obstacle) {
        if (this.isAnimating) return;
        this.isAnimating = true;

        // Position behind obstacle
        const pos = obstacle.position.clone();
        pos.x += (Math.random() - 0.5) * 2;
        pos.z += (Math.random() > 0.5 ? 2 : -2);
        this.pivotPoint.position.set(pos.x, -5, pos.z);
        this.pivotPoint.rotation.y = Math.atan2(
            camera.position.x - pos.x,
            camera.position.z - pos.z
        );

        // Animate up
        this.targetRotation = 0;
        this.isUp = true;
    }

    knockDown() {
        if (!this.isUp || this.isAnimating) return;
        this.isAnimating = true;
        this.targetRotation = Math.PI / 2;
        this.isUp = false;

        // Schedule popup at new location
        setTimeout(() => {
            if (obstacles.length > 0) {
                const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                this.popup(randomObstacle);
            }
        }, 1500 + Math.random() * 2000);
    }

    update(dt) {
        // Smooth rotation animation
        const diff = this.targetRotation - this.rotation;
        if (Math.abs(diff) > 0.01) {
            this.rotation += diff * 8 * dt;
            this.pivotPoint.rotation.x = -this.rotation;
        } else {
            this.rotation = this.targetRotation;
            this.isAnimating = false;
        }
    }
}

// Create shooting targets
for (let i = 0; i < 8; i++) {
    const target = new ShootingTarget(new THREE.Vector3(0, -5, 0));
    shootingTargets.push(target);

    // Spawn at random obstacle after delay
    setTimeout(() => {
        if (obstacles.length > 0) {
            const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            target.popup(randomObstacle);
        }
    }, 1000 + i * 500);
}

// ZOMBIES
const zombies = [];

// Zombie materials - decayed greenish-grey skin
const zombieSkinMat = new THREE.MeshStandardMaterial({ color: 0x5a6b4a, roughness: 0.9 });
const zombieSkinDarkMat = new THREE.MeshStandardMaterial({ color: 0x3d4a35, roughness: 0.9 });

// Create tattered shirt texture
const shirtTexCanvas = document.createElement('canvas');
shirtTexCanvas.width = 256; shirtTexCanvas.height = 256;
const shirtTexCtx = shirtTexCanvas.getContext('2d');
// Base dirty brown/grey color
shirtTexCtx.fillStyle = '#3a3530';
shirtTexCtx.fillRect(0, 0, 256, 256);
// Add blood stains
shirtTexCtx.fillStyle = '#4a1515';
for (let i = 0; i < 8; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.arc(Math.random() * 256, Math.random() * 256, 15 + Math.random() * 30, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add tears/holes (dark spots)
shirtTexCtx.fillStyle = '#1a1a1a';
for (let i = 0; i < 5; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.ellipse(Math.random() * 256, Math.random() * 256, 8 + Math.random() * 15, 4 + Math.random() * 10, Math.random() * Math.PI, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add dirt streaks
shirtTexCtx.strokeStyle = '#2a2520';
shirtTexCtx.lineWidth = 3;
for (let i = 0; i < 10; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.moveTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.lineTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.stroke();
}
const shirtTex = new THREE.CanvasTexture(shirtTexCanvas);

const zombieShirtMat = new THREE.MeshStandardMaterial({ map: shirtTex, roughness: 0.8 });
const zombiePantsMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.8 });

// ============ ZOMBIE VARIANTS ============
const ZOMBIE_VARIANTS = {
    normal: {
        name: 'Normal',
        scale: 1.0,
        healthMod: 1.0,
        speedMod: 1.0,
        damageMod: 1.0,
        skinColor: 0x5a6b4a,     // Gray-green
        skinColorDark: 0x3d4a35,
        shirtColor: null,        // Use default texture
        pantsColor: 0x252525,
        spawnWeight: 50          // Higher = more common
    },
    runner: {
        name: 'Runner',
        scale: 0.85,
        healthMod: 0.5,          // Low health
        speedMod: 1.8,           // Very fast
        damageMod: 0.7,
        skinColor: 0x8a9a8a,     // Pale gray
        skinColorDark: 0x6a7a6a,
        shirtColor: 0x444444,
        pantsColor: 0x333333,
        spawnWeight: 25
    },
    brute: {
        name: 'Brute',
        scale: 1.5,
        healthMod: 3.0,          // Very tanky
        speedMod: 0.55,          // Slow
        damageMod: 2.5,          // Hits hard
        skinColor: 0x4a2525,     // Dark red/brown
        skinColorDark: 0x351818,
        shirtColor: 0x2a1515,
        pantsColor: 0x1a1010,
        spawnWeight: 10
    },
    crawler: {
        name: 'Crawler',
        scale: 0.65,
        healthMod: 0.8,
        speedMod: 0.7,
        damageMod: 1.2,
        skinColor: 0x5a4a35,     // Rotted brown
        skinColorDark: 0x3d3020,
        shirtColor: 0x352a20,
        pantsColor: 0x252015,
        spawnWeight: 15
    }
};

// Pick random variant based on wave and weights
function pickZombieVariant(waveNum) {
    // Early waves: mostly normal zombies
    // Later waves: more special variants
    const variantChance = Math.min(0.6, 0.1 + waveNum * 0.05);

    if (Math.random() > variantChance) {
        return 'normal';
    }

    // Pick weighted random variant (excluding normal for special spawn)
    const specialVariants = ['runner', 'brute', 'crawler'];
    let weights = specialVariants.map(v => {
        let w = ZOMBIE_VARIANTS[v].spawnWeight;
        // Brutes more common in later waves
        if (v === 'brute' && waveNum >= 5) w *= 1.5;
        // Runners more common early
        if (v === 'runner' && waveNum < 3) w *= 1.5;
        return w;
    });

    const totalWeight = weights.reduce((a, b) => a + b, 0);
    let roll = Math.random() * totalWeight;

    for (let i = 0; i < specialVariants.length; i++) {
        roll -= weights[i];
        if (roll <= 0) return specialVariants[i];
    }

    return 'normal';
}

function createZombieMesh(variant = 'normal') {
    const config = ZOMBIE_VARIANTS[variant] || ZOMBIE_VARIANTS.normal;
    const group = new THREE.Group();
    const baseScale = 2.0;
    const scale = baseScale * config.scale;

    // Create variant-specific materials
    const variantSkinMat = new THREE.MeshStandardMaterial({
        color: config.skinColor,
        roughness: 0.9
    });
    const variantSkinDarkMat = new THREE.MeshStandardMaterial({
        color: config.skinColorDark,
        roughness: 0.9
    });
    const variantShirtMat = config.shirtColor
        ? new THREE.MeshStandardMaterial({ color: config.shirtColor, roughness: 0.8 })
        : zombieShirtMat;
    const variantPantsMat = new THREE.MeshStandardMaterial({
        color: config.pantsColor,
        roughness: 0.8
    });

    // Head - variant colored zombie skin
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.35 * scale, 12, 8), variantSkinMat);
    head.position.y = 1.85 * scale;
    head.castShadow = true;
    group.add(head);

    // Torso - variant shirt
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale), variantShirtMat);
    torso.position.y = 1.1 * scale;
    torso.castShadow = true;
    group.add(torso);

    // Arms - zombie skin, arms extended forward
    const armGeo = new THREE.BoxGeometry(0.2 * scale, 0.7 * scale, 0.2 * scale);
    const leftArm = new THREE.Mesh(armGeo, variantSkinMat);
    leftArm.position.set(-0.45 * scale, 1.3 * scale, 0.4 * scale);
    leftArm.rotation.x = -Math.PI / 3; // Arms reaching forward
    leftArm.castShadow = true;
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, variantSkinDarkMat);
    rightArm.position.set(0.45 * scale, 1.3 * scale, 0.4 * scale);
    rightArm.rotation.x = -Math.PI / 3;
    rightArm.castShadow = true;
    group.add(rightArm);

    // Legs - variant pants
    const legGeo = new THREE.BoxGeometry(0.25 * scale, 0.8 * scale, 0.25 * scale);
    const leftLeg = new THREE.Mesh(legGeo, variantPantsMat);
    leftLeg.position.set(-0.2 * scale, 0.4 * scale, 0);
    leftLeg.castShadow = true;
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, variantPantsMat);
    rightLeg.position.set(0.2 * scale, 0.4 * scale, 0);
    rightLeg.castShadow = true;
    group.add(rightLeg);

    // Store variant info on group for reference
    group.userData.variant = variant;
    group.userData.variantScale = config.scale;

    return group;
}

// ============ HIVE MIND - SHARED ZOMBIE INTELLIGENCE ============
const HiveMind = {
    // Shared state (updated once per frame, all zombies reference)
    playerPos: { x: 0, z: 0 },
    playerVelocity: { x: 0, z: 0 },
    threatDirection: { x: 0, z: 0 },  // Where player is shooting/aiming
    threatIntensity: 0,                 // How much threat (0-1)
    
    // Flanking system - 8 positions around player
    flankSlots: [],
    flankRadius: 8.0,                    // Distance from player for flanking
    numFlankSlots: 8,
    
    // Performance tracking
    frameCounter: 0,
    
    // Update shared intelligence (called once per frame)
    update(dt) {
        this.frameCounter++;
        
        // Track player position and velocity
        const oldX = this.playerPos.x;
        const oldZ = this.playerPos.z;
        this.playerPos.x = camera.position.x;
        this.playerPos.z = camera.position.z;
        
        // Calculate player velocity (smoothed)
        const velX = (this.playerPos.x - oldX) / dt;
        const velZ = (this.playerPos.z - oldZ) / dt;
        this.playerVelocity.x = THREE.MathUtils.lerp(this.playerVelocity.x, velX, 0.3);
        this.playerVelocity.z = THREE.MathUtils.lerp(this.playerVelocity.z, velZ, 0.3);
        
        // Calculate threat direction (where player is aiming)
        const cameraDir = new THREE.Vector3();
        camera.getWorldDirection(cameraDir);
        this.threatDirection.x = cameraDir.x;
        this.threatDirection.z = cameraDir.z;
        
        // Update threat intensity (higher when player is shooting/aiming)
        if (isFiring) {
            this.threatIntensity = Math.min(1.0, this.threatIntensity + dt * 5);
        } else {
            this.threatIntensity = Math.max(0, this.threatIntensity - dt * 2);
        }
        
        // Precompute flank positions around player (once per frame)
        const angleStep = (Math.PI * 2) / this.numFlankSlots;
        this.flankSlots = [];
        for (let i = 0; i < this.numFlankSlots; i++) {
            const angle = i * angleStep;
            this.flankSlots.push({
                x: this.playerPos.x + Math.cos(angle) * this.flankRadius,
                z: this.playerPos.z + Math.sin(angle) * this.flankRadius,
                angle: angle,
                occupied: false,
                occupiedBy: null
            });
        }
    },
    
    // Find best available flank slot for a zombie
    claimFlankSlot(zombie) {
        // Find closest unoccupied slot
        let bestSlot = null;
        let bestDist = Infinity;
        
        for (const slot of this.flankSlots) {
            if (slot.occupied && slot.occupiedBy !== zombie) continue;
            
            const dx = slot.x - zombie.mesh.position.x;
            const dz = slot.z - zombie.mesh.position.z;
            const dist = dx * dx + dz * dz; // Squared distance
            
            if (dist < bestDist) {
                bestDist = dist;
                bestSlot = slot;
            }
        }
        
        if (bestSlot) {
            // Release old slot if zombie had one
            for (const slot of this.flankSlots) {
                if (slot.occupiedBy === zombie) {
                    slot.occupied = false;
                    slot.occupiedBy = null;
                }
            }
            
            bestSlot.occupied = true;
            bestSlot.occupiedBy = zombie;
            return bestSlot;
        }
        
        return null;
    },
    
    // Release a flank slot when zombie dies or changes behavior
    releaseFlankSlot(zombie) {
        for (const slot of this.flankSlots) {
            if (slot.occupiedBy === zombie) {
                slot.occupied = false;
                slot.occupiedBy = null;
            }
        }
    }
};

class Zombie {
    constructor(x, z, waveNum = 1, variant = 'normal') {
        // Get variant config
        this.variant = variant;
        this.variantConfig = ZOMBIE_VARIANTS[variant] || ZOMBIE_VARIANTS.normal;

        this.mesh = createZombieMesh(variant);
        this.mesh.position.set(x, -5, z);
        scene.add(this.mesh);

        // Scale health and speed with wave AND variant
        const waveMod = 1 + (waveNum - 1) * 0.1;
        const baseHealth = Math.floor(2 + Math.random() * 2 * waveMod);
        this.health = Math.floor(baseHealth * this.variantConfig.healthMod);
        this.maxHealth = this.health;
        const baseSpd = 4.0 + Math.random() * 2.0; // Slower zombies
        this.baseSpeed = baseSpd * this.variantConfig.speedMod;
        this.speed = this.baseSpeed;

        // State
        this.isDead = false;
        this.deathTime = 0;
        this.attackCooldown = 0;
        this.attackRange = 3.5 * this.variantConfig.scale; // Scale attack range with size
        const baseDamage = 10 + Math.floor(waveNum / 2) * 5;
        this.attackDamage = Math.floor(baseDamage * this.variantConfig.damageMod);
        this.headExploded = false; // Tracks if head was blown off
        
        // AI STATE - Swarm Intelligence
        this.aiRole = this.assignRole(); // 'rusher', 'flanker', 'lurker'
        this.flankSlot = null;
        this.flankAngle = 0;
        this.separationForce = { x: 0, z: 0 };
        this.stuckTimer = 0;
        this.lastPositions = []; // For stuck detection (circular buffer)
        this.threatAwareness = 0; // Knows when being aimed at (0-1)
        this.updateCounter = 0; // For staggered updates
        this.aiWave = waveNum; // Store wave for adaptive behavior

        // FLUID Animation state
        this.walkCycle = Math.random() * Math.PI * 2;
        this.swayOffset = Math.random() * Math.PI * 2;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.limbPhase = Math.random() * Math.PI * 2;
        this.headBob = 0;
        this.bodyLean = 0;
        this.armSwing = 0;

        // Ragdoll parts (populated on death)
        this.ragdollParts = [];

        // Hitbox for raycasting (scaled by variant)
        const hitScale = this.variantConfig.scale;
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6 * hitScale, 4.4 * hitScale, 1.0 * hitScale),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2.2 * hitScale;
        this.mesh.add(this.hitbox);
        this.hitbox.userData.isBot = true;
        this.hitbox.userData.botRef = this;
        targets.push(this.hitbox);
    }
    
    // Assign tactical role based on spawn order and position
    assignRole() {
        const rand = Math.random();
        if (rand < 0.4) return 'rusher';   // 40% direct charge
        if (rand < 0.75) return 'flanker'; // 35% flanking
        return 'lurker';                     // 25% slower approach
    }
    
    // Calculate separation force from nearby zombies (prevents clumping)
    calculateSeparation(zombiesArray, dt) {
        this.separationForce.x = 0;
        this.separationForce.z = 0;
        
        const separationRadius = 3.0; // Distance to maintain from other zombies
        const separationRadiusSq = separationRadius * separationRadius;
        let neighborCount = 0;
        
        // Only check 3 closest zombies for performance (reduced from 5)
        const nearbyZombies = zombiesArray
            .filter(z => z !== this && !z.isDead)
            .map(z => {
                const dx = z.mesh.position.x - this.mesh.position.x;
                const dz = z.mesh.position.z - this.mesh.position.z;
                return { zombie: z, distSq: dx * dx + dz * dz, dx, dz };
            })
            .sort((a, b) => a.distSq - b.distSq)
            .slice(0, 3);
        
        for (const neighbor of nearbyZombies) {
            if (neighbor.distSq < separationRadiusSq && neighbor.distSq > 0.01) {
                const dist = Math.sqrt(neighbor.distSq);
                const strength = (separationRadius - dist) / separationRadius;
                
                // Push away from neighbor
                this.separationForce.x -= (neighbor.dx / dist) * strength * 2.0;
                this.separationForce.z -= (neighbor.dz / dist) * strength * 2.0;
                neighborCount++;
            }
        }
        
        // Normalize if multiple neighbors
        if (neighborCount > 0) {
            const mag = Math.sqrt(this.separationForce.x * this.separationForce.x + this.separationForce.z * this.separationForce.z);
            if (mag > 0.01) {
                this.separationForce.x /= mag;
                this.separationForce.z /= mag;
            }
        }
    }
    
    // Calculate steering forces based on AI role and wave difficulty
    calculateSteering(playerPos, dt) {
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const distSq = dx * dx + dz * dz;
        const dist = Math.sqrt(distSq);
        
        // Adaptive behavior based on wave
        const waveLevel = Math.min(this.aiWave, 7);
        const hasSeparation = waveLevel >= 3;
        const hasFlanking = waveLevel >= 5;
        const hasFullTactics = waveLevel >= 7;
        
        let targetX = playerPos.x;
        let targetZ = playerPos.z;
        let seekWeight = 1.0;
        
        // Role-based behavior
        if (this.aiRole === 'rusher') {
            // Direct charge - higher speed multiplier
            this.speed = this.baseSpeed * (hasFullTactics ? 1.3 : 1.1);
            seekWeight = 1.2; // Stronger seek
        } else if (this.aiRole === 'flanker' && hasFlanking) {
            // Flanking behavior
            if (!this.flankSlot) {
                this.flankSlot = HiveMind.claimFlankSlot(this);
            }
            
            if (this.flankSlot) {
                // Move toward flank position, but still seek player if close
                const flankWeight = dist > 10 ? 0.8 : 0.3;
                targetX = THREE.MathUtils.lerp(playerPos.x, this.flankSlot.x, flankWeight);
                targetZ = THREE.MathUtils.lerp(playerPos.z, this.flankSlot.z, flankWeight);
                this.speed = this.baseSpeed * 0.9; // Slightly slower for flanking
            }
        } else if (this.aiRole === 'lurker') {
            // Slower, cautious approach
            this.speed = this.baseSpeed * 0.7;
            seekWeight = 0.6;
            
            // Lurkers avoid threat direction
            if (HiveMind.threatIntensity > 0.5) {
                const threatDot = (dx * HiveMind.threatDirection.x + dz * HiveMind.threatDirection.z) / dist;
                if (threatDot > 0.5) {
                    // Being aimed at - move perpendicular
                    const perpX = -HiveMind.threatDirection.z;
                    const perpZ = HiveMind.threatDirection.x;
                    targetX = this.mesh.position.x + perpX * 5;
                    targetZ = this.mesh.position.z + perpZ * 5;
                }
            }
        }
        
        // Calculate seek vector
        const seekX = (targetX - this.mesh.position.x) / Math.max(dist, 0.1);
        const seekZ = (targetZ - this.mesh.position.z) / Math.max(dist, 0.1);
        
        // Combine forces
        let finalX = seekX * seekWeight;
        let finalZ = seekZ * seekWeight;
        
        // Add separation (if enabled for this wave)
        if (hasSeparation) {
            finalX += this.separationForce.x * 0.4;
            finalZ += this.separationForce.z * 0.4;
        }
        
        // Normalize final vector
        const finalMag = Math.sqrt(finalX * finalX + finalZ * finalZ);
        if (finalMag > 0.01) {
            finalX /= finalMag;
            finalZ /= finalMag;
        }
        
        return { x: finalX, z: finalZ };
    }
    
    // Detect if zombie is stuck
    checkStuck() {
        this.lastPositions.push({ x: this.mesh.position.x, z: this.mesh.position.z });
        if (this.lastPositions.length > 10) {
            this.lastPositions.shift();
        }
        
        if (this.lastPositions.length >= 5) {
            const first = this.lastPositions[0];
            const last = this.lastPositions[this.lastPositions.length - 1];
            const dx = last.x - first.x;
            const dz = last.z - first.z;
            const moved = Math.sqrt(dx * dx + dz * dz);
            
            if (moved < 0.5) {
                this.stuckTimer += 0.016; // Assume ~60fps
                if (this.stuckTimer > 1.0) {
                    // Stuck - try random movement
                    this.stuckTimer = 0;
                    this.lastPositions = [];
                    return true;
                }
            } else {
                this.stuckTimer = 0;
            }
        }
        
        return false;
    }

    hit(hitPoint) {
        if (this.isDead) return;

        // Apply damage (boosted if power-up active)
        const damage = damageBoostTimer > 0 ? damageBoostMultiplier : 1;
        this.health -= damage;
        playSound('zombieHit');

        // === ENHANCED: Hit Stagger Animation ===
        // Direction from player to zombie (knockback direction)
        const knockDir = new THREE.Vector3();
        knockDir.subVectors(this.mesh.position, camera.position).normalize();

        // Stagger/flinch with random variation
        const flinchIntensity = 0.15 + Math.random() * 0.15;
        this.mesh.rotation.x = -flinchIntensity - Math.random() * 0.1;
        this.mesh.rotation.z = (Math.random() - 0.5) * 0.2; // Slight random side tilt

        // Knockback - push zombie away from player slightly
        const knockbackStrength = 0.3 + Math.random() * 0.2;
        this.mesh.position.x += knockDir.x * knockbackStrength;
        this.mesh.position.z += knockDir.z * knockbackStrength;

        // Store hit time for stagger recovery animation
        if (!this.lastHitTime) this.lastHitTime = 0;
        this.lastHitTime = performance.now();
        this.isStaggered = true;

        // Schedule stagger recovery
        setTimeout(() => {
            if (!this.isDead) {
                this.isStaggered = false;
            }
        }, 150 + Math.random() * 100);

        // VIOLENT blood spray from hit point
        const bloodPos = hitPoint || this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        const bloodDir = knockDir.clone();
        spawnBloodSpray(bloodPos, bloodDir, this.health <= 0 ? 4 : 2); // More blood on every hit
        if (Math.random() > 0.5) {
            spawnGoreChunks(bloodPos, bloodDir); // Chance for gore on hits too
        }

        if (this.health <= 0) {
            this.die();
        }
    }

    die() {
        this.isDead = true;
        this.deathTime = performance.now();

        // Release flank slot when zombie dies
        HiveMind.releaseFlankSlot(this);

        // Only play death sound if not headshot (headshot has its own sound)
        if (!this.headExploded) {
            playSound('zombieDeath');
            addScore(100);
        }
        // Headshot score is already added in shoot()
        zombiesKilledThisWave++;

        // Remove hitbox from targets
        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);

        // Get direction from camera to zombie for death impulse
        const deathDir = new THREE.Vector3();
        deathDir.subVectors(this.mesh.position, camera.position).normalize();

        // Gore effects - less if headshot (head already exploded separately)
        if (!this.headExploded) {
            const centerPos = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
            spawnGoreChunks(centerPos, deathDir);
            spawnGoreChunks(centerPos, deathDir); // Double gore
            spawnBloodSpray(centerPos, deathDir, 4); // Much more blood
            spawnBloodSpray(centerPos.clone().add(new THREE.Vector3(0, -0.5, 0)), deathDir, 3);
        } else {
            // For headshot, just torso/body blood
            const torsoPos = this.mesh.position.clone().add(new THREE.Vector3(0, 1.5, 0));
            spawnBloodSpray(torsoPos, deathDir, 2);
        }
        spawnBloodPool(this.mesh.position.clone());
        spawnBloodPool(this.mesh.position.clone().add(new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5)));

        // Detach each body part (skip hitbox at index 6)
        for (let i = 0; i < 6; i++) {
            const part = this.mesh.children[0];
            if (!part) continue;

            const partWorldPos = new THREE.Vector3();
            part.getWorldPosition(partWorldPos);

            this.mesh.remove(part);
            scene.add(part);
            part.position.copy(partWorldPos);

            // VIOLENT ragdoll - much more force
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * 15 + deathDir.x * 12,
                Math.random() * 10 + 5,
                (Math.random() - 0.5) * 15 + deathDir.z * 12
            );

            const rotVel = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25
            );

            this.ragdollParts.push({
                mesh: part,
                velocity: vel,
                rotVelocity: rotVel,
                grounded: false,
                bleedTimer: 0,
                canBleed: true
            });
        }

        this.mesh.visible = false;
    }

    cleanup() {
        // Remove from scene completely
        for (const part of this.ragdollParts) {
            scene.remove(part.mesh);
        }
        this.ragdollParts = [];
        scene.remove(this.mesh);

        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);
    }

    update(dt, time) {
        if (this.isDead) {
            // Update ragdoll physics
            const groundY = -4.8;
            const friction = 0.85;
            const bounciness = 0.3;

            for (const part of this.ragdollParts) {
                if (!part.grounded) {
                    // Apply gravity
                    part.velocity.y -= 25 * dt;
                    
                    // Store old position for collision resolution
                    const oldX = part.mesh.position.x;
                    const oldZ = part.mesh.position.z;
                    
                    // Calculate new position
                    const newX = oldX + part.velocity.x * dt;
                    const newZ = oldZ + part.velocity.z * dt;
                    
                    // Apply collision detection for ragdoll parts (smaller radius ~0.3)
                    // Exclude the part's own mesh to prevent self-collision
                    const partRadius = 0.3;
                    const resolved = resolveCollision(oldX, oldZ, newX, newZ, partRadius, part.mesh);
                    part.mesh.position.x = resolved.x;
                    part.mesh.position.z = resolved.z;
                    
                    // Apply vertical movement
                    part.mesh.position.y += part.velocity.y * dt;
                    
                    // Rotation
                    part.mesh.rotation.x += part.rotVelocity.x * dt;
                    part.mesh.rotation.y += part.rotVelocity.y * dt;
                    part.mesh.rotation.z += part.rotVelocity.z * dt;

                    // Ground collision
                    if (part.mesh.position.y < groundY) {
                        part.mesh.position.y = groundY;
                        if (Math.abs(part.velocity.y) > 1) {
                            part.velocity.y *= -bounciness;
                            part.velocity.x *= friction;
                            part.velocity.z *= friction;
                            part.rotVelocity.multiplyScalar(0.7);
                        } else {
                            part.velocity.set(0, 0, 0);
                            part.rotVelocity.multiplyScalar(0.9);
                            if (part.rotVelocity.length() < 0.1) {
                                part.grounded = true;
                            }
                        }
                    }
                    
                    // Apply friction
                    part.velocity.multiplyScalar(0.995);
                    
                    // If collision occurred, reduce velocity
                    if (resolved.collided) {
                        part.velocity.x *= 0.5;
                        part.velocity.z *= 0.5;
                        part.rotVelocity.multiplyScalar(0.8);
                    }

                    if (part.canBleed) {
                        part.bleedTimer += dt;
                        if (part.bleedTimer > 0.08) {
                            part.bleedTimer = 0;
                            const dropMat = new THREE.SpriteMaterial({
                                map: bloodSpriteTex,
                                color: 0x880000,
                                transparent: true,
                                opacity: 0.9
                            });
                            const drop = new THREE.Sprite(dropMat);
                            drop.position.copy(part.mesh.position);
                            drop.scale.setScalar(0.1 + Math.random() * 0.1);
                            scene.add(drop);
                            bloodParticles.push({
                                mesh: drop,
                                velocity: new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.5,
                                    -1,
                                    (Math.random() - 0.5) * 0.5
                                ),
                                life: 0.8,
                                gravity: 20,
                                type: 'droplet'
                            });
                        }
                    }
                } else if (part.canBleed) {
                    part.bleedTimer += dt;
                    if (part.bleedTimer > 2) {
                        part.canBleed = false;
                    }
                }
            }
            return;
        }

        // Recover from flinch
        this.mesh.rotation.x *= 0.9;

        // INTELLIGENT CHASE WITH SWARM BEHAVIOR
        const playerPos = { x: HiveMind.playerPos.x, z: HiveMind.playerPos.z };
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const distSq = dx * dx + dz * dz;
        const dist = Math.sqrt(distSq);

        // Attack cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= dt;
        }

        // Attack if close enough
        if (dist < this.attackRange && this.attackCooldown <= 0) {
            this.attackCooldown = 1.0; // 1 second between attacks
            damagePlayer(this.attackDamage, this.mesh.position); // Pass attacker position for directional indicator
            playSound('zombieAttack');
        }

        // Update threat awareness (know when being aimed at)
        if (dist < 15) {
            const cameraDir = new THREE.Vector3();
            camera.getWorldDirection(cameraDir);
            const toZombie = new THREE.Vector3(dx, 0, dz).normalize();
            const dot = cameraDir.dot(toZombie);
            this.threatAwareness = THREE.MathUtils.lerp(this.threatAwareness, dot > 0.7 ? 1.0 : 0.0, dt * 3);
        } else {
            this.threatAwareness = THREE.MathUtils.lerp(this.threatAwareness, 0, dt * 2);
        }

        // Move with intelligent steering
        if (dist > 1.5) {
            this.updateCounter++;
            
            // Staggered updates for performance (separation every 6 frames)
            if (this.updateCounter % 6 === 0) {
                this.calculateSeparation(zombies, dt); // zombies is global array
            }
            
            // Check if stuck
            const isStuck = this.checkStuck();
            
            // Calculate steering forces
            const steering = this.calculateSteering(playerPos, dt);
            
            // Apply movement
            let moveX = steering.x * this.speed * dt;
            let moveZ = steering.z * this.speed * dt;
            
            // If stuck, add random movement
            if (isStuck) {
                const randomAngle = Math.random() * Math.PI * 2;
                moveX += Math.cos(randomAngle) * this.speed * dt * 0.5;
                moveZ += Math.sin(randomAngle) * this.speed * dt * 0.5;
            }
            
            // Store old position for collision resolution
            const oldX = this.mesh.position.x;
            const oldZ = this.mesh.position.z;
            
            // Calculate new position
            const newX = oldX + moveX;
            const newZ = oldZ + moveZ;
            
            // Apply collision detection and resolution (zombie radius ~0.6)
            const zombieRadius = 0.6;
            const resolved = resolveCollision(oldX, oldZ, newX, newZ, zombieRadius, this.mesh);
            this.mesh.position.x = resolved.x;
            this.mesh.position.z = resolved.z;
            
            // If collision occurred, release flank slot (might be blocked)
            if (resolved.collided && this.flankSlot) {
                HiveMind.releaseFlankSlot(this);
                this.flankSlot = null;
            }

            // Smooth face towards movement direction (not just player)
            const moveDirX = this.mesh.position.x - oldX;
            const moveDirZ = this.mesh.position.z - oldZ;
            const moveDist = Math.sqrt(moveDirX * moveDirX + moveDirZ * moveDirZ);
            
            if (moveDist > 0.01) {
                const targetRot = Math.atan2(moveDirX, moveDirZ);
                const rotDiff = targetRot - this.mesh.rotation.y;
                const normalizedDiff = Math.atan2(Math.sin(rotDiff), Math.cos(rotDiff));
                const turnSpeed = this.aiWave >= 7 ? 8 : 5; // Faster turning in later waves
                this.mesh.rotation.y += normalizedDiff * turnSpeed * dt;
            } else {
                // Fallback to facing player if not moving
                const targetRot = Math.atan2(dx, dz);
                const rotDiff = targetRot - this.mesh.rotation.y;
                const normalizedDiff = Math.atan2(Math.sin(rotDiff), Math.cos(rotDiff));
                this.mesh.rotation.y += normalizedDiff * 5 * dt;
            }

            // FLUID shambling walk animation
            const walkSpeed = this.speed * 1.2;
            this.walkCycle += dt * walkSpeed;
            this.limbPhase += dt * walkSpeed * 0.8; // Slightly offset phase

            const head = this.mesh.children[0];
            const torso = this.mesh.children[1];
            const leftArm = this.mesh.children[2];
            const rightArm = this.mesh.children[3];
            const leftLeg = this.mesh.children[4];
            const rightLeg = this.mesh.children[5];

            // Organic body vertical bob + terrain following
            this.headBob = THREE.MathUtils.lerp(this.headBob, Math.sin(this.walkCycle * 2) * 0.08, 0.15);
            const zombieTerrainY = getTerrainHeight(this.mesh.position.x, this.mesh.position.z);
            this.mesh.position.y = zombieTerrainY + this.headBob;

            // Body lean into movement
            this.bodyLean = THREE.MathUtils.lerp(this.bodyLean, 0.15, 0.05);
            if (torso) {
                torso.rotation.x = this.bodyLean + Math.sin(this.walkCycle) * 0.05;
                torso.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.08;
            }

            // Head wobble
            if (head) {
                head.rotation.x = Math.sin(this.walkCycle * 2 + 0.5) * 0.1;
                head.rotation.z = Math.sin(this.walkCycle + this.swayOffset) * 0.12;
                head.rotation.y = Math.sin(this.walkCycle * 0.3) * 0.15;
            }

            // Fluid leg animation - bent knee shamble
            if (leftLeg && rightLeg) {
                const legSwing = 0.5;
                leftLeg.rotation.x = Math.sin(this.walkCycle) * legSwing;
                leftLeg.rotation.z = Math.sin(this.walkCycle * 0.5) * 0.1;
                rightLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * legSwing;
                rightLeg.rotation.z = Math.sin(this.walkCycle * 0.5 + Math.PI) * 0.1;
            }

            // Arms - reaching forward with organic sway
            this.armSwing = THREE.MathUtils.lerp(this.armSwing, Math.sin(this.limbPhase) * 0.2, 0.1);
            if (leftArm && rightArm) {
                // Base reaching pose with fluid motion
                leftArm.rotation.x = -Math.PI / 3 + this.armSwing + Math.sin(this.walkCycle * 0.7) * 0.15;
                leftArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.2 - 0.1;
                rightArm.rotation.x = -Math.PI / 3 - this.armSwing + Math.sin(this.walkCycle * 0.7 + Math.PI) * 0.15;
                rightArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset + Math.PI) * 0.2 + 0.1;
            }

            // Fluid body sway (drunk shamble) - don't override when staggered
            if (!this.isStaggered) {
                this.mesh.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.1;
                this.mesh.rotation.x = Math.sin(this.walkCycle + this.bobOffset) * 0.03;
            } else {
                // During stagger, smoothly recover z rotation
                this.mesh.rotation.z *= 0.92;
            }
        } else {
            // Idle sway when close - also respect stagger
            if (!this.isStaggered) {
                this.mesh.rotation.z = Math.sin(time * 0.002 + this.swayOffset) * 0.05;
            }
        }

        // Keep within bounds (collision system handles this, but keep as backup)
        this.mesh.position.x = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.x));
        this.mesh.position.z = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.z));
    }

    // Minimal update for non-active zombies (performance optimization)
    updateMinimal(dt) {
        // Only update position and basic bounds checking
        this.mesh.position.x = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.x));
        this.mesh.position.z = Math.max(-MAP_HALF + 1, Math.min(MAP_HALF - 1, this.mesh.position.z));
    }
}

// WAVE SYSTEM
let currentWave = 0;
let zombiesThisWave = 0;
let zombiesKilledThisWave = 0;
let zombiesSpawnedThisWave = 0;
let waveInProgress = false;
let waveStartTime = 0;
let betweenWaves = true;
let nextWaveCountdown = 1; // Start fast

function startWave(waveNum) {
    currentWave = waveNum;
    zombiesThisWave = 8 + waveNum * 4; // More zombies: 12, 16, 20, 24...
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = true;
    betweenWaves = false;
    waveStartTime = performance.now();

    // Clear any remaining dead zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    updateHUD();
}

function spawnZombie() {
    if (zombiesSpawnedThisWave >= zombiesThisWave) return;
    if (spawnDoors.length === 0) return;

    // Pick a random door to spawn from
    const doorIndex = Math.floor(Math.random() * spawnDoors.length);
    const door = spawnDoors[doorIndex];

    // Open the door with animation and sound
    openDoor(door);

    // Spawn zombie at door position (slightly randomized)
    const offsetX = (Math.random() - 0.5) * 2;
    const offsetZ = (Math.random() - 0.5) * 2;
    const x = door.spawnX + offsetX;
    const z = door.spawnZ + offsetZ;

    // Pick zombie variant based on wave
    const variant = pickZombieVariant(currentWave);

    zombies.push(new Zombie(x, z, currentWave, variant));
    zombiesSpawnedThisWave++;
}

function updateWaveSystem(dt) {
    if (betweenWaves) {
        nextWaveCountdown -= dt;
        if (nextWaveCountdown <= 0) {
            startWave(currentWave + 1);
        }
        return;
    }

    if (!waveInProgress) return;

    // Spawn zombies rapidly
    const timeSinceWaveStart = (performance.now() - waveStartTime) / 1000;
    const spawnInterval = Math.max(0.2, 0.8 - currentWave * 0.05); // Much faster spawns
    const shouldHaveSpawned = Math.floor(timeSinceWaveStart / spawnInterval) + 1;

    while (zombiesSpawnedThisWave < shouldHaveSpawned && zombiesSpawnedThisWave < zombiesThisWave) {
        spawnZombie();
    }

    // Check wave completion
    if (zombiesKilledThisWave >= zombiesThisWave) {
        waveInProgress = false;
        betweenWaves = true;
        nextWaveCountdown = 2; // Quick 2 seconds between waves

        // Bonus points for wave clear
        addScore(currentWave * 500);
        playSound('waveComplete');

        // Pickups disabled for now
    }
}

// PICKUP SYSTEM
const pickups = [];

// Power-up state
let speedBoostTimer = 0;
let damageBoostTimer = 0;
const speedBoostMultiplier = 1.8;
const damageBoostMultiplier = 2;

// Pickup types configuration
const PICKUP_TYPES = {
    ammo: { color: 0xffaa00, glowColor: 0xffcc00, height: 0.4, label: 'AMMO' },
    health: { color: 0x00ff00, glowColor: 0x44ff44, height: 0.5, label: '+HEALTH' },
    speed: { color: 0x00ffff, glowColor: 0x44ffff, height: 0.5, label: 'SPEED!' },
    damage: { color: 0xff0000, glowColor: 0xff4444, height: 0.5, label: '2X DAMAGE!' },
    nuke: { color: 0xff00ff, glowColor: 0xff44ff, height: 0.6, label: 'NUKE!' }
};

function createPickupMesh(type) {
    const config = PICKUP_TYPES[type];
    const group = new THREE.Group();

    if (type === 'ammo') {
        // Ammo box
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.5, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.6 })
        );
        box.castShadow = true;
        group.add(box);

        // Bullets on top
        for (let i = 0; i < 3; i++) {
            const bullet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.25, 8),
                new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })
            );
            bullet.position.set(-0.2 + i * 0.2, 0.35, 0);
            bullet.rotation.x = Math.PI / 2;
            group.add(bullet);
        }
    } else if (type === 'health') {
        // Medical box with cross
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.5, 0.7),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
        );
        box.castShadow = true;
        group.add(box);

        // Red cross
        const crossH = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.1, 0.15),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossH.position.set(0, 0.26, 0);
        group.add(crossH);

        const crossV = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.1, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossV.position.set(0, 0.26, 0);
        group.add(crossV);
    } else if (type === 'speed') {
        // Lightning bolt shape
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.4);
        shape.lineTo(0.15, 0.1);
        shape.lineTo(0.05, 0.1);
        shape.lineTo(0.15, -0.4);
        shape.lineTo(-0.05, 0);
        shape.lineTo(0.05, 0);
        shape.lineTo(-0.1, 0.4);

        const extrudeSettings = { depth: 0.1, bevelEnabled: false };
        const boltGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const bolt = new THREE.Mesh(
            boltGeo,
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444, metalness: 0.5 })
        );
        bolt.rotation.y = Math.PI / 2;
        bolt.position.x = -0.05;
        group.add(bolt);
    } else if (type === 'damage') {
        // Skull shape (simplified)
        const skull = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 12, 10),
            new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0x440000 })
        );
        skull.scale.y = 1.2;
        group.add(skull);

        // Eye sockets
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        leftEye.position.set(-0.1, 0.05, 0.25);
        group.add(leftEye);

        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        rightEye.position.set(0.1, 0.05, 0.25);
        group.add(rightEye);
    } else if (type === 'nuke') {
        // Bomb/nuke shape
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 12),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 })
        );
        body.scale.y = 1.3;
        group.add(body);

        // Radiation symbol
        const symbolMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x440044 });
        const center = new THREE.Mesh(new THREE.CircleGeometry(0.08, 16), symbolMat);
        center.position.z = 0.36;
        group.add(center);

        // Fins
        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.3, 0.02),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 })
            );
            fin.position.set(0, -0.35, 0);
            fin.rotation.y = (i / 4) * Math.PI * 2;
            fin.position.x = Math.sin(fin.rotation.y) * 0.2;
            fin.position.z = Math.cos(fin.rotation.y) * 0.2;
            group.add(fin);
        }
    }

    return group;
}

class Pickup {
    constructor(type, x, z) {
        this.type = type;
        this.config = PICKUP_TYPES[type];
        this.mesh = createPickupMesh(type);
        this.mesh.position.set(x, -4.5 + this.config.height, z);
        scene.add(this.mesh);

        // Glow effect
        const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: this.config.glowColor,
            transparent: true,
            opacity: 0.15
        });
        this.glow = new THREE.Mesh(glowGeo, glowMat);
        this.mesh.add(this.glow);

        // Point light for visibility in the dark
        this.light = new THREE.PointLight(this.config.glowColor, 0.8, 8);
        this.light.position.set(0, 0.5, 0);
        this.mesh.add(this.light);

        this.bobOffset = Math.random() * Math.PI * 2;
        this.lifeTime = 30; // Despawn after 30 seconds
        this.collected = false;
    }

    update(dt, time) {
        if (this.collected) return true;

        // Bob and rotate
        this.mesh.position.y = -4.5 + this.config.height + Math.sin(time * 0.003 + this.bobOffset) * 0.15;
        this.mesh.rotation.y += dt * 2;

        // Pulse glow
        this.glow.material.opacity = 0.1 + Math.sin(time * 0.005) * 0.05;
        this.light.intensity = 0.6 + Math.sin(time * 0.005) * 0.3;

        // Check pickup collision with player
        const dx = camera.position.x - this.mesh.position.x;
        const dz = camera.position.z - this.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 2.5) {
            this.collect();
            return true;
        }

        // Lifetime
        this.lifeTime -= dt;
        if (this.lifeTime <= 0) {
            this.remove();
            return true;
        }

        // Flicker when about to despawn
        if (this.lifeTime < 5) {
            this.mesh.visible = Math.sin(time * 0.02) > 0;
        }

        return false;
    }

    collect() {
        this.collected = true;
        playSound('pickup');

        // Show floating text
        showPickupText(this.config.label, this.config.color);

        // Apply effect based on type
        switch (this.type) {
            case 'ammo':
                reserve = Math.min(reserve + 60, 300);
                addScore(50);
                break;

            case 'health':
                playerHealth = Math.min(playerHealth + 50, maxPlayerHealth);
                addScore(50);
                break;

            case 'speed':
                speedBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'damage':
                damageBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'nuke':
                // Kill all zombies!
                for (const zombie of zombies) {
                    if (!zombie.isDead) {
                        zombie.die();
                    }
                }
                addScore(500);
                playSound('nuke');
                // Screen flash
                damageFlashIntensity = 1.0;
                document.getElementById('damage-flash').style.background =
                    'radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,0,255,0.4) 100%)';
                setTimeout(() => {
                    document.getElementById('damage-flash').style.background =
                        'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
                }, 300);
                break;
        }

        updateHUD();
        this.remove();
    }

    remove() {
        scene.remove(this.mesh);
    }
}

function spawnPickup(type, x, z) {
    // Clamp to arena
    x = Math.max(-170, Math.min(170, x));
    z = Math.max(-170, Math.min(170, z));
    pickups.push(new Pickup(type, x, z));
}

function updatePickups(dt, time) {
    // Update existing pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
        if (pickups[i].update(dt, time)) {
            pickups.splice(i, 1);
        }
    }

    // Pickups disabled for now
    // if (waveInProgress && Math.random() < 0.001) {
    //     const types = ['ammo', 'ammo', 'health', 'speed', 'damage'];
    //     const type = types[Math.floor(Math.random() * types.length)];
    //     const angle = Math.random() * Math.PI * 2;
    //     const dist = 20 + Math.random() * 40;
    //     spawnPickup(type, camera.position.x + Math.cos(angle) * dist, camera.position.z + Math.sin(angle) * dist);
    // }
}

// Floating pickup text
let pickupTextTimeout = null;
function showPickupText(text, color) {
    let textEl = document.getElementById('pickup-text');
    if (!textEl) {
        textEl = document.createElement('div');
        textEl.id = 'pickup-text';
        textEl.style.cssText = `
            position: absolute; top: 40%; left: 50%; transform: translateX(-50%);
            font-size: 32px; font-weight: bold; pointer-events: none;
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
            transition: opacity 0.3s, top 0.5s;
        `;
        document.body.appendChild(textEl);
    }

    textEl.textContent = text;
    textEl.style.color = '#' + color.toString(16).padStart(6, '0');
    textEl.style.opacity = '1';
    textEl.style.top = '40%';

    if (pickupTextTimeout) clearTimeout(pickupTextTimeout);
    pickupTextTimeout = setTimeout(() => {
        textEl.style.opacity = '0';
        textEl.style.top = '35%';
    }, 1000);
}

// BLOOD & GORE SYSTEM
const bloodParticles = [];
const goreChunks = [];
const bloodDecals = [];
const bloodPools = [];

// Blood splatter texture (procedural)
const bloodTexCanvas = document.createElement('canvas');
bloodTexCanvas.width = 64; bloodTexCanvas.height = 64;
const bloodCtx = bloodTexCanvas.getContext('2d');
const bloodGrad = bloodCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
bloodGrad.addColorStop(0, 'rgba(180, 0, 0, 1)');
bloodGrad.addColorStop(0.3, 'rgba(120, 0, 0, 0.8)');
bloodGrad.addColorStop(0.7, 'rgba(80, 0, 0, 0.4)');
bloodGrad.addColorStop(1, 'rgba(40, 0, 0, 0)');
bloodCtx.fillStyle = bloodGrad;
bloodCtx.fillRect(0, 0, 64, 64);
const bloodSpriteTex = new THREE.CanvasTexture(bloodTexCanvas);

// Blood mist texture
const mistTexCanvas = document.createElement('canvas');
mistTexCanvas.width = 128; mistTexCanvas.height = 128;
const mistCtx = mistTexCanvas.getContext('2d');
const mistGrad = mistCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
mistGrad.addColorStop(0, 'rgba(150, 0, 0, 0.6)');
mistGrad.addColorStop(0.5, 'rgba(100, 0, 0, 0.3)');
mistGrad.addColorStop(1, 'rgba(60, 0, 0, 0)');
mistCtx.fillStyle = mistGrad;
mistCtx.fillRect(0, 0, 128, 128);
const bloodMistTex = new THREE.CanvasTexture(mistTexCanvas);

// Blood decal texture (splatter pattern)
const bloodDecalCanvas = document.createElement('canvas');
bloodDecalCanvas.width = 256; bloodDecalCanvas.height = 256;
const decalCtx = bloodDecalCanvas.getContext('2d');
decalCtx.fillStyle = 'rgba(0,0,0,0)';
decalCtx.fillRect(0, 0, 256, 256);
// Main splat
decalCtx.beginPath();
decalCtx.arc(128, 128, 60 + Math.random() * 20, 0, Math.PI * 2);
decalCtx.fillStyle = 'rgba(100, 0, 0, 0.9)';
decalCtx.fill();
// Splatter droplets
for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 40 + Math.random() * 80;
    const x = 128 + Math.cos(angle) * dist;
    const y = 128 + Math.sin(angle) * dist;
    const r = 3 + Math.random() * 12;
    decalCtx.beginPath();
    decalCtx.arc(x, y, r, 0, Math.PI * 2);
    decalCtx.fillStyle = `rgba(${80 + Math.random() * 40}, 0, 0, ${0.6 + Math.random() * 0.4})`;
    decalCtx.fill();
}
// Streaks
for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    decalCtx.beginPath();
    decalCtx.moveTo(128, 128);
    const len = 50 + Math.random() * 70;
    decalCtx.lineTo(128 + Math.cos(angle) * len, 128 + Math.sin(angle) * len);
    decalCtx.strokeStyle = `rgba(90, 0, 0, ${0.5 + Math.random() * 0.3})`;
    decalCtx.lineWidth = 2 + Math.random() * 4;
    decalCtx.stroke();
}
const bloodDecalTex = new THREE.CanvasTexture(bloodDecalCanvas);

// Gore materials
const goreMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.6 });
const boneMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.4 });
const organMat = new THREE.MeshStandardMaterial({ color: 0x4a0000, roughness: 0.7 });

// Pre-create blood sprite materials (avoid runtime allocation)
const bloodSpriteMats = [];
for (let i = 0; i < 40; i++) {
    bloodSpriteMats.push(new THREE.SpriteMaterial({
        map: bloodSpriteTex,
        color: new THREE.Color(0.5 + Math.random() * 0.3, 0, 0),
        transparent: true,
        opacity: 0.8,
        depthWrite: false
    }));
}
let bloodMatIdx = 0;

// Blood sprite pool
const bloodSpritePool = new ObjectPool(
    () => { const s = new THREE.Sprite(bloodSpriteMats[0]); s.visible = false; return s; },
    (s) => { s.visible = false; },
    MAX_BLOOD_PARTICLES
);

// Reusable vector for blood spray
const _bloodVel = new THREE.Vector3();

// Blood spray on hit - VIOLENT
function spawnBloodSpray(position, direction, intensity = 1) {
    const count = Math.floor(10 * intensity); // More blood

    // Blood droplets
    for (let i = 0; i < count; i++) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.1 + Math.random() * 0.15);
        sprite.visible = true;

        // VIOLENT blood spray velocity
        _bloodVel.copy(direction).multiplyScalar(6 + Math.random() * 10);
        _bloodVel.x += (Math.random() - 0.5) * 8;
        _bloodVel.y += Math.random() * 6;
        _bloodVel.z += (Math.random() - 0.5) * 8;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: _bloodVel.clone(),
            life: 1.0 + Math.random() * 0.5,
            gravity: 15,
            type: 'droplet'
        });
    }

    // Light blood mist (only on major hits, reuse material)
    if (intensity > 1.5) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.5);
        sprite.visible = true;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: direction.clone().multiplyScalar(2),
            life: 0.4,
            gravity: 0,
            type: 'mist',
            initialScale: 0.5
        });
    }
}

// Spawn gore chunks on death - VIOLENT
function spawnGoreChunks(position, direction) {
    const chunkCount = 6 + Math.floor(Math.random() * 4); // More chunks

    for (let i = 0; i < chunkCount; i++) {
        let geo, mat;
        const type = Math.random();

        if (type < 0.6) {
            // Small meat chunk
            geo = new THREE.DodecahedronGeometry(0.08 + Math.random() * 0.08);
            mat = goreMat.clone();
        } else {
            // Bone fragment
            geo = new THREE.BoxGeometry(0.04, 0.12, 0.04);
            mat = boneMat.clone();
        }

        const chunk = new THREE.Mesh(geo, mat);
        chunk.position.copy(position);
        chunk.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        chunk.castShadow = true;

        // VIOLENT - explosive chunk velocity
        const vel = direction.clone().multiplyScalar(8 + Math.random() * 10);
        vel.add(new THREE.Vector3(
            (Math.random() - 0.5) * 12,
            Math.random() * 8 + 4,
            (Math.random() - 0.5) * 12
        ));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 6 + Math.random() * 3,
            grounded: false,
            canBleed: Math.random() > 0.7,
            bleedTimer: 0
        });
    }
}

// HEAD EXPLOSION - Satisfying headshot effect
// Brain/skull material for headshot gore
const brainMat = new THREE.MeshStandardMaterial({ color: 0xcc6677, roughness: 0.8 });
const skullMat = new THREE.MeshStandardMaterial({ color: 0xddccbb, roughness: 0.5 });

function explodeHead(zombie, hitPoint, direction) {
    // Get the head mesh (first child of zombie mesh)
    const head = zombie.mesh.children[0];
    if (!head) return;

    // Get head world position before hiding
    const headWorldPos = new THREE.Vector3();
    head.getWorldPosition(headWorldPos);

    // Hide the head
    head.visible = false;
    zombie.headExploded = true;

    // Play headshot sound
    playSound('headshot');

    // MASSIVE blood spray in all directions
    for (let i = 0; i < 5; i++) {
        const sprayDir = new THREE.Vector3(
            (Math.random() - 0.5) * 2,
            Math.random() * 0.5 + 0.5,
            (Math.random() - 0.5) * 2
        ).normalize();
        spawnBloodSpray(headWorldPos.clone(), sprayDir, 3);
    }

    // Spawn skull fragments
    const skullFragCount = 6 + Math.floor(Math.random() * 4);
    for (let i = 0; i < skullFragCount; i++) {
        const size = 0.08 + Math.random() * 0.12;
        const geo = new THREE.TetrahedronGeometry(size);
        const chunk = new THREE.Mesh(geo, skullMat.clone());
        chunk.position.copy(headWorldPos);
        chunk.castShadow = true;

        // Explosive outward velocity
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            Math.random() * 15 + 5,
            (Math.random() - 0.5) * 20
        );
        // Add direction bias from bullet
        vel.add(direction.clone().multiplyScalar(10));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 40,
            (Math.random() - 0.5) * 40
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 5 + Math.random() * 3,
            grounded: false,
            canBleed: true,
            bleedTimer: 0,
            isSkull: true
        });
    }

    // Spawn brain chunks (pink/red squishy bits)
    const brainChunkCount = 8 + Math.floor(Math.random() * 5);
    for (let i = 0; i < brainChunkCount; i++) {
        const size = 0.06 + Math.random() * 0.1;
        const geo = new THREE.SphereGeometry(size, 6, 4);
        // Deform slightly for organic look
        const positions = geo.attributes.position;
        for (let j = 0; j < positions.count; j++) {
            positions.setXYZ(j,
                positions.getX(j) * (0.8 + Math.random() * 0.4),
                positions.getY(j) * (0.8 + Math.random() * 0.4),
                positions.getZ(j) * (0.8 + Math.random() * 0.4)
            );
        }

        const chunk = new THREE.Mesh(geo, brainMat.clone());
        chunk.position.copy(headWorldPos);
        chunk.castShadow = true;

        // Slower, goopier velocity for brain matter
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 15,
            Math.random() * 10 + 3,
            (Math.random() - 0.5) * 15
        );
        vel.add(direction.clone().multiplyScalar(8));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20,
            (Math.random() - 0.5) * 20
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 4 + Math.random() * 2,
            grounded: false,
            canBleed: true,
            bleedTimer: 0,
            isBrain: true
        });
    }

    // Create a blood mist cloud at head position
    for (let i = 0; i < 3; i++) {
        const mistSprite = bloodSpritePool.get();
        mistSprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        mistSprite.position.copy(headWorldPos);
        mistSprite.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        mistSprite.scale.setScalar(1.0 + Math.random() * 0.5);
        mistSprite.visible = true;

        scene.add(mistSprite);
        bloodParticles.push({
            mesh: mistSprite,
            velocity: new THREE.Vector3(
                (Math.random() - 0.5) * 2,
                Math.random() * 2,
                (Math.random() - 0.5) * 2
            ),
            life: 0.6,
            gravity: 0,
            type: 'mist',
            initialScale: mistSprite.scale.x
        });
    }
}

// Spawn blood decal on ANY surface (floor or obstacles)
function spawnBloodDecal(position, normal, size = 1) {
    const decalMat = new THREE.MeshBasicMaterial({
        map: bloodDecalTex,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -2,
        side: THREE.DoubleSide
    });

    const decalSize = (1.5 + Math.random() * 1.5) * size;
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(decalSize, decalSize), decalMat);
    decal.position.copy(position);

    // If normal is provided and not pointing up, orient to surface
    if (normal && Math.abs(normal.y) < 0.9) {
        // Vertical or angled surface (obstacle)
        decal.position.addScaledVector(normal, 0.02); // Offset slightly from surface
        decal.lookAt(position.clone().add(normal));
        decal.rotation.z = Math.random() * Math.PI * 2;
    } else {
        // Floor (horizontal surface)
        decal.position.y = -4.95; // Just above floor
        decal.rotation.x = -Math.PI / 2;
        decal.rotation.z = Math.random() * Math.PI * 2;
    }

    scene.add(decal);
    bloodDecals.push({
        mesh: decal,
        life: 10.0 + Math.random() * 5.0
    });
}

// Raycaster for blood collision with obstacles
const bloodRaycaster = new THREE.Raycaster();
const _bloodRayDir = new THREE.Vector3();

// Check if blood particle hits an obstacle and spawn decal
function checkBloodObstacleCollision(particle) {
    if (!particle.velocity || particle.type !== 'droplet') return false;

    // Cast ray in direction of movement
    _bloodRayDir.copy(particle.velocity).normalize();
    bloodRaycaster.set(particle.mesh.position, _bloodRayDir);
    bloodRaycaster.far = particle.velocity.length() * 0.1; // Check short distance

    const hits = bloodRaycaster.intersectObjects(obstacles);
    if (hits.length > 0) {
        const hit = hits[0];
        // Spawn blood splat on obstacle surface
        spawnBloodDecal(hit.point, hit.face.normal, 0.4 + Math.random() * 0.3);
        return true;
    }
    return false;
}

// Spawn expanding blood pool under body
function spawnBloodPool(position) {
    const poolMat = new THREE.MeshBasicMaterial({
        color: 0x3a0000,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1
    });

    const pool = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), poolMat);
    pool.position.copy(position);
    pool.position.y = -4.98;
    pool.rotation.x = -Math.PI / 2;

    scene.add(pool);
    bloodPools.push({
        mesh: pool,
        targetSize: 2.0 + Math.random() * 1.5, // Bigger pools
        currentSize: 0.1,
        growthRate: 1.0 + Math.random() * 0.5, // Faster growth
        life: 8.0 + Math.random() * 5.0 // Fixed: 8-13 seconds instead of 500-800 frames
    });
}

// Reusable normal vector for decals
const _upNormal = new THREE.Vector3(0, 1, 0);

// Update blood particle systems (optimized with swap-and-pop)
function updateBloodEffects(dt) {
    // Update blood particles
    for (let i = bloodParticles.length - 1; i >= 0; i--) {
        const p = bloodParticles[i];
        p.life -= dt;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodSpritePool.release(p.mesh);
            bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
            bloodParticles.pop();
            continue;
        }

        if (p.type === 'droplet') {
            p.velocity.y -= p.gravity * dt;
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.mesh.material.opacity = Math.min(1, p.life);

            // Check for obstacle collision (blood sticks to walls/crates)
            if (checkBloodObstacleCollision(p)) {
                scene.remove(p.mesh);
                bloodSpritePool.release(p.mesh);
                bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
                bloodParticles.pop();
                continue;
            }

            // Hit ground
            if (p.mesh.position.y < -4.8) {
                if (Math.random() > 0.7) { // Increased decal spawns
                    spawnBloodDecal(p.mesh.position.clone(), _upNormal, 0.3);
                }
                scene.remove(p.mesh);
                bloodSpritePool.release(p.mesh);
                bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
                bloodParticles.pop();
            }
        } else if (p.type === 'mist') {
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.velocity.multiplyScalar(0.95);
            p.mesh.scale.setScalar(p.initialScale * (1 + (1 - p.life) * 3));
            p.mesh.material.opacity = p.life * 0.5;
        }
    }

    // Update gore chunks
    for (let i = goreChunks.length - 1; i >= 0; i--) {
        const g = goreChunks[i];
        g.life -= dt;

        if (g.life <= 0) {
            scene.remove(g.mesh);
            goreChunks[i] = goreChunks[goreChunks.length - 1];
            goreChunks.pop();
            continue;
        }

        if (!g.grounded) {
            g.velocity.y -= 20 * dt;
            g.mesh.position.addScaledVector(g.velocity, dt);
            g.mesh.rotation.x += g.rotVelocity.x * dt;
            g.mesh.rotation.y += g.rotVelocity.y * dt;
            g.mesh.rotation.z += g.rotVelocity.z * dt;

            // Check for obstacle collision (gore sticks to walls/crates)
            _bloodRayDir.copy(g.velocity).normalize();
            bloodRaycaster.set(g.mesh.position, _bloodRayDir);
            bloodRaycaster.far = g.velocity.length() * dt * 2;
            const goreHits = bloodRaycaster.intersectObjects(obstacles);
            if (goreHits.length > 0 && g.canBleed) {
                const hit = goreHits[0];
                // Splatter blood on obstacle
                spawnBloodDecal(hit.point, hit.face.normal, 0.5 + Math.random() * 0.3);
                // Bounce off
                g.velocity.reflect(hit.face.normal).multiplyScalar(0.3);
                g.rotVelocity.multiplyScalar(0.5);
            }

            if (g.mesh.position.y < -4.7) {
                g.mesh.position.y = -4.7;
                if (Math.abs(g.velocity.y) > 2) {
                    g.velocity.y *= -0.3;
                    g.velocity.x *= 0.7;
                    g.velocity.z *= 0.7;
                    g.rotVelocity.multiplyScalar(0.5);
                    if (Math.random() > 0.4) { // More decal spawns
                        spawnBloodDecal(g.mesh.position.clone(), _upNormal, 0.5);
                    }
                } else {
                    g.grounded = true;
                    g.velocity.set(0, 0, 0);
                }
            }
        }

        // Bleeding effect (disabled for performance)
        // if (g.canBleed && !g.grounded) { ... }

        if (g.life < 2) {
            g.mesh.material.opacity = g.life / 2;
            g.mesh.material.transparent = true;
        }
    }

    // Update blood pools
    for (let i = bloodPools.length - 1; i >= 0; i--) {
        const p = bloodPools[i];
        p.life -= dt; // Fixed: time-based instead of frame-based

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodPools[i] = bloodPools[bloodPools.length - 1];
            bloodPools.pop();
            continue;
        }

        if (p.currentSize < p.targetSize) {
            p.currentSize += p.growthRate * dt;
            p.mesh.scale.setScalar(p.currentSize);
        }

        if (p.life < 1.5) {
            p.mesh.material.opacity = (p.life / 1.5) * 0.9; // Fixed: fade over last 1.5 seconds
        }
    }

    // Update blood decals
    for (let i = bloodDecals.length - 1; i >= 0; i--) {
        const d = bloodDecals[i];
        d.life -= dt; // Fixed: time-based instead of frame-based

        if (d.life <= 0) {
            scene.remove(d.mesh);
            bloodDecals[i] = bloodDecals[bloodDecals.length - 1];
            bloodDecals.pop();
            continue;
        }

        if (d.life < 1.5) {
            d.mesh.material.opacity = (d.life / 1.5) * 0.85; // Fixed: fade over last 1.5 seconds
        }
    }
}

// ATMOSPHERIC DUST PARTICLES (reduced for performance)
const dustParticles = [];
const dustGeo = new THREE.BufferGeometry();
const dustCount = 100; // Further reduced for performance
const dustPositions = new Float32Array(dustCount * 3);
for(let i = 0; i < dustCount; i++) {
    dustPositions[i * 3] = (Math.random() - 0.5) * 200;
    dustPositions[i * 3 + 1] = Math.random() * 30 - 5;
    dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
const dustMat = new THREE.PointsMaterial({
    color: 0xeebb88, // Warm dust
    size: 0.08, // Smaller particles
    transparent: true,
    opacity: 0.2, // Less opaque
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
});
const dustCloud = new THREE.Points(dustGeo, dustMat);
scene.add(dustCloud);

/**
 * GUN CONSTRUCTION
 */
const gunGroup = new THREE.Group();
const recoilGroup = new THREE.Group();
recoilGroup.add(gunGroup);

// Enhanced gun materials with environment reflections
const woodMat = new THREE.MeshStandardMaterial({
    map: woodTex,
    roughness: 0.45,
    metalness: 0.05,
    bumpMap: woodTex,
    bumpScale: 0.03,
    envMap: envMapTex,
    envMapIntensity: 0.15
});

const metalMat = new THREE.MeshStandardMaterial({
    map: metalTexLight,
    color: 0xdddddd,
    roughness: 0.25,
    metalness: 0.95,
    bumpMap: metalTexLight,
    bumpScale: 0.008,
    envMap: envMapTex,
    envMapIntensity: 0.6
});

const darkMetalMat = new THREE.MeshStandardMaterial({
    map: metalTexDark,
    color: 0x1a1a1a,
    roughness: 0.5,
    metalness: 0.7,
    bumpMap: metalTexDark,
    bumpScale: 0.01,
    envMap: envMapTex,
    envMapIntensity: 0.3
});

const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 4), darkMetalMat);
receiver.castShadow = true; gunGroup.add(receiver);

const dustCover = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4, 16, 1, false, 0, Math.PI), darkMetalMat);
dustCover.rotation.set(Math.PI/2, Math.PI/2, 0); dustCover.position.y = 0.5; dustCover.castShadow = true; gunGroup.add(dustCover);

const stock = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 3), woodMat);
stock.position.set(0, -0.5, 3.5); stock.rotation.x = 0.2; stock.castShadow = true; gunGroup.add(stock);

const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 6, 12), metalMat);
barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.3, -4); barrel.castShadow = true; gunGroup.add(barrel);

const gasTube = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 3, 12), metalMat);
gasTube.rotation.x = Math.PI / 2; gasTube.position.set(0, 0.7, -3); gunGroup.add(gasTube);

const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 2.5), woodMat);
handguard.position.set(0, 0.2, -3); handguard.castShadow = true; gunGroup.add(handguard);

const grip = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.5, 0.8), woodMat);
grip.position.set(0, -1, 0.5); grip.rotation.x = -0.3; grip.castShadow = true; gunGroup.add(grip);

// Sights
const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.2), darkMetalMat);
frontSight.position.set(0, 0.8, -6.5); frontSight.castShadow = true; gunGroup.add(frontSight);

const rearSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), darkMetalMat);
rearSightBase.position.set(0, 0.9, -1.0); gunGroup.add(rearSightBase);
const rearSightL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightL.position.set(-0.15, 1.1, -1.0); gunGroup.add(rearSightL);
const rearSightR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightR.position.set(0.15, 1.1, -1.0); gunGroup.add(rearSightR);

const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.6), metalMat);
bolt.position.set(0.5, 0.4, -0.5); bolt.castShadow = true; gunGroup.add(bolt);

// Magazine Pivot Group (For cooler reloading arcs)
const magPivot = new THREE.Group();
magPivot.position.set(0, -0.5, -1);
gunGroup.add(magPivot);

const magGeo = new THREE.BoxGeometry(0.6, 2.5, 1.2);
const magCurve = new THREE.Mesh(magGeo, metalMat);
magCurve.rotation.x = 0.4; magCurve.position.y = -1.2; magCurve.castShadow = true;
magPivot.add(magCurve);

// ENHANCED MUZZLE FLASH VFX
const flashGroup = new THREE.Group();

// Core flash (bright white center)
const flashCoreMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
const flashCore = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), flashCoreMat);
flashGroup.add(flashCore);

// Mid flash (orange/yellow)
const flashMidMat = new THREE.MeshBasicMaterial({
    color: 0xffaa44, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    flashGroup.add(f);
}

// Outer flash (red/orange glow)
const flashOuterMat = new THREE.MeshBasicMaterial({
    color: 0xff6622, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<6; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), flashOuterMat);
    f.rotation.z = (Math.PI / 3) * i;
    flashGroup.add(f);
}

// Flash streaks (elongated for directional feel)
const flashStreakMat = new THREE.MeshBasicMaterial({
    color: 0xffcc66, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<3; i++) {
    const streak = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 3.0), flashStreakMat);
    streak.rotation.z = (Math.PI / 3) * i + Math.PI/6;
    streak.position.z = -0.5;
    flashGroup.add(streak);
}

flashGroup.position.set(0, 0.3, -7.2);
gunGroup.add(flashGroup);

// Legacy reference for compatibility
const flashMat = flashMidMat;

// Camera Rig
const hipPos = new THREE.Vector3(0.9, -1.1, -1.8);
const aimPos = new THREE.Vector3(0.0, -1.22, -0.5);
recoilGroup.position.copy(hipPos);
recoilGroup.rotation.y = Math.PI; 
camera.add(recoilGroup);
scene.add(camera);

/**
 * ENHANCED PARTICLE SYSTEMS
 */

// Improved Smoke with object pooling
const smokeParticles = [];
const smokeTexCanvas = document.createElement('canvas'); smokeTexCanvas.width = 64; smokeTexCanvas.height = 64; // Reduced size
const stx = smokeTexCanvas.getContext('2d');
const sGrad = stx.createRadialGradient(32,32,0,32,32,32);
sGrad.addColorStop(0, 'rgba(200,200,200,0.6)');
sGrad.addColorStop(0.4, 'rgba(150,150,150,0.3)');
sGrad.addColorStop(1, 'rgba(100,100,100,0)');
stx.fillStyle = sGrad; stx.fillRect(0,0,64,64);
const smokeSpriteTex = new THREE.CanvasTexture(smokeTexCanvas);

// Pre-create smoke sprite materials (no cloning needed)
const smokeMats = [];
const hotSmokeMats = [];
for (let i = 0; i < 20; i++) {
    smokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0x888888, transparent: true,
        blending: THREE.NormalBlending, depthWrite: false
    }));
    hotSmokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0xffaa66, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
    }));
}
let smokeMatIdx = 0;
let hotSmokeMatIdx = 0;

// Object pool for smoke sprites
const smokePool = new ObjectPool(
    () => new THREE.Sprite(smokeMats[0]),
    (s) => { s.visible = false; s.scale.setScalar(0.4); }
);

// Reusable vectors for smoke spawning
const _smokeSpawnPos = new THREE.Vector3(0, 0.3, -7.5);
const _smokeVel = new THREE.Vector3();
const _smokeQuat = new THREE.Quaternion();

function spawnSmoke() {
    const basePos = _smokeSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    gunGroup.getWorldQuaternion(_smokeQuat);

    // Hot smoke near muzzle (reduced count)
    for(let i=0; i<1; i++) {
        const s = smokePool.get();
        s.material = hotSmokeMats[hotSmokeMatIdx++ % hotSmokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.3 + Math.random() * 0.3);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.5; _smokeVel.y += Math.random()*0.3; _smokeVel.z += (Math.random()-0.5)*0.5;
        _smokeVel.multiplyScalar(3 + Math.random()*2);
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 0.4 + Math.random()*0.3, hot: true });
    }
    // Regular smoke (reduced count)
    for(let i=0; i<2; i++) {
        const s = smokePool.get();
        s.material = smokeMats[smokeMatIdx++ % smokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.4 + Math.random() * 0.4);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.4; _smokeVel.y += Math.random()*0.6; _smokeVel.z += (Math.random()-0.5)*0.4;
        _smokeVel.multiplyScalar(1.5 + Math.random());
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 1.0 + Math.random()*0.5, hot: false });
    }
}

// === NEW: Muzzle Smoke Wisps - lingering smoke after firing ===
const muzzleSmokeWisps = [];
const wispMats = [];
for (let i = 0; i < 10; i++) {
    wispMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex,
        color: 0x888899,
        transparent: true,
        blending: THREE.NormalBlending,
        opacity: 0.3,
        depthWrite: false
    }));
}
let wispMatIdx = 0;

function spawnMuzzleSmokeWisps() {
    // Only spawn wisps occasionally for subtle effect
    if (Math.random() > 0.4) return;

    const basePos = _smokeSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    gunGroup.getWorldQuaternion(_smokeQuat);

    // Spawn 1-2 slow-moving wisps that rise gently
    const wispCount = 1 + Math.floor(Math.random() * 2);
    for (let i = 0; i < wispCount; i++) {
        const s = new THREE.Sprite(wispMats[wispMatIdx++ % wispMats.length].clone());
        s.position.copy(basePos);
        s.position.x += (Math.random() - 0.5) * 0.2;
        s.position.y += (Math.random() - 0.5) * 0.1;
        s.scale.setScalar(0.15 + Math.random() * 0.1);
        scene.add(s);

        // Very slow upward drift with slight random motion
        const vel = new THREE.Vector3(
            (Math.random() - 0.5) * 0.2,
            0.3 + Math.random() * 0.2,
            (Math.random() - 0.5) * 0.2
        );

        muzzleSmokeWisps.push({
            mesh: s,
            velocity: vel,
            age: 0,
            life: 2.0 + Math.random() * 1.5, // Long-lasting
            initialScale: s.scale.x
        });
    }
}

// Update smoke wisps (called in main loop)
function updateMuzzleSmokeWisps(dt) {
    for (let i = muzzleSmokeWisps.length - 1; i >= 0; i--) {
        const w = muzzleSmokeWisps[i];
        w.age += dt;

        if (w.age >= w.life) {
            scene.remove(w.mesh);
            w.mesh.material.dispose();
            muzzleSmokeWisps.splice(i, 1);
            continue;
        }

        // Move upward slowly
        w.mesh.position.add(w.velocity.clone().multiplyScalar(dt));

        // Add slight turbulence
        w.mesh.position.x += Math.sin(w.age * 3 + i) * 0.01 * dt;
        w.mesh.position.z += Math.cos(w.age * 2.5 + i * 2) * 0.01 * dt;

        // Grow and fade
        const lifeRatio = w.age / w.life;
        const growthFactor = 1 + lifeRatio * 3; // Grow to 4x size
        w.mesh.scale.setScalar(w.initialScale * growthFactor);

        // Fade out smoothly
        const fadeStart = 0.3;
        if (lifeRatio > fadeStart) {
            const fadeRatio = (lifeRatio - fadeStart) / (1 - fadeStart);
            w.mesh.material.opacity = 0.3 * (1 - fadeRatio);
        }

        // Slow down over time
        w.velocity.multiplyScalar(0.995);
    }
}

// SPARK PARTICLES - pooled for performance
const sparks = [];
const sparkGeo = new THREE.SphereGeometry(0.02, 3, 3); // Reduced geometry complexity
const sparkBaseMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending });

// Pre-create spark materials
const sparkMats = [];
for (let i = 0; i < 30; i++) {
    sparkMats.push(new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending }));
}
let sparkMatIdx = 0;

// Object pool for sparks
const sparkPool = new ObjectPool(
    () => { const m = new THREE.Mesh(sparkGeo, sparkMats[0]); m.visible = false; return m; },
    (s) => { s.visible = false; },
    MAX_SPARKS
);

const _sparkSpawnPos = new THREE.Vector3(0, 0.3, -7.5);

function spawnMuzzleSparks() {
    const basePos = _sparkSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    for(let i=0; i<5; i++) { // Reduced from 8
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(basePos);
        spark.visible = true;
        _tempVec3.set((Math.random()-0.5) * 8, Math.random() * 4, -Math.random() * 15);
        _tempVec3.applyQuaternion(camera.quaternion);
        spark.userData = { velocity: _tempVec3.clone(), life: 0.15 + Math.random()*0.2 };
        scene.add(spark);
        sparks.push(spark);
    }
}

function spawnImpactSparks(point, normal) {
    for(let i=0; i<3; i++) { // Further reduced for performance
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(point);
        spark.visible = true;
        _tempVec3.copy(normal).multiplyScalar(5 + Math.random()*10);
        _tempVec3.x += (Math.random()-0.5) * 8;
        _tempVec3.y += Math.random() * 5;
        _tempVec3.z += (Math.random()-0.5) * 8;
        spark.userData = { velocity: _tempVec3.clone(), life: 0.2 + Math.random()*0.3 };
        scene.add(spark);
        sparks.push(spark);
    }
}

// DEBRIS PARTICLES - pooled
const debris = [];
const debrisGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
const debrisMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });

const debrisPool = new ObjectPool(
    () => { const d = new THREE.Mesh(debrisGeo, debrisMat); d.visible = false; return d; },
    (d) => { d.visible = false; },
    MAX_DEBRIS
);

function spawnDebris(point, normal) {
    for(let i=0; i<1; i++) { // Further reduced for performance
        const d = debrisPool.get();
        d.position.copy(point);
        d.visible = true;
        _tempVec3.copy(normal).multiplyScalar(2 + Math.random()*4);
        _tempVec3.x += (Math.random()-0.5) * 4;
        _tempVec3.y += Math.random() * 3;
        _tempVec3.z += (Math.random()-0.5) * 4;
        d.userData = {
            velocity: _tempVec3.clone(),
            rotVel: new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10),
            life: 1.0 + Math.random() * 1.0 // Fixed: 1-2 seconds instead of 60-120 frames
        };
        scene.add(d);
        debris.push(d);
    }
}

const shells = [];
const mags = [];
const tracers = [];
const decals = [];
const decalTex = TextureFactory.impact();
const decalMat = new THREE.MeshBasicMaterial({ map: decalTex, transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
const shellGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
const shellMat = new THREE.MeshStandardMaterial({
    color: 0xd4af37,
    metalness: 1.0,
    roughness: 0.15,
    envMap: envMapTex,
    envMapIntensity: 0.8
});

const raycaster = new THREE.Raycaster();

function ejectShell() {
    const shell = new THREE.Mesh(shellGeo, shellMat);
    shell.position.copy(new THREE.Vector3(0.5, 0.4, 0).applyMatrix4(gunGroup.matrixWorld));
    shell.quaternion.copy(gunGroup.quaternion); shell.rotation.z = Math.PI/2;
    const velocity = new THREE.Vector3(0.1 + Math.random()*0.1, 0.2 + Math.random()*0.1, 0).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 2.5 }; // Fixed: 2.5 seconds instead of 150 frames
    scene.add(shell); shells.push(shell);
}

function spawnTracer(start, end) {
    // Main tracer line
    const points = [start, end];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({
        color: 0xffff88,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    tracers.push({ mesh: line, life: 0.1 }); // Fixed: 0.1 seconds instead of 4 frames

    // Glow tracer (wider, softer)
    const glowMat = new THREE.LineBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
    });
    const glowLine = new THREE.Line(geo.clone(), glowMat);
    scene.add(glowLine);
    tracers.push({ mesh: glowLine, life: 0.08 }); // Fixed: 0.08 seconds instead of 3 frames
}

function spawnDecal(point, normal) {
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), decalMat);
    decal.position.copy(point);
    decal.position.addScaledVector(normal, 0.01);
    decal.lookAt(point.clone().add(normal));
    decal.rotation.z = Math.random() * Math.PI * 2;
    scene.add(decal);
    decals.push({ mesh: decal, life: 10.0 }); // Fixed: 10 seconds instead of 600 frames

    // Spawn impact effects
    spawnImpactSparks(point, normal);
    spawnDebris(point, normal);
}

/**
 * LOGIC & STATE
 */
let ammo = 30;
let reserve = 90;
let isReloading = false;
let isFiring = false;
let isAiming = false;
let lastShotTime = 0;
const fireRate = 0.1;

// PLAYER HEALTH & GAME STATE
let playerHealth = 100;
let maxPlayerHealth = 100;
let score = 0;
let isGameOver = false;
let lastDamageTime = 0;
let damageFlashIntensity = 0;

function damagePlayer(amount, attackerPos = null) {
    if (isGameOver) return;

    playerHealth -= amount;
    lastDamageTime = performance.now();
    damageFlashIntensity = 0.5;
    playSound('playerHurt');

    // Screen shake
    Springs.shakeX.impulse((Math.random() - 0.5) * 20);
    Springs.shakeY.impulse((Math.random() - 0.5) * 20);

    // === NEW: Damage Direction Indicator ===
    if (attackerPos) {
        // Calculate direction from player to attacker in camera space
        const toAttacker = new THREE.Vector3();
        toAttacker.subVectors(attackerPos, camera.position);
        toAttacker.y = 0; // Ignore vertical

        // Get camera forward direction (horizontal)
        const camForward = new THREE.Vector3(0, 0, -1);
        camForward.applyQuaternion(camera.quaternion);
        camForward.y = 0;
        camForward.normalize();

        // Get camera right direction
        const camRight = new THREE.Vector3(1, 0, 0);
        camRight.applyQuaternion(camera.quaternion);
        camRight.y = 0;
        camRight.normalize();

        // Dot products to determine relative position
        const forward = toAttacker.dot(camForward);
        const right = toAttacker.dot(camRight);

        // Determine which arrow to show based on angle
        const angle = Math.atan2(right, forward);
        const deg = (angle * 180 / Math.PI + 360) % 360;

        // Map angle to direction (0 = front, 90 = right, 180 = back, 270 = left)
        if (deg >= 337.5 || deg < 22.5) lastDamageDir = 'top';         // Front
        else if (deg >= 22.5 && deg < 67.5) lastDamageDir = 'top-right';
        else if (deg >= 67.5 && deg < 112.5) lastDamageDir = 'right';
        else if (deg >= 112.5 && deg < 157.5) lastDamageDir = 'bottom-right';
        else if (deg >= 157.5 && deg < 202.5) lastDamageDir = 'bottom'; // Back
        else if (deg >= 202.5 && deg < 247.5) lastDamageDir = 'bottom-left';
        else if (deg >= 247.5 && deg < 292.5) lastDamageDir = 'left';
        else lastDamageDir = 'top-left';

        damageIndicatorAlpha = 1.0; // Start fade
    }

    if (playerHealth <= 0) {
        playerHealth = 0;
        gameOver();
    }
    updateHUD();
}

function addScore(points) {
    score += points;
    updateHUD();

    // Micro-animation: score bump
    const scoreEl = document.getElementById('score-display');
    if (scoreEl) {
        scoreEl.classList.remove('score-bump');
        void scoreEl.offsetWidth; // Force reflow to restart animation
        scoreEl.classList.add('score-bump');
    }
}

function gameOver() {
    isGameOver = true;
    waveInProgress = false;
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('final-score').textContent = score;
    document.getElementById('final-wave').textContent = currentWave;
    document.exitPointerLock();
}

function restartGame() {
    // Reset all game state
    playerHealth = maxPlayerHealth;
    score = 0;
    ammo = 30;
    reserve = 90;
    currentWave = 0;
    zombiesThisWave = 0;
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = false;
    betweenWaves = true;
    nextWaveCountdown = 3;
    isGameOver = false;
    isReloading = false;

    // Clear all zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    // Clear all pickups
    for (const pickup of pickups) {
        pickup.remove();
    }
    pickups.length = 0;

    // Reset power-up timers
    speedBoostTimer = 0;
    damageBoostTimer = 0;

    // Reset player position
    camera.position.set(0, 0, 0);

    // Hide game over screen
    document.getElementById('game-over').style.display = 'none';

    // Re-lock pointer
    document.body.requestPointerLock();

    updateHUD();
}

const moveState = { f: false, b: false, l: false, r: false, sprint: false };
const velocity = new THREE.Vector3();
// Player speed is 1.15x average zombie speed (zombie avg = 7.75, so player = ~9)
const baseSpeed = 9.0;
const sprintMultiplier = 1.8;
let prevTime = performance.now();

// Jump physics
let verticalVelocity = 0;
let playerHeight = 0; // Height above current terrain
let currentGroundLevel = 0; // Dynamic ground level (updated each frame)
const gravity = 35;
const jumpForce = 12;
let isGrounded = true;
let canJump = true;

// Smooth landing spring
Springs.landing = new Spring(200, 15, 1);

// CAMERA STATE
let cameraPitch = 0;
let cameraYaw = 0;
let cameraRecoil = 0;
let currentFOV = 90;

const crosshair = document.getElementById('crosshair');
const hitmarker = document.getElementById('hitmarker');

let hitmarkerTimeout = null;
function showHitmarker(isHeadshot = false) {
    hitmarker.classList.add('show');
    if (isHeadshot) {
        hitmarker.classList.add('headshot');
    }
    if (hitmarkerTimeout) clearTimeout(hitmarkerTimeout);
    hitmarkerTimeout = setTimeout(() => {
        hitmarker.classList.remove('show');
        hitmarker.classList.remove('headshot');
    }, isHeadshot ? 200 : 100);
}

// Power-up display element (created once)
let powerupsEl = null;
function ensurePowerupsEl() {
    if (!powerupsEl) {
        powerupsEl = document.createElement('div');
        powerupsEl.id = 'powerups-display';
        powerupsEl.style.cssText = `
            position: absolute; bottom: 60px; left: 20px;
            display: flex; gap: 10px; pointer-events: none;
        `;
        document.body.appendChild(powerupsEl);
    }
    return powerupsEl;
}

function updateHUD(force = false) {
    const dom = getCachedDOM();
    const remaining = zombiesThisWave - zombiesKilledThisWave;
    const healthPercent = Math.ceil(playerHealth);

    // Only update if values changed (or forced)
    if (force || lastHUDValues.ammo !== ammo || lastHUDValues.reserve !== reserve || lastHUDValues.isReloading !== isReloading) {
        lastHUDValues.ammo = ammo;
        lastHUDValues.reserve = reserve;
        lastHUDValues.isReloading = isReloading;
        if (dom.ammoDisplay) {
            dom.ammoDisplay.innerText = `${isReloading ? 'RLD' : ammo} / `;

            // Micro-animation classes for ammo state
            dom.ammoDisplay.classList.remove('low-ammo', 'empty', 'reloading');
            if (isReloading) {
                dom.ammoDisplay.classList.add('reloading');
            } else if (ammo === 0) {
                dom.ammoDisplay.classList.add('empty');
            } else if (ammo <= 10) {
                dom.ammoDisplay.classList.add('low-ammo');
            }
        }
    }

    if (force || lastHUDValues.health !== healthPercent) {
        lastHUDValues.health = healthPercent;
        const pct = (playerHealth / maxPlayerHealth) * 100;

        if (dom.healthFill) {
            dom.healthFill.style.width = pct + '%';
            dom.healthFill.classList.remove('damaged', 'critical');
            if (pct <= 25) {
                dom.healthFill.classList.add('critical');
            } else if (pct <= 50) {
                dom.healthFill.classList.add('damaged');
            }
        }
        if (dom.healthText) {
            dom.healthText.textContent = healthPercent;
            dom.healthText.classList.toggle('critical', pct <= 25);
        }

        // Health bar border animation
        const healthBar = document.getElementById('health-bar');
        if (healthBar) {
            healthBar.classList.toggle('critical', pct <= 25);
        }
    }

    if (force || lastHUDValues.wave !== currentWave || lastHUDValues.remaining !== remaining) {
        const prevWave = lastHUDValues.wave;
        const prevRemaining = lastHUDValues.remaining;
        lastHUDValues.wave = currentWave;
        lastHUDValues.remaining = remaining;

        if (dom.waveDisplay) {
            if (betweenWaves && currentWave > 0) {
                dom.waveDisplay.textContent = `WAVE ${currentWave} COMPLETE`;
            } else if (betweenWaves) {
                dom.waveDisplay.textContent = `GET READY...`;
            } else {
                dom.waveDisplay.textContent = `WAVE ${currentWave}`;
            }

            // New wave animation
            if (currentWave !== prevWave && currentWave > 0) {
                dom.waveDisplay.classList.remove('new-wave');
                void dom.waveDisplay.offsetWidth;
                dom.waveDisplay.classList.add('new-wave');
            }
        }
        if (dom.zombieCount) {
            dom.zombieCount.textContent = `${remaining} ZOMBIES`;

            // Kill flash animation
            if (remaining < prevRemaining && remaining >= 0) {
                dom.zombieCount.classList.remove('kill-flash');
                void dom.zombieCount.offsetWidth;
                dom.zombieCount.classList.add('kill-flash');
            }
        }
    }

    if (force || lastHUDValues.score !== score) {
        lastHUDValues.score = score;
        if (dom.scoreDisplay) {
            dom.scoreDisplay.textContent = score.toString().padStart(8, '0');
        }
    }

    // Power-ups (throttled to whole seconds)
    const speedSec = Math.ceil(speedBoostTimer);
    const damageSec = Math.ceil(damageBoostTimer);
    if (force || lastHUDValues.speedSec !== speedSec || lastHUDValues.damageSec !== damageSec) {
        lastHUDValues.speedSec = speedSec;
        lastHUDValues.damageSec = damageSec;
        const pEl = ensurePowerupsEl();
        let html = '';
        if (speedSec > 0) html += `<div style="color: #0ff; text-shadow: 0 0 10px #0ff; font-size: 16px;"> SPEED ${speedSec}s</div>`;
        if (damageSec > 0) html += `<div style="color: #f00; text-shadow: 0 0 10px #f00; font-size: 16px;"> 2X DMG ${damageSec}s</div>`;
        pEl.innerHTML = html;
    }
}

function shoot() {
    if (isGameOver) return;
    if (isReloading || ammo <= 0) {
        if (ammo <= 0 && !isReloading) playSound('empty');
        return;
    }
    const now = performance.now() / 1000;
    if (now - lastShotTime < fireRate) return;
    
    lastShotTime = now;
    ammo--; // Still decrement for reload mechanic
    updateHUD();
    playSound('shoot');

    // ORGANIC RECOIL IMPULSE PHYSICS
    const aimMod = isAiming ? 0.35 : 1.0;

    // Randomize recoil slightly for organic feel (no two shots identical)
    const recoilVariance = 0.85 + Math.random() * 0.3;
    const horizontalBias = (Math.random() - 0.5) * 0.4; // Slight random horizontal pull

    // Z: Backward kick into shoulder - primary recoil
    Springs.recoilZ.impulse(-14 * aimMod * recoilVariance);

    // X: Muzzle climb (negative = up) - with variance
    Springs.recoilX.impulse(-3.5 * aimMod * recoilVariance);

    // Y: Vertical physical rise
    Springs.recoilY.impulse(0.6 * aimMod * recoilVariance);

    // Roll: Rotational torque - asymmetric for realism
    Springs.recoilRoll.impulse((horizontalBias + (Math.random() - 0.5) * 0.3) * 0.8 * aimMod);
    Springs.roll.impulse(horizontalBias * 0.4 * aimMod);

    // Horizontal sway from recoil
    Springs.swayX.impulse(horizontalBias * 0.15 * aimMod);

    // Camera recoil - gradual climb
    cameraRecoil += 0.025 * aimMod * recoilVariance;

    // Subtle forward jolt
    Springs.bobZ.impulse(-0.8 * aimMod);

    // Crosshair pop with smooth animation
    if(!isAiming) {
        crosshair.style.width = '45px'; crosshair.style.height = '45px';
        crosshair.style.transition = 'width 0.05s, height 0.05s';
        setTimeout(() => {
            crosshair.style.width = '20px'; crosshair.style.height = '20px';
            crosshair.style.transition = 'width 0.15s ease-out, height 0.15s ease-out';
        }, 50);
    }

    // ENHANCED FLASH with variance
    const flashIntensity = 0.9 + Math.random() * 0.2;
    flashCoreMat.opacity = flashIntensity;
    flashMidMat.opacity = flashIntensity * 0.9;
    flashOuterMat.opacity = flashIntensity * 0.7;
    flashStreakMat.opacity = flashIntensity * 0.8;
    flashGroup.rotation.z = Math.random() * Math.PI;
    flashGroup.scale.setScalar(0.75 + Math.random() * 0.5);
    muzzleLight.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
    muzzleLight.intensity = 25 + Math.random() * 10;
    muzzleLight.color.setHex(0xffaa44);

    // Spawn muzzle sparks
    spawnMuzzleSparks();

    // Dynamic post-processing punch
    bloomIntensity = 0.4 + Math.random() * 0.15;
    chromaticAmount = 0.0015 + Math.random() * 0.001;

    // Screen shake - organic variance
    const shakeIntensity = aimMod * recoilVariance;
    Springs.shakeX.impulse((Math.random() - 0.5) * 2.5 * shakeIntensity);
    Springs.shakeY.impulse((Math.random() - 0.3) * 2 * shakeIntensity); // Bias upward
    Springs.shakeRoll.impulse((Math.random() - 0.5) * 1.5 * shakeIntensity);

    // Bolt snap - spring-driven for smooth return
    Springs.boltZ.impulse(8); // Impulse bolt backward
    lastFireTime = performance.now();
    consecutiveShots++;

    ejectShell();
    spawnSmoke();
    spawnMuzzleSmokeWisps(); // NEW: Lingering smoke wisps

    // RAYCAST
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(targets);
    const muzzlePos = new THREE.Vector3(0, 0.3, -6.5).applyMatrix4(gunGroup.matrixWorld);
    let hitPoint;
    if (intersects.length > 0) {
        hitPoint = intersects[0].point;

        // Check if we hit a shooting target
        if (intersects[0].object.userData.isTarget) {
            const target = intersects[0].object.userData.targetRef;
            if (target && target.isUp) {
                target.knockDown();
                playSound('targetHit');
            }
        } else if (intersects[0].object.userData.isBot) {
            // Hit a bot (zombie)
            const bot = intersects[0].object.userData.botRef;
            if (bot && !bot.isDead) {
                const hitPointWorld = intersects[0].point.clone();

                // HEADSHOT DETECTION
                // Zombie head is at local y = 3.7 (1.85 * scale of 2.0)
                // Head radius is 0.7 (0.35 * 2.0)
                // So headshot if hit point is above torso top (~3.0 local y)
                const zombieBaseY = bot.mesh.position.y;
                const hitLocalY = hitPointWorld.y - zombieBaseY;
                const isHeadshot = hitLocalY > 2.9 && !bot.headExploded;

                if (isHeadshot) {
                    // Get direction from camera to zombie
                    const hitDir = new THREE.Vector3();
                    hitDir.subVectors(hitPointWorld, camera.position).normalize();

                    // EXPLODE THE HEAD!
                    explodeHead(bot, hitPointWorld, hitDir);
                    showHitmarker(true);

                    // Headshot is instant kill + bonus score
                    addScore(150); // +50 bonus for headshot
                    bot.health = 0;
                    bot.die();
                } else {
                    bot.hit(hitPointWorld);
                    showHitmarker(false);
                }
            }
        } else if (intersects[0].face) {
            spawnDecal(intersects[0].point, intersects[0].face.normal);
        }
    } else {
        hitPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
    }
    spawnTracer(muzzlePos, hitPoint);
}

function dropMag() {
    const dMag = magPivot.clone(); // Clone pivot to preserve rotation
    scene.add(dMag);
    const wp = new THREE.Vector3(); const wq = new THREE.Quaternion();
    magPivot.getWorldPosition(wp); magPivot.getWorldQuaternion(wq);
    dMag.position.copy(wp); dMag.quaternion.copy(wq);
    // Inherit some velocity?
    dMag.userData = { vel: new THREE.Vector3(0, -2, 0), rot: new THREE.Vector3(1, 0, 0), life: 200 };
    mags.push(dMag);
}

/**
 * HIGH-END RELOAD SEQUENCE (Tween.js)
 */
function reload() {
    if (isGameOver) return;
    if (isReloading || ammo === 30) return; // Infinite reserve, always can reload
    if (isAiming) isAiming = false;
    isReloading = true;
    updateHUD();

    // ANIMATION TWEENS
    // 1. Tilt Gun
    new TWEEN.Tween(recoilGroup.rotation)
        .to({ z: 0.8, x: 0.3 }, 300)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    // 2. Unlatch Mag (Fast)
    setTimeout(() => {
        playSound('mag_out');
        new TWEEN.Tween(magPivot.rotation)
            .to({ x: 1.5 }, 200)
            .easing(TWEEN.Easing.Back.In)
            .onComplete(() => {
                // 3. Drop
                dropMag();
                magPivot.visible = false;
                Springs.bobY.impulse(-2);
            })
            .start();

        // 4. Insert New Mag
        setTimeout(() => {
            magPivot.visible = true;
            magPivot.rotation.x = 0;
            magPivot.position.y = -4;

            new TWEEN.Tween(magPivot.position)
                .to({ y: -0.5 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // 5. Lock In
                    playSound('mag_in');
                    Springs.recoilX.impulse(-2);
                    Springs.roll.impulse(-0.2);

                    // 6. Rack Bolt
                    setTimeout(() => {
                        playSound('rack');
                        new TWEEN.Tween(bolt.position).to({ z: 0.5 }, 100).easing(TWEEN.Easing.Cubic.Out).start();
                        Springs.recoilZ.impulse(2);

                        setTimeout(() => {
                            new TWEEN.Tween(bolt.position).to({ z: -0.5 }, 80).easing(TWEEN.Easing.Exponential.In).start();
                            Springs.recoilZ.impulse(-5);

                            // 7. Return to Idle
                            new TWEEN.Tween(recoilGroup.rotation)
                                .to({ z: 0, x: 0 }, 400)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();

                            ammo = 30; // Infinite reserve, always full reload
                            isReloading = false;
                            updateHUD();
                        }, 150);
                    }, 200);
                })
                .start();
        }, 300);
    }, 250);
}

// Input
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'KeyR') reload();
    if (e.code === 'KeyW') moveState.f = true;
    if (e.code === 'KeyS') moveState.b = true;
    if (e.code === 'KeyA') moveState.l = true;
    if (e.code === 'KeyD') moveState.r = true;
    if (e.code === 'ShiftLeft') moveState.sprint = true;
    if (e.code === 'Space' && isGrounded && canJump) {
        verticalVelocity = jumpForce;
        isGrounded = false;
        canJump = false;
        // Slight upward weapon motion on jump
        Springs.bobY.impulse(-1.5);
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (e.code === 'KeyW') moveState.f = false;
    if (e.code === 'KeyS') moveState.b = false;
    if (e.code === 'KeyA') moveState.l = false;
    if (e.code === 'KeyD') moveState.r = false;
    if (e.code === 'ShiftLeft') moveState.sprint = false;
    if (e.code === 'Space') canJump = true;
});
document.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
        document.getElementById('blocker').style.display = 'none';
    } else {
        if(e.button === 0) isFiring = true;
        if(e.button === 2) isAiming = true;
    }
});
document.addEventListener('mouseup', (e) => {
    if(e.button === 0) isFiring = false;
    if(e.button === 2) isAiming = false;
});

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        const sens = isAiming ? 0.001 : 0.002;
        cameraYaw -= e.movementX * sens;
        cameraPitch -= e.movementY * sens;
        cameraPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraPitch));

        // ULTRA FLUID Procedural Sway - multi-layered organic response
        const adsReduction = isAiming ? 0.4 : 1.0;

        // Primary sway - immediate response
        const swayAmount = 0.0025 * adsReduction;
        Springs.swayX.target = -e.movementX * swayAmount;
        Springs.swayY.target = -e.movementY * swayAmount;

        // Roll with horizontal look - weapon tilts into turns
        const rollAmount = 0.005 * adsReduction;
        Springs.roll.target = -e.movementX * rollAmount;

        // Tilt on vertical look - weapon dips/rises with view
        Springs.tilt.target += e.movementY * 0.0004 * adsReduction;

        // Secondary lag layers get impulses for organic trailing
        const moveSpeed = Math.sqrt(e.movementX * e.movementX + e.movementY * e.movementY);
        if (moveSpeed > 2) {
            Springs.swayLagX.impulse(-e.movementX * 0.0008 * adsReduction);
            Springs.swayLagY.impulse(-e.movementY * 0.0008 * adsReduction);
            Springs.swayLag2X.impulse(-e.movementX * 0.0004 * adsReduction);
            Springs.swayLag2Y.impulse(-e.movementY * 0.0004 * adsReduction);
        }

        // Fast movements add extra roll momentum
        if (Math.abs(e.movementX) > 8) {
            Springs.roll.impulse(-e.movementX * 0.0003 * adsReduction);
        }

        // Motion blur from camera rotation - more subtle
        motionBlurX = Math.min(0.012, Math.abs(e.movementX) * 0.0004) * Math.sign(e.movementX);
        motionBlurY = Math.min(0.008, Math.abs(e.movementY) * 0.0004) * Math.sign(e.movementY);
    }
});

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    const dt = Math.min((time - prevTime) / 1000, 0.1); // Cap dt
    prevTime = time;
    frameCount++;

    // Throttled shadow updates (increased interval for performance)
    if (frameCount % (SHADOW_UPDATE_INTERVAL * 2) === 0) {
        renderer.shadowMap.needsUpdate = true;
    }

    // ADS Logic + Sprint FOV
    const targetPos = isAiming ? aimPos : hipPos;
    const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
    const targetFOV = isAiming ? 55 : (isSprinting ? 100 : 90);

    // Smooth transition for base position (Lerp is fine for macroscopic movements)
    recoilGroup.position.lerp(targetPos, 15 * dt);
    currentFOV = THREE.MathUtils.lerp(currentFOV, targetFOV, 8 * dt);
    camera.fov = currentFOV;
    camera.updateProjectionMatrix();

    // Hide crosshair when aiming
    crosshair.style.opacity = isAiming ? 0 : 1;

    // Track camera velocity for inertia
    camVelX = (cameraYaw - lastCamYaw) / Math.max(dt, 0.001);
    camVelY = (cameraPitch - lastCamPitch) / Math.max(dt, 0.001);
    lastCamYaw = cameraYaw;
    lastCamPitch = cameraPitch;

    // Update ALL Springs - Enhanced organic motion
    const recoilZ = Springs.recoilZ.update(dt);
    const recoilX = Springs.recoilX.update(dt);
    const recoilY = Springs.recoilY.update(dt);
    const recoilRoll = Springs.recoilRoll.update(dt);
    const recoilRecoverZ = Springs.recoilRecoverZ.update(dt);
    const recoilRecoverX = Springs.recoilRecoverX.update(dt);
    const swayX = Springs.swayX.update(dt);
    const swayY = Springs.swayY.update(dt);
    const swayLagX = Springs.swayLagX.update(dt);
    const swayLagY = Springs.swayLagY.update(dt);
    const swayLag2X = Springs.swayLag2X.update(dt);
    const swayLag2Y = Springs.swayLag2Y.update(dt);
    const bobY = Springs.bobY.update(dt);
    const bobX = Springs.bobX.update(dt);
    const bobZ = Springs.bobZ.update(dt);
    const roll = Springs.roll.update(dt);
    const tilt = Springs.tilt.update(dt);
    const breathe = Springs.breathe.update(dt);
    const idleSway = Springs.idleSway.update(dt);
    const heartbeat = Springs.heartbeat.update(dt);
    const momentumX = Springs.momentumX.update(dt);
    const momentumZ = Springs.momentumZ.update(dt);
    const shakeX = Springs.shakeX.update(dt);
    const shakeY = Springs.shakeY.update(dt);
    const shakeRoll = Springs.shakeRoll.update(dt);
    const camLagX = Springs.camLagX.update(dt);
    const camLagY = Springs.camLagY.update(dt);
    const adsTransition = Springs.adsTransition.update(dt);
    const sprintBob = Springs.sprintBob.update(dt);
    const sprintTilt = Springs.sprintTilt.update(dt);
    const sprintRoll = Springs.sprintRoll.update(dt);
    const landingTilt = Springs.landingTilt.update(dt);

    // === NEW: Attention to Detail Spring Updates ===
    const strafeTilt = Springs.strafeTilt.update(dt);
    const strafeRoll = Springs.strafeRoll.update(dt);
    const velocityDragX = Springs.velocityDragX.update(dt);
    const velocityDragY = Springs.velocityDragY.update(dt);
    const turnLagX = Springs.turnLagX.update(dt);
    const turnLagY = Springs.turnLagY.update(dt);
    const inspectRotX = Springs.inspectRotX.update(dt);
    const inspectRotY = Springs.inspectRotY.update(dt);
    const inspectRotZ = Springs.inspectRotZ.update(dt);
    const boltZ = Springs.boltZ.update(dt);
    const crosshairSpread = Springs.crosshairSpread.update(dt);

    // Organic idle animations using layered noise
    const idleAnimTime = time * 0.001;
    const breatheWave = organicNoise(idleAnimTime, 0.8, 2) * 0.012;
    const idleSwayWave = organicNoise(idleAnimTime + 100, 0.3, 3) * 0.008;
    const microTremor = organicNoise(idleAnimTime * 3, 2.5, 2) * 0.002;

    Springs.breathe.target = breatheWave;
    Springs.idleSway.target = idleSwayWave;
    Springs.heartbeat.target = Math.sin(idleAnimTime * 1.2) * 0.003; // Subtle pulse

    // Feed camera velocity into multi-layer lag springs for organic weapon inertia
    Springs.swayLagX.target = swayX * 0.7;
    Springs.swayLagY.target = swayY * 0.7;
    Springs.swayLag2X.target = swayLagX * 0.6;
    Springs.swayLag2Y.target = swayLagY * 0.6;
    Springs.camLagX.target = -camVelX * 0.00025;
    Springs.camLagY.target = -camVelY * 0.00025;

    // Track movement for momentum-based weapon lag
    moveVelX = THREE.MathUtils.lerp(moveVelX, velocity.x, 0.08);
    moveVelZ = THREE.MathUtils.lerp(moveVelZ, velocity.z, 0.08);
    Springs.momentumX.target = -moveVelX * 0.003;
    Springs.momentumZ.target = -moveVelZ * 0.002;

    // === NEW: Strafe Tilt - Weapon leans into strafe direction ===
    const strafeInput = Number(moveState.r) - Number(moveState.l);
    if (strafeInput !== 0 && !isAiming) {
        Springs.strafeTilt.target = strafeInput * 0.04;  // Lean into strafe
        Springs.strafeRoll.target = -strafeInput * 0.06; // Weapon roll opposite
        lastStrafeInput = strafeInput;
    } else {
        Springs.strafeTilt.target = 0;
        Springs.strafeRoll.target = 0;
    }

    // === NEW: Turn Inertia - Weapon trails behind fast camera turns ===
    const turnSpeed = Math.abs(camVelX) + Math.abs(camVelY);
    Springs.turnLagX.target = -camVelX * 0.0004;
    Springs.turnLagY.target = -camVelY * 0.0003;

    // === NEW: Velocity Drag - Weapon trails behind fast movement ===
    const moveSpeed = Math.sqrt(velocity.x * velocity.x + velocity.z * velocity.z);
    Springs.velocityDragX.target = -moveVelX * 0.005;
    Springs.velocityDragY.target = Math.abs(moveVelZ) * 0.002; // Slight bounce when moving

    // === NEW: Weapon Inspection - After idle for 5+ seconds ===
    if (!isFiring && !isReloading && !isAiming && moveSpeed < 0.5 && turnSpeed < 50) {
        idleTime += dt;
        if (idleTime > 5.0 && !isInspecting) {
            isInspecting = true;
            inspectPhase = 0;
        }
    } else {
        idleTime = 0;
        isInspecting = false;
        Springs.inspectRotX.target = 0;
        Springs.inspectRotY.target = 0;
        Springs.inspectRotZ.target = 0;
    }

    if (isInspecting) {
        inspectPhase += dt * 0.5; // Slow inspection cycle
        // Subtle inspection animation - look at the weapon
        Springs.inspectRotX.target = Math.sin(inspectPhase) * 0.15;
        Springs.inspectRotY.target = Math.sin(inspectPhase * 0.7) * 0.1 + 0.1;
        Springs.inspectRotZ.target = Math.cos(inspectPhase * 0.5) * 0.08;
        // Reset after full cycle
        if (inspectPhase > Math.PI * 4) {
            isInspecting = false;
            inspectPhase = 0;
        }
    }

    // === NEW: Bolt Carrier Animation - Smooth return after firing ===
    Springs.boltZ.target = 0; // Always return to closed position
    bolt.position.z = boltZ; // Apply spring-driven bolt position

    // === NEW: Dynamic Crosshair Spread ===
    let crosshairTarget = crosshairBaseSize;
    if (isFiring) {
        crosshairTarget += 25; // Expand on fire
        crosshair.classList.add('firing');
    } else {
        crosshair.classList.remove('firing');
    }
    if (moveSpeed > 2) {
        crosshairTarget += moveSpeed * 2; // Expand when moving
        crosshair.classList.add('moving');
    } else {
        crosshair.classList.remove('moving');
    }
    if (!isGrounded) {
        crosshairTarget += 15; // Expand in air
    }
    if (isAiming) {
        crosshairTarget = 0; // Hidden when ADS
    }
    Springs.crosshairSpread.target = crosshairTarget;
    crosshairCurrentSize = crosshairSpread;
    if (!isAiming) {
        crosshair.style.width = crosshairCurrentSize + 'px';
        crosshair.style.height = crosshairCurrentSize + 'px';
    }

    // === NEW: Low Health Visual Effects ===
    const lowHealthVignette = document.getElementById('low-health-vignette');
    if (lowHealthVignette) {
        if (playerHealth <= 30) {
            lowHealthPulse += dt * (1 + (30 - playerHealth) / 15); // Faster pulse at lower health
            const pulseIntensity = Math.max(0, 1 - playerHealth / 30);
            lowHealthVignette.style.opacity = 0.3 + Math.sin(lowHealthPulse * 3) * 0.2 * pulseIntensity;
            if (playerHealth <= 20) {
                lowHealthVignette.classList.add('pulse');
            } else {
                lowHealthVignette.classList.remove('pulse');
            }
        } else {
            lowHealthVignette.style.opacity = 0;
            lowHealthVignette.classList.remove('pulse');
            lowHealthPulse = 0;
        }
    }

    // === NEW: Damage Direction Indicator Fade ===
    if (damageIndicatorAlpha > 0) {
        damageIndicatorAlpha -= dt * 3; // Fade over ~0.33 seconds
        const arrows = document.querySelectorAll('.damage-arrow');
        arrows.forEach(a => a.style.opacity = 0);
        if (lastDamageDir && damageIndicatorAlpha > 0) {
            const arrow = document.querySelector('.damage-arrow.' + lastDamageDir);
            if (arrow) arrow.style.opacity = damageIndicatorAlpha;
        }
    }

    // Recoil recovery feeds into slower springs for organic settle
    Springs.recoilRecoverZ.target = recoilZ * 0.3;
    Springs.recoilRecoverX.target = recoilX * 0.3;

    // ADS smoothing
    Springs.adsTransition.target = isAiming ? 1 : 0;
    const adsAmount = adsTransition;
    const adsMultiplier = 1 - adsAmount * 0.6; // Reduce motion when ADS

    // Apply Springs to Gun - ULTRA FLUID layered organic motion
    // Position: recoil + bob + breathing + momentum + micro tremors + NEW effects
    const combinedRecoilZ = recoilZ + recoilRecoverZ * 0.5;
    const combinedRecoilX = recoilX + recoilRecoverX * 0.5;

    gunGroup.position.z = combinedRecoilZ * adsMultiplier + bobZ * adsMultiplier + breathe * 0.4 + momentumZ + velocityDragY;
    gunGroup.position.y = bobY * adsMultiplier + recoilY * adsMultiplier + breathe + heartbeat + microTremor + strafeTilt * 0.3;
    gunGroup.position.x = bobX * adsMultiplier + swayLag2X * 0.25 + momentumX + idleSway * 0.5 + velocityDragX + turnLagX;

    // Rotation: multi-layered sway + recoil + tilt + breathing + organic noise + NEW effects
    const totalSwayX = (swayX + swayLagX * 0.5 + swayLag2X * 0.3 + camLagX + turnLagX) * adsMultiplier;
    const totalSwayY = (swayY + swayLagY * 0.5 + swayLag2Y * 0.3 + camLagY + turnLagY) * adsMultiplier;

    gunGroup.rotation.x = combinedRecoilX * adsMultiplier + totalSwayY + tilt + breathe * 0.25 + landingTilt * 0.5 + sprintTilt + inspectRotX;
    gunGroup.rotation.y = Math.PI + totalSwayX + idleSway * 0.3 + strafeTilt + inspectRotY;
    gunGroup.rotation.z = (roll + recoilRoll) * adsMultiplier + totalSwayX * 0.35 + breathe * 0.15 + sprintRoll + microTremor * 2 + strafeRoll + inspectRotZ;

    // Reset Spring Targets (decay to neutral)
    Springs.swayX.target = 0;
    Springs.swayY.target = 0;
    Springs.roll.target = 0;
    Springs.tilt.target = 0;
    Springs.recoilZ.target = 0;
    Springs.recoilX.target = 0;
    Springs.recoilY.target = 0;
    Springs.recoilRoll.target = 0;
    Springs.bobX.target = 0;
    Springs.bobZ.target = 0;
    Springs.sprintBob.target = 0;
    Springs.sprintTilt.target = 0;
    Springs.sprintRoll.target = 0;
    Springs.landingTilt.target = 0;

    // Camera Recoil Recovery + Screen Shake - more organic + strafe lean
    cameraRecoil = THREE.MathUtils.lerp(cameraRecoil, 0, 0.08); // Slower recovery
    camera.rotation.set(
        cameraPitch + cameraRecoil + shakeY * 0.018 + breathe * 0.1,
        cameraYaw + shakeX * 0.018,
        (roll + shakeRoll) * 0.08 + strafeTilt * 0.5, // Camera also leans into strafe
        'YXZ'
    );

    // FLUID Movement (disabled during game over)
    if (document.pointerLockElement === document.body && !isGameOver) {
        // Smoother deceleration for fluid feel
        const friction = isGrounded ? 8.0 : 3.0;
        velocity.x -= velocity.x * friction * dt;
        velocity.z -= velocity.z * friction * dt;

        const fIn = Number(moveState.f) - Number(moveState.b);
        const rIn = Number(moveState.r) - Number(moveState.l);

        // Sprinting logic - only when moving forward and not aiming
        const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
        const speedMultiplier = speedBoostTimer > 0 ? speedBoostMultiplier : 1;
        const currentSpeed = (isAiming ? baseSpeed * 0.5 : (isSprinting ? baseSpeed * sprintMultiplier : baseSpeed)) * speedMultiplier;

        // Smoother acceleration
        const accel = isGrounded ? 12.0 : 4.0;
        if (moveState.f || moveState.b) velocity.z += fIn * currentSpeed * accel * dt;
        if (moveState.l || moveState.r) velocity.x += rIn * currentSpeed * accel * dt;

        const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
        const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
        
        // Store old position for collision resolution
        const oldX = camera.position.x;
        const oldZ = camera.position.z;
        
        // Calculate new position
        const newX = oldX + rgt.x * velocity.x * dt;
        const newZ = oldZ + rgt.z * velocity.x * dt;
        const finalX = newX + fwd.x * velocity.z * dt;
        const finalZ = newZ + fwd.z * velocity.z * dt;
        
        // Apply collision detection and resolution (player radius ~0.5)
        const playerRadius = 0.5;
        const resolved = resolveCollision(oldX, oldZ, finalX, finalZ, playerRadius);
        camera.position.x = resolved.x;
        camera.position.z = resolved.z;

        // Calculate dynamic ground level based on terrain height at player position
        const terrainY = getTerrainHeight(camera.position.x, camera.position.z);
        currentGroundLevel = terrainY + 5; // Eye level is 5 units above terrain

        // ULTRA FLUID Jump physics
        if (!isGrounded) {
            verticalVelocity -= gravity * dt;
            playerHeight += verticalVelocity * dt;

            // Organic airborne weapon drift
            const airTime = Math.abs(verticalVelocity) / gravity; // Approximate time in air

            // Weapon tilts based on vertical velocity - rising vs falling feels different
            if (verticalVelocity > 0) {
                // Rising - weapon tips back slightly
                Springs.tilt.target = verticalVelocity * 0.008;
                Springs.bobY.target = -verticalVelocity * 0.004;
                Springs.bobZ.target = verticalVelocity * 0.003; // Weapon pulls back
            } else {
                // Falling - weapon tips forward, bracing for landing
                Springs.tilt.target = verticalVelocity * 0.012;
                Springs.bobY.target = -verticalVelocity * 0.006;
                Springs.bobZ.target = verticalVelocity * 0.002;
                // Pre-brace roll
                Springs.roll.target = Math.sin(playerHeight * 2) * 0.02;
            }

            // Subtle floating sway while airborne
            Springs.swayX.target += Math.sin(time * 0.003) * 0.005;
            Springs.idleSway.target = Math.cos(time * 0.002) * 0.01;

            // Landing - check against dynamic ground level
            if (playerHeight <= currentGroundLevel) {
                playerHeight = currentGroundLevel;
                const landingImpact = Math.abs(verticalVelocity);
                verticalVelocity = 0;
                isGrounded = true;

                // ORGANIC landing effect based on fall speed
                if (landingImpact > 2) {
                    const impactScale = Math.min(landingImpact / 15, 1); // Normalize

                    // Main landing dip
                    Springs.landing.impulse(landingImpact * 0.25);

                    // Weapon drops and recovers
                    Springs.bobY.impulse(-landingImpact * 0.15);
                    Springs.bobZ.impulse(landingImpact * 0.08); // Weapon punches forward

                    // Tilt forward on impact
                    Springs.landingTilt.impulse(landingImpact * 0.025);
                    Springs.tilt.impulse(landingImpact * 0.015);

                    // Asymmetric roll for organic feel
                    Springs.roll.impulse((Math.random() - 0.4) * landingImpact * 0.025);

                    // Recoil springs add to the chaos
                    Springs.recoilY.impulse(-landingImpact * 0.08);

                    // Screen shake on harder landings
                    if (landingImpact > 6) {
                        Springs.shakeY.impulse(-landingImpact * 0.5);
                        Springs.shakeX.impulse((Math.random() - 0.5) * landingImpact * 0.25);
                        Springs.shakeRoll.impulse((Math.random() - 0.5) * landingImpact * 0.15);
                    }
                }
            }
        }

        // Apply landing spring
        const landingOffset = Springs.landing.update(dt);
        Springs.landing.target = 0;

        // When grounded, smoothly follow terrain height (for walking up/down hill)
        if (isGrounded) {
            playerHeight = THREE.MathUtils.lerp(playerHeight, currentGroundLevel, 0.15);
        }

        // Set camera Y position (base + jump height - landing dip)
        camera.position.y = playerHeight - landingOffset * 0.1;

        // ULTRA FLUID Procedural Bobbing (Walking/Sprinting)
        const vLen = Math.sqrt(velocity.x*velocity.x + velocity.z*velocity.z);
        moveVelSmooth = THREE.MathUtils.lerp(moveVelSmooth, vLen, 0.08); // Smoother velocity tracking
        const bobSpeed = isSprinting ? 0.016 : 0.011;
        const bobIntensity = isSprinting ? 0.1 : 0.06;
        const velRatio = Math.min(moveVelSmooth / baseSpeed, 1.5);

        if(moveVelSmooth > 0.1 && !isReloading && isGrounded) {
            // Phase offset for more natural gait
            const phase = time * bobSpeed;
            const phase2 = phase * 0.5;

            // Vertical bob - asymmetric for natural feel (footsteps aren't perfectly symmetric)
            const vertBob = Math.sin(phase) * 0.7 + Math.sin(phase * 2) * 0.3;
            Springs.bobY.target = vertBob * bobIntensity * velRatio;

            // Horizontal bob (side-to-side sway) - slower frequency
            const horizBob = Math.cos(phase2) + Math.sin(phase2 * 1.5) * 0.2;
            Springs.bobX.target = horizBob * bobIntensity * 0.35 * velRatio;

            // Forward/back bob - subtle push with each step
            Springs.bobZ.target = Math.sin(phase + 0.5) * bobIntensity * 0.2 * velRatio;

            // Hip sway rotation - figure-8 pattern for organic feel
            const hipSwayX = Math.cos(phase2) * 0.02 + Math.sin(phase * 0.7) * 0.008;
            Springs.swayX.target += hipSwayX * velRatio;

            // Roll with steps - asymmetric
            const stepRoll = Math.sin(phase) * 0.018 + Math.cos(phase * 1.3) * 0.006;
            Springs.roll.target += stepRoll * velRatio;

            // Forward tilt when moving - increases with speed
            Springs.tilt.target = -velRatio * 0.025;

            // Extra effects when sprinting - more dramatic
            if (isSprinting) {
                // Exaggerated sprint bob
                Springs.sprintBob.target = Math.sin(phase * 1.2) * 0.08;
                Springs.bobY.target += Springs.sprintBob.position;

                // More aggressive roll
                Springs.sprintRoll.target = Math.sin(phase) * 0.035;

                // Strong forward lean
                Springs.sprintTilt.target = -0.055;
                Springs.tilt.target = -0.04;

                // Weapon pulls back slightly when sprinting
                Springs.bobZ.target -= 0.15;
            }
        } else if (isGrounded) {
            // Smooth return to idle
            Springs.bobY.target = 0;
            Springs.bobX.target = 0;
            Springs.bobZ.target = 0;
            Springs.tilt.target = 0;
        }
    }

    if (isFiring) shoot();

    // Decay Enhanced Flash
    if (flashCoreMat.opacity > 0.01) {
        flashCoreMat.opacity = Math.max(0, flashCoreMat.opacity - 0.25);
        flashMidMat.opacity = Math.max(0, flashMidMat.opacity - 0.2);
        flashOuterMat.opacity = Math.max(0, flashOuterMat.opacity - 0.15);
        flashStreakMat.opacity = Math.max(0, flashStreakMat.opacity - 0.2);
        muzzleLight.intensity = Math.max(0, muzzleLight.intensity - 4);
    } else {
        flashCoreMat.opacity = 0;
        flashMidMat.opacity = 0;
        flashOuterMat.opacity = 0;
        flashStreakMat.opacity = 0;
        muzzleLight.intensity = 0;
    }

    // Decay dynamic post-processing
    bloomIntensity = THREE.MathUtils.lerp(bloomIntensity, 0.12, 0.15);
    bloomPass.strength = bloomIntensity;
    // Chromatic aberration disabled

    // Update motion blur based on camera rotation velocity
    motionBlurX = THREE.MathUtils.lerp(motionBlurX, 0, 0.2);
    motionBlurY = THREE.MathUtils.lerp(motionBlurY, 0, 0.2);
    motionBlurPass.uniforms.velocityX.value = motionBlurX;
    motionBlurPass.uniforms.velocityY.value = motionBlurY;

    // Post-processing effects disabled for performance

    // Update sky shader time for animated clouds
    skyUniforms.time.value = time * 0.001;

    // Calculate sun screen position for god rays and lens flare
    const sunWorldPos = sun.position.clone();
    const sunScreenPosTemp = sunWorldPos.project(camera);
    sunScreenPos.set(
        (sunScreenPosTemp.x + 1) / 2,
        (sunScreenPosTemp.y + 1) / 2
    );

    // Check if sun is visible (in front of camera and on screen)
    const sunDir = sunWorldPos.clone().sub(camera.position).normalize();
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const sunDot = sunDir.dot(camDir);

    // Sun visibility based on angle and screen bounds
    sunVisible = sunDot > 0 &&
                 sunScreenPos.x > -0.3 && sunScreenPos.x < 1.3 &&
                 sunScreenPos.y > -0.3 && sunScreenPos.y < 1.3 ?
                 Math.pow(sunDot, 2) : 0;

    // God rays, lens flare, heat distortion disabled for performance

    // Reset screen shake targets
    Springs.shakeX.target = 0;
    Springs.shakeY.target = 0;
    
    // Bolt Recovery (Spring-ish)
    if (!isReloading && bolt.position.z < -0.5) bolt.position.z += 0.1;

    // Entity Updates - using swap-and-pop for O(1) removal
    // Shells
    for(let i = shells.length - 1; i >= 0; i--) {
        const s = shells[i];
        s.position.addScaledVector(s.userData.velocity, dt); // Fixed: removed * 60 multiplier
        s.userData.velocity.y -= 20 * dt; // Fixed: proper gravity (was 0.02 per frame, now 20 units/sec^2)
        s.rotation.x += 2 * dt; // Fixed: proper rotation speed
        if(s.position.y < -5) { s.position.y = -5; s.userData.velocity.set(0,0,0); }
        if(--s.userData.life <= 0) {
            scene.remove(s);
            shells[i] = shells[shells.length - 1];
            shells.pop();
        }
    }
    // Mags
    for(let i = mags.length - 1; i >= 0; i--) {
        const m = mags[i];
        m.position.addScaledVector(m.userData.vel, dt); // Fixed: removed * 60 multiplier
        m.rotation.x += m.userData.rot.x * dt; // Fixed: proper rotation speed
        m.userData.vel.y -= 20 * dt; // Fixed: proper gravity (was 0.02 per frame, now 20 units/sec^2)
        if(m.position.y < -5) { m.position.y = -5; m.userData.vel.set(0,0,0); }
        if(--m.userData.life <= 0) {
            scene.remove(m);
            mags[i] = mags[mags.length - 1];
            mags.pop();
        }
    }
    // Smoke particles with pooling
    for(let i = smokeParticles.length - 1; i >= 0; i--) {
        const s = smokeParticles[i];
        s.age += dt;
        const r = s.age / s.life;
        if(r >= 1) {
            scene.remove(s.mesh);
            smokePool.release(s.mesh);
            smokeParticles[i] = smokeParticles[smokeParticles.length - 1];
            smokeParticles.pop();
            continue;
        }
        s.mesh.position.addScaledVector(s.velocity, dt);
        if(s.hot) {
            s.mesh.scale.setScalar(0.3 + r * 1.5);
            s.mesh.material.opacity = 0.6 * (1 - r);
        } else {
            s.mesh.scale.setScalar(0.5 + r * 4);
            s.mesh.material.opacity = 0.5 * (1 - r);
        }
        s.velocity.y += 1.5 * dt;
        s.velocity.multiplyScalar(0.99);
    }

    // === NEW: Update muzzle smoke wisps ===
    updateMuzzleSmokeWisps(dt);

    // Sparks with pooling
    for(let i = sparks.length - 1; i >= 0; i--) {
        const sp = sparks[i];
        sp.userData.life -= dt;
        if(sp.userData.life <= 0) {
            scene.remove(sp);
            sparkPool.release(sp);
            sparks[i] = sparks[sparks.length - 1];
            sparks.pop();
            continue;
        }
        sp.position.addScaledVector(sp.userData.velocity, dt);
        sp.userData.velocity.y -= 20 * dt;
        sp.material.opacity = sp.userData.life * 3;
    }

    // Debris with pooling
    for(let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.userData.life -= dt; // Fixed: time-based instead of frame-based
        if(d.userData.life <= 0) {
            scene.remove(d);
            debrisPool.release(d);
            debris[i] = debris[debris.length - 1];
            debris.pop();
            continue;
        }
        d.position.addScaledVector(d.userData.velocity, dt);
        d.userData.velocity.y -= 15 * dt;
        d.rotation.x += d.userData.rotVel.x * dt;
        d.rotation.y += d.userData.rotVel.y * dt;
        d.rotation.z += d.userData.rotVel.z * dt;
        if(d.position.y < -4.9) {
            d.position.y = -4.9;
            d.userData.velocity.set(0, 0, 0);
            d.userData.rotVel.multiplyScalar(0.9);
        }
    }
    // Tracers
    for(let i = tracers.length - 1; i >= 0; i--) {
        const t = tracers[i];
        t.life -= dt; // Fixed: time-based instead of frame-based
        t.mesh.material.opacity = Math.max(0, t.life / 0.1); // Fixed: opacity based on time (0.1 seconds)
        if(t.life <= 0) {
            scene.remove(t.mesh);
            tracers[i] = tracers[tracers.length - 1];
            tracers.pop();
        }
    }
    // Decals
    for(let i = decals.length - 1; i >= 0; i--) {
        const d = decals[i];
        d.life -= dt; // Fixed: time-based instead of frame-based
        if(d.life < 1.0) d.mesh.material.opacity = d.life / 1.0; // Fixed: fade over last 1 second
        if(d.life <= 0) {
            scene.remove(d.mesh);
            decals[i] = decals[decals.length - 1];
            decals.pop();
        }
    }

    // Update shooting targets
    for (const target of shootingTargets) {
        target.update(dt);
    }

    // Update wave system (only if game is active)
    if (!isGameOver) {
        updateWaveSystem(dt);
        updatePickups(dt, time);
        updateDoors(dt);

        // Update power-up timers (only when active)
        if (speedBoostTimer > 0) {
            speedBoostTimer -= dt;
            if (speedBoostTimer <= 0) speedBoostTimer = 0;
        }
        if (damageBoostTimer > 0) {
            damageBoostTimer -= dt;
            if (damageBoostTimer <= 0) damageBoostTimer = 0;
        }

        // Throttled HUD update (increased interval for performance)
        if (frameCount % (HUD_UPDATE_INTERVAL * 2) === 0) {
            updateHUD();
        }
    }

    // Update HiveMind (shared intelligence) - once per frame
    if (zombies.length > 0) {
        HiveMind.update(dt);
    }
    
    // Update all zombies every frame (no staggering - causes slow motion!)
    for (let i = 0; i < zombies.length; i++) {
        zombies[i].update(dt, time);
    }

    // Update blood and gore effects
    updateBloodEffects(dt);

    // Update damage flash
    if (damageFlashIntensity > 0) {
        damageFlashIntensity -= dt * 2;
        if (damageFlashIntensity < 0) damageFlashIntensity = 0;
        document.getElementById('damage-flash').style.opacity = damageFlashIntensity;
    }

    // Animate dust particles (throttled to every 12 frames for better performance)
    if (frameCount % 12 === 0) {
        const dustPos = dustGeo.attributes.position.array;
        for(let i = 0; i < dustCount; i += 4) { // Process every 4th particle
            dustPos[i * 3 + 1] += Math.sin(time * 0.0002 + i) * 0.003; // Even slower movement
            const dx = dustPos[i * 3] - camera.position.x;
            const dz = dustPos[i * 3 + 2] - camera.position.z;
            if(Math.abs(dx) > 140) dustPos[i * 3] = camera.position.x + (Math.random() - 0.5) * 280;
            if(Math.abs(dz) > 140) dustPos[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 280;
        }
        dustGeo.attributes.position.needsUpdate = true;
    }

    // Render with post-processing
    composer.render();
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth / 2, window.innerHeight / 2); // Half resolution for performance
    outlinePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
    // Update FXAA resolution
    const pr = renderer.getPixelRatio();
    fxaaPass.uniforms['resolution'].value.set(1 / (window.innerWidth * pr), 1 / (window.innerHeight * pr));
});

// Initialize HUD (force update all values)
updateHUD(true);

animate(performance.now());
</script>
</body>
</html>