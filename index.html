<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ZOMBIE SURVIVAL</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #050505; font-family: 'Courier New', monospace; }
        #crosshair {
            position: absolute; top: 50%; left: 50%; width: 20px; height: 20px;
            border: 2px solid rgba(0, 255, 0, 0.7); border-radius: 50%;
            transform: translate(-50%, -50%); pointer-events: none;
            transition: width 0.1s, height 0.1s, opacity 0.2s;
        }
        #hitmarker {
            position: absolute; top: 50%; left: 50%; width: 30px; height: 30px;
            transform: translate(-50%, -50%); pointer-events: none;
            opacity: 0; transition: opacity 0.05s;
        }
        #hitmarker.show {
            opacity: 1;
        }
        .hm-line {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 2px;
            background: rgba(180, 180, 180, 0.5);
            transform-origin: center;
        }
        .hm-line:first-child {
            transform: translate(-50%, -50%) rotate(45deg);
        }
        .hm-line:last-child {
            transform: translate(-50%, -50%) rotate(-45deg);
        }
        #ammo-display {
            position: absolute; bottom: 20px; right: 20px; color: #0f0;
            font-size: 28px; pointer-events: none; user-select: none;
            text-shadow: 0 0 5px #0f0;
        }
        #blocker, #game-over {
            position: absolute; width: 100%; height: 100%;
            background-color: rgba(0,0,0,0.85); color: white;
            display: flex; justify-content: center; align-items: center;
            flex-direction: column; cursor: pointer; z-index: 10;
        }
        #top-hud {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            display: flex; flex-direction: column; align-items: center;
            pointer-events: none; user-select: none;
        }
        #wave-display {
            font-size: 32px; color: #f00; text-shadow: 0 0 10px #f00;
            letter-spacing: 4px;
        }
        #zombie-count {
            font-size: 16px; color: #888; margin-top: 5px;
        }
        #score-display {
            font-size: 20px; color: #ff0; text-shadow: 0 0 5px #ff0;
            margin-top: 10px; letter-spacing: 2px;
        }
        #health-container {
            position: absolute; bottom: 20px; left: 20px;
            display: flex; align-items: center; gap: 10px;
            pointer-events: none; user-select: none;
        }
        #health-bar {
            width: 200px; height: 20px;
            background: #333; border: 2px solid #0f0;
            overflow: hidden;
        }
        #health-fill {
            width: 100%; height: 100%;
            background: #0f0; transition: width 0.2s, background 0.3s;
        }
        #health-text {
            font-size: 24px; color: #0f0; text-shadow: 0 0 5px #0f0;
            min-width: 40px;
        }
        #damage-flash {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%);
            pointer-events: none; opacity: 0; transition: opacity 0.1s;
        }
        #restart-btn:hover {
            background: #500; box-shadow: 0 0 20px #f00;
        }
    </style>
</head>
<body>

<div id="blocker">
    <h1>ZOMBIE SURVIVAL</h1>
    <p style="color: #0f0; font-size: 18px;">Survive the zombie horde!</p>
    <p>Click to Start</p>
    <p style="color: #888;">WASD: Move | SHIFT: Sprint | SPACE: Jump | LMB: Shoot | RMB: Aim | R: Reload</p>
</div>

<div id="game-over" style="display: none;">
    <h1 style="color: #f00; text-shadow: 0 0 20px #f00;">YOU DIED</h1>
    <p style="font-size: 24px;">SCORE: <span id="final-score">0</span></p>
    <p style="font-size: 18px;">Survived to Wave <span id="final-wave">1</span></p>
    <button id="restart-btn" onclick="restartGame()" style="margin-top: 20px; padding: 15px 40px; font-size: 20px; background: #300; color: #f00; border: 2px solid #f00; cursor: pointer; font-family: inherit;">RESTART</button>
</div>

<div id="crosshair"></div>
<div id="hitmarker">
    <div class="hm-line"></div>
    <div class="hm-line"></div>
</div>

<div id="damage-flash"></div>

<!-- Top HUD - Wave and Score -->
<div id="top-hud">
    <div id="wave-display">GET READY...</div>
    <div id="zombie-count">0 ZOMBIES</div>
    <div id="score-display">00000000</div>
</div>

<!-- Bottom Left - Health -->
<div id="health-container">
    <div id="health-bar">
        <div id="health-fill"></div>
    </div>
    <div id="health-text">100</div>
</div>

<!-- Bottom Right - Ammo -->
<div id="ammo-display">30 / 90</div>

<!-- Three.js from CDN -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<!-- Post-processing -->
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
<script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
<!-- TWEEN.js for complex curves -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tween.js/18.6.4/tween.umd.js"></script>

<script>
/**
 * MOTION DESIGN UTILS
 * Spring physics for procedural weight.
 */
// Enhanced Spring class with better physics simulation
class Spring {
    constructor(stiffness, damping, mass) {
        this.stiffness = stiffness;
        this.damping = damping;
        this.mass = mass;
        this.position = 0;
        this.velocity = 0;
        this.target = 0;
    }

    // Semi-implicit Euler for more stable, organic motion
    update(dt) {
        const displacement = this.position - this.target;
        const springForce = -this.stiffness * displacement;
        const dampingForce = -this.damping * this.velocity;
        const acceleration = (springForce + dampingForce) / this.mass;

        this.velocity += acceleration * dt;
        this.position += this.velocity * dt;

        return this.position;
    }

    impulse(force) {
        this.velocity += force / this.mass;
    }

    // Smooth impulse over time for more organic feel
    softImpulse(force, smoothness = 0.5) {
        this.velocity += (force / this.mass) * smoothness;
        this.target += (force / this.mass) * (1 - smoothness) * 0.1;
    }
}

// Dual-spring system for extra organic lag
class DualSpring {
    constructor(primaryStiffness, primaryDamping, secondaryStiffness, secondaryDamping, mass) {
        this.primary = new Spring(primaryStiffness, primaryDamping, mass);
        this.secondary = new Spring(secondaryStiffness, secondaryDamping, mass * 1.5);
    }

    update(dt) {
        const primaryPos = this.primary.update(dt);
        this.secondary.target = primaryPos;
        return this.secondary.update(dt);
    }

    set target(val) { this.primary.target = val; }
    get target() { return this.primary.target; }

    impulse(force) {
        this.primary.impulse(force * 0.7);
        this.secondary.impulse(force * 0.3);
    }
}

// Separate springs for different axes - ULTRA FLUID & ORGANIC feel
const Springs = {
    // Gun sway - multi-layered for organic feel
    swayX: new Spring(65, 5, 1.4),       // Softer, more floaty
    swayY: new Spring(65, 5, 1.4),
    swayLagX: new Spring(30, 3.5, 1.8),  // More lag for fluidity
    swayLagY: new Spring(30, 3.5, 1.8),
    swayLag2X: new Spring(18, 2.5, 2.2), // Third layer of lag
    swayLag2Y: new Spring(18, 2.5, 2.2),

    // Recoil - snappy initial kick with soft follow-through
    recoilZ: new Spring(280, 14, 0.9),   // Quick snap back
    recoilX: new Spring(180, 9, 1.1),    // Muzzle climb - softer
    recoilY: new Spring(140, 8, 1.2),    // Vertical rise
    recoilRoll: new Spring(200, 12, 1),  // Rotational recoil

    // Recoil recovery (slower return to neutral)
    recoilRecoverZ: new Spring(40, 4, 2),
    recoilRecoverX: new Spring(35, 3.5, 2),

    // Movement feel - very organic
    bobY: new Spring(50, 4, 1.4),        // Floatier vertical bob
    bobX: new Spring(40, 3.5, 1.5),      // Side-to-side sway
    bobZ: new Spring(35, 3, 1.6),        // Forward/back bob (new)
    roll: new Spring(45, 4, 1.3),        // Hip roll
    tilt: new Spring(30, 3, 1.5),        // Forward lean

    // Momentum/inertia
    momentumX: new Spring(25, 2.5, 2),   // Weapon trails behind movement
    momentumZ: new Spring(25, 2.5, 2),

    // Breathing/idle - very subtle organic motion
    breathe: new Spring(15, 1.5, 2.5),   // Slow breathing
    idleSway: new Spring(8, 1, 3),       // Ultra slow idle drift
    heartbeat: new Spring(100, 8, 0.5),  // Subtle pulse

    // Screen shake - responsive but not jarring
    shakeX: new Spring(250, 16, 1),
    shakeY: new Spring(250, 16, 1),
    shakeRoll: new Spring(200, 14, 1),   // Rotational shake

    // Camera smoothing - cinematic lag
    camLagX: new Spring(80, 6, 1.2),
    camLagY: new Spring(80, 6, 1.2),

    // ADS transition smoothing
    adsTransition: new Spring(120, 10, 1),
    adsFov: new Spring(100, 8, 1),

    // Landing impact
    landing: new Spring(200, 15, 1),
    landingTilt: new Spring(150, 12, 1),

    // Sprinting effects
    sprintBob: new Spring(70, 5, 1.2),
    sprintTilt: new Spring(50, 4, 1.3),
    sprintRoll: new Spring(60, 4.5, 1.2)
};

// Velocity tracking for inertia effects
let lastCamYaw = 0;
let lastCamPitch = 0;
let camVelX = 0;
let camVelY = 0;
let moveVelSmooth = 0;
let moveVelX = 0;
let moveVelZ = 0;

// Organic noise for idle animations
function organicNoise(time, frequency, octaves = 3) {
    let value = 0;
    let amplitude = 1;
    let freq = frequency;
    for (let i = 0; i < octaves; i++) {
        value += Math.sin(time * freq) * amplitude;
        value += Math.cos(time * freq * 1.3) * amplitude * 0.5;
        freq *= 2.1;
        amplitude *= 0.5;
    }
    return value;
}

/**
 * CUSTOM POST-PROCESSING SHADERS
 */
const VignetteShader = {
    uniforms: {
        tDiffuse: { value: null },
        intensity: { value: 0.4 },
        smoothness: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float intensity;
        uniform float smoothness;
        varying vec2 vUv;
        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            vec2 center = vUv - 0.5;
            float dist = length(center);
            float vignette = smoothstep(0.5, 0.5 - smoothness, dist * (intensity + 0.5));
            color.rgb *= vignette;
            gl_FragColor = color;
        }
    `
};

const ChromaticAberrationShader = {
    uniforms: {
        tDiffuse: { value: null },
        amount: { value: 0.003 },
        angle: { value: 0.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float amount;
        uniform float angle;
        varying vec2 vUv;
        void main() {
            vec2 offset = amount * vec2(cos(angle), sin(angle));
            vec4 cr = texture2D(tDiffuse, vUv + offset);
            vec4 cg = texture2D(tDiffuse, vUv);
            vec4 cb = texture2D(tDiffuse, vUv - offset);
            gl_FragColor = vec4(cr.r, cg.g, cb.b, cg.a);
        }
    `
};

const FilmGrainShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        intensity: { value: 0.03 },
        speed: { value: 1.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float intensity;
        varying vec2 vUv;

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float grain = random(vUv + time) * 2.0 - 1.0;
            color.rgb += grain * intensity;
            gl_FragColor = color;
        }
    `
};

const MotionBlurShader = {
    uniforms: {
        tDiffuse: { value: null },
        velocityX: { value: 0.0 },
        velocityY: { value: 0.0 },
        samples: { value: 4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float velocityX;
        uniform float velocityY;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 velocity = vec2(velocityX, velocityY);
            float speed = length(velocity);

            if (speed < 0.001) {
                gl_FragColor = texture2D(tDiffuse, vUv);
                return;
            }

            vec2 dir = velocity / speed;
            vec4 color = vec4(0.0);
            float total = 0.0;

            for (float i = 0.0; i < 16.0; i++) {
                if (i >= samples) break;
                float t = (i / (samples - 1.0)) - 0.5;
                vec2 offset = dir * t * speed;
                float weight = 1.0 - abs(t * 2.0);
                color += texture2D(tDiffuse, vUv + offset) * weight;
                total += weight;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ SSAO (Screen Space Ambient Occlusion) ============
const SSAOShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        radius: { value: 0.5 },
        aoStrength: { value: 1.2 },
        falloff: { value: 0.5 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float radius;
        uniform float aoStrength;
        uniform float falloff;
        varying vec2 vUv;

        float readDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            float viewZ = (cameraNear * cameraFar) / ((cameraFar - cameraNear) * fragCoordZ - cameraFar);
            return viewZ;
        }

        float random(vec2 co) {
            return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = readDepth(vUv);

            if (depth > -1.0) {
                gl_FragColor = color;
                return;
            }

            float ao = 0.0;
            float sampleRadius = radius / abs(depth);

            const int samples = 16;
            for (int i = 0; i < samples; i++) {
                float angle = float(i) * 2.39996322973;
                float r = sampleRadius * (float(i + 1) / float(samples));
                vec2 offset = vec2(cos(angle), sin(angle)) * r;
                offset += (vec2(random(vUv + float(i)), random(vUv - float(i))) - 0.5) * sampleRadius * 0.25;

                float sampleDepth = readDepth(vUv + offset);
                float rangeCheck = smoothstep(0.0, 1.0, falloff / abs(depth - sampleDepth));
                ao += (sampleDepth > depth + 0.01 ? 1.0 : 0.0) * rangeCheck;
            }

            ao = 1.0 - (ao / float(samples)) * aoStrength;
            ao = clamp(ao, 0.0, 1.0);

            color.rgb *= ao;
            gl_FragColor = color;
        }
    `
};

// ============ VOLUMETRIC GOD RAYS ============
const GodRaysShader = {
    uniforms: {
        tDiffuse: { value: null },
        lightPositionOnScreen: { value: new THREE.Vector2(0.3, 0.7) },
        exposure: { value: 0.35 },
        decay: { value: 0.96 },
        density: { value: 0.8 },
        weight: { value: 0.6 },
        samples: { value: 60 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 lightPositionOnScreen;
        uniform float exposure;
        uniform float decay;
        uniform float density;
        uniform float weight;
        uniform float samples;
        varying vec2 vUv;

        void main() {
            vec2 texCoord = vUv;
            vec2 deltaTexCoord = texCoord - lightPositionOnScreen;
            deltaTexCoord *= 1.0 / samples * density;

            vec4 color = texture2D(tDiffuse, texCoord);
            float illuminationDecay = 1.0;
            vec4 accumulatedColor = vec4(0.0);

            for (int i = 0; i < 100; i++) {
                if (float(i) >= samples) break;
                texCoord -= deltaTexCoord;
                vec4 sampleColor = texture2D(tDiffuse, texCoord);
                float luminance = dot(sampleColor.rgb, vec3(0.299, 0.587, 0.114));
                sampleColor *= illuminationDecay * weight * luminance;
                accumulatedColor += sampleColor;
                illuminationDecay *= decay;
            }

            accumulatedColor *= exposure;
            accumulatedColor.rgb = clamp(accumulatedColor.rgb, 0.0, 1.0);

            gl_FragColor = color + accumulatedColor * vec4(1.0, 0.9, 0.7, 1.0);
        }
    `
};

// ============ DEPTH OF FIELD (Bokeh) ============
const DepthOfFieldShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        focusDistance: { value: 10.0 },
        focusRange: { value: 5.0 },
        bokehStrength: { value: 2.0 },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float focusDistance;
        uniform float focusRange;
        uniform float bokehStrength;
        uniform float cameraNear;
        uniform float cameraFar;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            float depth = getDepth(vUv);
            float blur = abs(depth - focusDistance) / focusRange;
            blur = clamp(blur * bokehStrength, 0.0, 1.0);

            vec2 texelSize = 1.0 / resolution;
            vec4 color = vec4(0.0);
            float total = 0.0;

            // Hexagonal bokeh pattern
            const int SAMPLES = 36;
            for (int i = 0; i < SAMPLES; i++) {
                float angle = float(i) * 6.28318530718 / float(SAMPLES);
                float dist = blur * 8.0 * (0.5 + 0.5 * fract(float(i) * 0.618));
                vec2 offset = vec2(cos(angle), sin(angle)) * texelSize * dist;
                color += texture2D(tDiffuse, vUv + offset);
                total += 1.0;
            }

            gl_FragColor = color / total;
        }
    `
};

// ============ LENS FLARE SHADER ============
const LensFlareShader = {
    uniforms: {
        tDiffuse: { value: null },
        sunPosition: { value: new THREE.Vector2(0.3, 0.7) },
        sunVisible: { value: 1.0 },
        flareStrength: { value: 0.4 },
        ghostStrength: { value: 0.3 },
        haloStrength: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 sunPosition;
        uniform float sunVisible;
        uniform float flareStrength;
        uniform float ghostStrength;
        uniform float haloStrength;
        varying vec2 vUv;

        vec3 flareColor(float t) {
            return mix(vec3(1.0, 0.6, 0.3), vec3(1.0, 0.9, 0.6), t);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            if (sunVisible < 0.01) {
                gl_FragColor = color;
                return;
            }

            vec2 sunToCenter = vec2(0.5) - sunPosition;
            vec2 flareVector = sunToCenter;

            // Main sun glow
            float distToSun = length(vUv - sunPosition);
            float glow = exp(-distToSun * 4.0) * flareStrength * sunVisible;
            color.rgb += flareColor(0.0) * glow;

            // Ghost flares (reflections along the flare vector)
            for (int i = 1; i < 6; i++) {
                float t = float(i) / 6.0;
                vec2 ghostPos = sunPosition + flareVector * (0.3 + t * 1.4);
                float ghostDist = length(vUv - ghostPos);
                float ghostSize = 0.05 + t * 0.03;
                float ghost = smoothstep(ghostSize, 0.0, ghostDist) * ghostStrength * sunVisible;
                ghost *= (1.0 - t * 0.5);
                color.rgb += flareColor(t) * ghost * 0.5;
            }

            // Halo ring
            float haloDist = abs(length(vUv - sunPosition) - 0.25);
            float halo = smoothstep(0.02, 0.0, haloDist) * haloStrength * sunVisible * 0.3;
            color.rgb += vec3(1.0, 0.8, 0.5) * halo;

            // Anamorphic streak
            float streakX = exp(-abs(vUv.y - sunPosition.y) * 30.0) * exp(-abs(vUv.x - sunPosition.x) * 2.0);
            color.rgb += vec3(1.0, 0.7, 0.4) * streakX * flareStrength * sunVisible * 0.3;

            gl_FragColor = color;
        }
    `
};

// ============ HEAT DISTORTION / HAZE ============
const HeatDistortionShader = {
    uniforms: {
        tDiffuse: { value: null },
        time: { value: 0.0 },
        distortionStrength: { value: 0.003 },
        heatLine: { value: 0.2 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float time;
        uniform float distortionStrength;
        uniform float heatLine;
        varying vec2 vUv;

        float noise(vec2 p) {
            return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
        }

        float smoothNoise(vec2 p) {
            vec2 i = floor(p);
            vec2 f = fract(p);
            f = f * f * (3.0 - 2.0 * f);

            float a = noise(i);
            float b = noise(i + vec2(1.0, 0.0));
            float c = noise(i + vec2(0.0, 1.0));
            float d = noise(i + vec2(1.0, 1.0));

            return mix(mix(a, b, f.x), mix(c, d, f.x), f.y);
        }

        void main() {
            // Heat distortion strongest near bottom of screen (ground level)
            float heatMask = smoothstep(heatLine + 0.15, heatLine, vUv.y);

            // Multi-octave noise for realistic heat waves
            float n1 = smoothNoise(vUv * 20.0 + vec2(time * 0.5, time * 0.3));
            float n2 = smoothNoise(vUv * 40.0 + vec2(-time * 0.3, time * 0.5));
            float n3 = smoothNoise(vUv * 80.0 + vec2(time * 0.4, -time * 0.2));

            float distortion = (n1 * 0.5 + n2 * 0.3 + n3 * 0.2) * 2.0 - 1.0;

            vec2 offset = vec2(distortion, distortion * 0.5) * distortionStrength * heatMask;

            vec4 color = texture2D(tDiffuse, vUv + offset);

            gl_FragColor = color;
        }
    `
};

// ============ COLOR GRADING / LUT ============
const ColorGradingShader = {
    uniforms: {
        tDiffuse: { value: null },
        contrast: { value: 1.15 },
        saturation: { value: 1.2 },
        brightness: { value: 1.0 },
        // Shadows, midtones, highlights color adjustments
        shadowColor: { value: new THREE.Vector3(0.1, 0.05, 0.15) },
        midtoneColor: { value: new THREE.Vector3(1.0, 0.95, 0.9) },
        highlightColor: { value: new THREE.Vector3(1.0, 0.9, 0.8) },
        // Lift, gamma, gain (standard color grading)
        lift: { value: new THREE.Vector3(0.0, 0.0, 0.02) },
        gamma: { value: new THREE.Vector3(1.0, 1.0, 1.0) },
        gain: { value: new THREE.Vector3(1.0, 0.98, 0.95) }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float contrast;
        uniform float saturation;
        uniform float brightness;
        uniform vec3 shadowColor;
        uniform vec3 midtoneColor;
        uniform vec3 highlightColor;
        uniform vec3 lift;
        uniform vec3 gamma;
        uniform vec3 gain;
        varying vec2 vUv;

        vec3 adjustSaturation(vec3 color, float sat) {
            float luma = dot(color, vec3(0.299, 0.587, 0.114));
            return mix(vec3(luma), color, sat);
        }

        vec3 adjustContrast(vec3 color, float con) {
            return (color - 0.5) * con + 0.5;
        }

        vec3 liftGammaGain(vec3 color, vec3 lift, vec3 gamma, vec3 gain) {
            vec3 lerpV = clamp(pow(color, 1.0 / gamma), 0.0, 1.0);
            return gain * lerpV + lift * (1.0 - lerpV);
        }

        void main() {
            vec4 texel = texture2D(tDiffuse, vUv);
            vec3 color = texel.rgb;

            // Brightness
            color *= brightness;

            // Contrast
            color = adjustContrast(color, contrast);

            // Saturation
            color = adjustSaturation(color, saturation);

            // Lift/Gamma/Gain
            color = liftGammaGain(color, lift, gamma, gain);

            // Color tinting based on luminance
            float luma = dot(color, vec3(0.299, 0.587, 0.114));

            // Shadow tint (dark areas get cool/purple tint)
            float shadowMask = 1.0 - smoothstep(0.0, 0.3, luma);
            color = mix(color, color * shadowColor * 3.0, shadowMask * 0.3);

            // Highlight tint (bright areas get warm tint)
            float highlightMask = smoothstep(0.6, 1.0, luma);
            color = mix(color, color * highlightColor, highlightMask * 0.4);

            // Midtone tint
            float midtoneMask = 1.0 - abs(luma - 0.5) * 2.0;
            color *= mix(vec3(1.0), midtoneColor, midtoneMask * 0.2);

            gl_FragColor = vec4(clamp(color, 0.0, 1.0), texel.a);
        }
    `
};

// ============ SCREEN SPACE REFLECTIONS (Simplified) ============
const SSRShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        reflectionStrength: { value: 0.3 },
        groundLevel: { value: 0.25 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform vec2 resolution;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform float reflectionStrength;
        uniform float groundLevel;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Only apply reflections near ground level (bottom portion of screen)
            float reflectionMask = smoothstep(groundLevel + 0.1, groundLevel, vUv.y);

            if (reflectionMask > 0.01) {
                // Mirror UV for reflection
                vec2 reflectedUv = vec2(vUv.x, groundLevel + (groundLevel - vUv.y));

                if (reflectedUv.y >= 0.0 && reflectedUv.y <= 1.0) {
                    vec4 reflectedColor = texture2D(tDiffuse, reflectedUv);

                    // Fade reflection based on distance from ground
                    float fadeFactor = 1.0 - abs(vUv.y - groundLevel) * 4.0;
                    fadeFactor = clamp(fadeFactor, 0.0, 1.0);

                    // Blend with roughness simulation (blur)
                    float blur = (groundLevel - vUv.y) * 0.05;
                    vec4 blurredReflection = vec4(0.0);
                    float total = 0.0;
                    for (int i = -2; i <= 2; i++) {
                        for (int j = -2; j <= 2; j++) {
                            vec2 offset = vec2(float(i), float(j)) * blur;
                            blurredReflection += texture2D(tDiffuse, reflectedUv + offset);
                            total += 1.0;
                        }
                    }
                    reflectedColor = blurredReflection / total;

                    color.rgb = mix(color.rgb, reflectedColor.rgb, reflectionMask * reflectionStrength * fadeFactor);
                }
            }

            gl_FragColor = color;
        }
    `
};

// ============ ATMOSPHERIC SCATTERING ============
const AtmosphericScatteringShader = {
    uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        cameraNear: { value: 0.1 },
        cameraFar: { value: 1000.0 },
        fogColor: { value: new THREE.Vector3(0.4, 0.2, 0.15) },
        fogDensity: { value: 0.015 },
        sunDirection: { value: new THREE.Vector3(-0.5, 0.2, -0.8) },
        sunColor: { value: new THREE.Vector3(1.0, 0.7, 0.4) },
        scatteringStrength: { value: 0.4 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform sampler2D tDepth;
        uniform float cameraNear;
        uniform float cameraFar;
        uniform vec3 fogColor;
        uniform float fogDensity;
        uniform vec3 sunDirection;
        uniform vec3 sunColor;
        uniform float scatteringStrength;
        varying vec2 vUv;

        float getDepth(vec2 coord) {
            float fragCoordZ = texture2D(tDepth, coord).x;
            return (2.0 * cameraNear * cameraFar) / (cameraFar + cameraNear - fragCoordZ * (cameraFar - cameraNear));
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);
            float depth = getDepth(vUv);

            // Exponential fog
            float fogAmount = 1.0 - exp(-depth * fogDensity);
            fogAmount = clamp(fogAmount, 0.0, 1.0);

            // Add sun scattering based on view direction approximation
            vec2 screenCenter = vUv - 0.5;
            float viewSunDot = dot(normalize(vec3(screenCenter, 1.0)), normalize(sunDirection));
            viewSunDot = max(viewSunDot, 0.0);

            // Mie scattering (forward scattering from sun)
            float mie = pow(viewSunDot, 8.0) * scatteringStrength;

            vec3 scatterColor = mix(fogColor, sunColor, mie);

            color.rgb = mix(color.rgb, scatterColor, fogAmount);
            color.rgb += sunColor * mie * 0.2 * (1.0 - fogAmount);

            gl_FragColor = color;
        }
    `
};

// ============ CEL SHADING (Borderlands Style) ============
const CelShadingShader = {
    uniforms: {
        tDiffuse: { value: null },
        levels: { value: 4.0 },        // Number of color bands
        edgeIntensity: { value: 0.3 }, // How much to darken edges
        saturationBoost: { value: 1.2 } // Boost colors slightly
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform float levels;
        uniform float edgeIntensity;
        uniform float saturationBoost;
        varying vec2 vUv;

        vec3 rgb2hsv(vec3 c) {
            vec4 K = vec4(0.0, -1.0/3.0, 2.0/3.0, -1.0);
            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));
            float d = q.x - min(q.w, q.y);
            float e = 1.0e-10;
            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
        }

        vec3 hsv2rgb(vec3 c) {
            vec4 K = vec4(1.0, 2.0/3.0, 1.0/3.0, 3.0);
            vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
            return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
        }

        void main() {
            vec4 color = texture2D(tDiffuse, vUv);

            // Convert to HSV for better banding
            vec3 hsv = rgb2hsv(color.rgb);

            // Quantize value (brightness) into discrete levels
            float quantized = floor(hsv.z * levels + 0.5) / levels;

            // Boost saturation for that Borderlands pop
            hsv.y = min(hsv.y * saturationBoost, 1.0);
            hsv.z = quantized;

            // Convert back to RGB
            vec3 cel = hsv2rgb(hsv);

            gl_FragColor = vec4(cel, color.a);
        }
    `
};

const OutlineShader = {
    uniforms: {
        tDiffuse: { value: null },
        resolution: { value: new THREE.Vector2(1920, 1080) },
        outlineColor: { value: new THREE.Vector3(0.0, 0.0, 0.0) },
        thickness: { value: 1.0 },
        threshold: { value: 0.15 }
    },
    vertexShader: `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `,
    fragmentShader: `
        uniform sampler2D tDiffuse;
        uniform vec2 resolution;
        uniform vec3 outlineColor;
        uniform float thickness;
        uniform float threshold;
        varying vec2 vUv;

        float luminance(vec3 color) {
            return dot(color, vec3(0.299, 0.587, 0.114));
        }

        void main() {
            vec2 texel = vec2(1.0 / resolution.x, 1.0 / resolution.y) * thickness;

            // Sample surrounding pixels (Sobel operator)
            float tl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, texel.y)).rgb);
            float t  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, texel.y)).rgb);
            float tr = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, texel.y)).rgb);
            float l  = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, 0.0)).rgb);
            float r  = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, 0.0)).rgb);
            float bl = luminance(texture2D(tDiffuse, vUv + vec2(-texel.x, -texel.y)).rgb);
            float b  = luminance(texture2D(tDiffuse, vUv + vec2(0.0, -texel.y)).rgb);
            float br = luminance(texture2D(tDiffuse, vUv + vec2(texel.x, -texel.y)).rgb);

            // Sobel edge detection
            float gx = -tl - 2.0*l - bl + tr + 2.0*r + br;
            float gy = -tl - 2.0*t - tr + bl + 2.0*b + br;
            float edge = sqrt(gx*gx + gy*gy);

            vec4 color = texture2D(tDiffuse, vUv);

            // Apply outline where edges are detected
            if (edge > threshold) {
                // Blend toward outline color based on edge strength
                float blend = smoothstep(threshold, threshold + 0.1, edge);
                color.rgb = mix(color.rgb, outlineColor, blend * 0.9);
            }

            gl_FragColor = color;
        }
    `
};

// Dynamic post-processing values
let bloomIntensity = 0.15; // Warm sunset glow
let chromaticAmount = 0.0005;
let motionBlurX = 0.0;
let motionBlurY = 0.0;

// ============ PERFORMANCE: OBJECT POOLING ============
class ObjectPool {
    constructor(createFn, resetFn, initialSize = 50) {
        this.createFn = createFn;
        this.resetFn = resetFn;
        this.pool = [];
        this.active = [];
        // Pre-allocate
        for (let i = 0; i < initialSize; i++) {
            this.pool.push(createFn());
        }
    }

    get() {
        let obj = this.pool.pop() || this.createFn();
        this.active.push(obj);
        return obj;
    }

    release(obj) {
        const idx = this.active.indexOf(obj);
        if (idx > -1) {
            this.active.splice(idx, 1);
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }

    releaseAll() {
        while (this.active.length > 0) {
            const obj = this.active.pop();
            this.resetFn(obj);
            this.pool.push(obj);
        }
    }
}

// ============ INSTANCED PARTICLE SYSTEM ============
const MAX_BLOOD_PARTICLES = 200;
const MAX_SPARKS = 100;
const MAX_DEBRIS = 80;

// Reusable matrix and vectors for instanced updates
const _instanceMatrix = new THREE.Matrix4();
const _instancePos = new THREE.Vector3();
const _instanceQuat = new THREE.Quaternion();
const _instanceScale = new THREE.Vector3(1, 1, 1);
const _tempVec3 = new THREE.Vector3();

// Frame throttling for expensive operations
let frameCount = 0;
const SHADOW_UPDATE_INTERVAL = 3; // Update shadows every 3 frames
const HUD_UPDATE_INTERVAL = 2; // Update HUD every 2 frames
let lastHUDValues = { ammo: -1, reserve: -1, health: -1, score: -1, wave: -1 };

// Cached DOM references
let cachedDOM = null;
function getCachedDOM() {
    if (!cachedDOM) {
        cachedDOM = {
            ammoDisplay: document.getElementById('ammo-display'),
            healthFill: document.getElementById('health-fill'),
            healthText: document.getElementById('health-text'),
            waveDisplay: document.getElementById('wave-display'),
            zombieCount: document.getElementById('zombie-count'),
            scoreDisplay: document.getElementById('score-display'),
            damageFlash: document.getElementById('damage-flash')
        };
    }
    return cachedDOM;
}

/**
 * TEXTURE FACTORY
 */
const TextureFactory = {
    createCanvas: (size) => {
        const c = document.createElement('canvas');
        c.width = c.height = size;
        return { c, ctx: c.getContext('2d') };
    },
    
    noise: (ctx, w, h, opacity) => {
        const idata = ctx.getImageData(0,0,w,h);
        const data = idata.data;
        for(let i=0; i<data.length; i+=4) {
            const v = Math.random() * 255 * opacity;
            data[i] += v; data[i+1] += v; data[i+2] += v;
        }
        ctx.putImageData(idata, 0, 0);
    },

    wood: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.3;
        for(let i=0; i<150; i++) {
            ctx.strokeStyle = i%2===0 ? '#5d4037' : '#281a14';
            ctx.lineWidth = 1 + Math.random() * 4;
            ctx.beginPath();
            ctx.moveTo(0, Math.random()*size);
            ctx.bezierCurveTo(size/3, Math.random()*size, size*2/3, Math.random()*size, size, Math.random()*size);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.1);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        return tex;
    },

    metal: (isDark) => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = isDark ? '#1a1a1a' : '#555555'; ctx.fillRect(0,0,size,size);
        ctx.globalAlpha = 0.1; ctx.strokeStyle = '#ffffff';
        for(let i=0; i<400; i++) {
            ctx.lineWidth = 0.5; ctx.beginPath();
            const x = Math.random()*size; const y = Math.random()*size;
            ctx.moveTo(x, y); ctx.lineTo(x + (Math.random()-0.5)*50, y + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        TextureFactory.noise(ctx, size, size, 0.05);
        return new THREE.CanvasTexture(c);
    },

    concrete: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#888888'; ctx.fillRect(0,0,size,size);
        //Heavy noise for aggregate
        TextureFactory.noise(ctx, size, size, 0.4); 
        // Cracks
        ctx.strokeStyle = '#444444'; ctx.lineWidth = 1; ctx.globalAlpha = 0.5;
        for(let i=0; i<20; i++) {
             ctx.beginPath(); ctx.moveTo(Math.random()*size, Math.random()*size);
             for(let j=0; j<5; j++) ctx.lineTo(Math.random()*size, Math.random()*size);
             ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(20, 20);
        return tex;
    },

    brick: () => {
        const size = 512;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#301510'; ctx.fillRect(0,0,size,size); // Grout
        ctx.fillStyle = '#56302a'; // Brick color
        const brickW = 64; const brickH = 32;
        for(let y=0; y<size; y+=brickH+2) {
            const offset = (y/(brickH+2))%2 === 0 ? 0 : brickW/2;
            for(let x=-brickW; x<size; x+=brickW+2) {
                ctx.fillRect(x+offset, y, brickW, brickH);
            }
        }
        TextureFactory.noise(ctx, size, size, 0.2);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(10, 5);
        return tex;
    },

    grid: () => {
        const size = 1024;
        const { c, ctx } = TextureFactory.createCanvas(size);
        ctx.fillStyle = '#080808'; ctx.fillRect(0,0,size,size); // Darker floor
        TextureFactory.noise(ctx, size, size, 0.2);
        ctx.strokeStyle = '#222'; ctx.lineWidth = 2; ctx.globalAlpha = 1.0;
        const step = 128; // Bigger grid
        for(let i=0; i<=size; i+=step) {
            ctx.beginPath(); ctx.moveTo(i,0); ctx.lineTo(i,size); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(0,i); ctx.lineTo(size,i); ctx.stroke();
        }
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
        tex.repeat.set(50, 50);
        return tex;
    },

    // Procedural Bullet Hole
    impact: () => {
        const size = 128;
        const { c, ctx } = TextureFactory.createCanvas(size);
        // Alpha mask
        ctx.fillStyle = 'rgba(0,0,0,0)'; ctx.clearRect(0,0,size,size);
        
        // Cracks
        ctx.beginPath();
        ctx.arc(64,64, 20, 0, Math.PI*2);
        ctx.fillStyle = '#050505'; ctx.fill();
        
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        for(let i=0; i<12; i++) {
            ctx.beginPath(); ctx.moveTo(64,64);
            ctx.lineTo(64 + Math.cos(i)*40 + (Math.random()-0.5)*10, 64 + Math.sin(i)*40 + (Math.random()-0.5)*10);
            ctx.stroke();
        }
        return new THREE.CanvasTexture(c);
    }
};

/**
 * AUDIO ENGINE
 */
const AudioContext = window.AudioContext || window.webkitAudioContext;
const actx = new AudioContext();

// Improved Reverb
const convolver = actx.createConvolver();
const dryGain = actx.createGain();
const wetGain = actx.createGain();
dryGain.connect(actx.destination);
wetGain.connect(actx.destination);
wetGain.gain.value = 0.3; // Tighter reverb

const sampleRate = actx.sampleRate;
const length = sampleRate * 1.0; // Short, slap-back reverb
const impulse = actx.createBuffer(2, length, sampleRate);
for (let channel = 0; channel < 2; channel++) {
    const data = impulse.getChannelData(channel);
    for (let i = 0; i < length; i++) {
        // Exponential decay for metallic room sound
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 6);
    }
}
convolver.buffer = impulse;
convolver.connect(wetGain);

function playSound(type) {
    if (actx.state === 'suspended') actx.resume();
    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const filter = actx.createBiquadFilter();

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(dryGain);
    gain.connect(convolver);

    const now = actx.currentTime;

    if (type === 'shoot') {
        // Enhanced gunshot - layered sounds

        // Layer 1: Low thump (body)
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(20, now + 0.15);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        filter.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now); osc.stop(now + 0.2);

        // Layer 2: High crack
        const osc2 = actx.createOscillator();
        const gain2 = actx.createGain();
        const filter2 = actx.createBiquadFilter();
        osc2.connect(filter2); filter2.connect(gain2);
        gain2.connect(dryGain); gain2.connect(convolver);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(200, now);
        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.08);
        filter2.type = 'highpass';
        filter2.frequency.setValueAtTime(500, now);
        gain2.gain.setValueAtTime(0.5, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.08);
        osc2.start(now); osc2.stop(now + 0.1);

        // Layer 3: Noise burst (explosion)
        const nBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const out = nBuf.getChannelData(0);
        for (let i = 0; i < nBuf.length; i++) {
            const env = Math.exp(-i / (actx.sampleRate * 0.03));
            out[i] = (Math.random() * 2 - 1) * env;
        }
        const n = actx.createBufferSource(); n.buffer = nBuf;
        const nFilter = actx.createBiquadFilter();
        nFilter.type = 'bandpass';
        nFilter.frequency.setValueAtTime(2000, now);
        nFilter.Q.value = 1;
        const nG = actx.createGain();
        nG.gain.setValueAtTime(1.0, now);
        nG.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        n.connect(nFilter); nFilter.connect(nG);
        nG.connect(dryGain); nG.connect(convolver);
        n.start(now);

        // Layer 4: Mechanical click
        const osc3 = actx.createOscillator();
        const gain3 = actx.createGain();
        osc3.connect(gain3); gain3.connect(dryGain);
        osc3.type = 'square';
        osc3.frequency.setValueAtTime(1200, now + 0.02);
        gain3.gain.setValueAtTime(0.15, now + 0.02);
        gain3.gain.exponentialRampToValueAtTime(0.01, now + 0.04);
        osc3.start(now + 0.02); osc3.stop(now + 0.05);

    } else if (type === 'targetHit') {
        // Metallic ping/clang for hitting target
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(400, now + 0.3);
        filter.type = 'bandpass';
        filter.frequency.setValueAtTime(1000, now);
        filter.Q.value = 5;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add metallic noise
        const hitBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const hitOut = hitBuf.getChannelData(0);
        for (let i = 0; i < hitBuf.length; i++) hitOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.02));
        const hitN = actx.createBufferSource(); hitN.buffer = hitBuf;
        const hitG = actx.createGain();
        hitG.gain.setValueAtTime(0.3, now);
        hitG.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        hitN.connect(hitG); hitG.connect(dryGain);
        hitN.start(now);

    } else if (type === 'zombieHit') {
        // Fleshy impact sound for zombie hits
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.1);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now); osc.stop(now + 0.15);

        // Thwack noise layer
        const thwackBuf = actx.createBuffer(1, actx.sampleRate * 0.08, actx.sampleRate);
        const thwackOut = thwackBuf.getChannelData(0);
        for (let i = 0; i < thwackBuf.length; i++) {
            thwackOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.015));
        }
        const thwackN = actx.createBufferSource(); thwackN.buffer = thwackBuf;
        const thwackFilter = actx.createBiquadFilter();
        thwackFilter.type = 'bandpass'; thwackFilter.frequency.value = 800; thwackFilter.Q.value = 1;
        const thwackG = actx.createGain();
        thwackG.gain.setValueAtTime(0.4, now);
        thwackN.connect(thwackFilter); thwackFilter.connect(thwackG);
        thwackG.connect(dryGain);
        thwackN.start(now);

    } else if (type === 'zombieDeath') {
        // Zombie death groan
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.4);
        filter.type = 'lowpass';
        filter.frequency.value = 250;
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.45);
        osc.start(now); osc.stop(now + 0.5);

        // Body fall thud
        const thudOsc = actx.createOscillator();
        const thudGain = actx.createGain();
        thudOsc.connect(thudGain); thudGain.connect(dryGain); thudGain.connect(convolver);
        thudOsc.type = 'sine';
        thudOsc.frequency.setValueAtTime(80, now + 0.2);
        thudOsc.frequency.exponentialRampToValueAtTime(30, now + 0.4);
        thudGain.gain.setValueAtTime(0.6, now + 0.2);
        thudGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        thudOsc.start(now + 0.2); thudOsc.stop(now + 0.55);

    } else if (type === 'zombieAttack') {
        // Zombie growl/bite sound
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(80, now + 0.25);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now); osc.stop(now + 0.35);

        // Add snarl noise
        const snarlBuf = actx.createBuffer(1, actx.sampleRate * 0.15, actx.sampleRate);
        const snarlOut = snarlBuf.getChannelData(0);
        for (let i = 0; i < snarlBuf.length; i++) {
            snarlOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.05)) * 0.5;
        }
        const snarlN = actx.createBufferSource(); snarlN.buffer = snarlBuf;
        const snarlFilter = actx.createBiquadFilter();
        snarlFilter.type = 'bandpass'; snarlFilter.frequency.value = 300; snarlFilter.Q.value = 2;
        const snarlG = actx.createGain();
        snarlG.gain.setValueAtTime(0.3, now);
        snarlN.connect(snarlFilter); snarlFilter.connect(snarlG);
        snarlG.connect(dryGain);
        snarlN.start(now);

    } else if (type === 'playerHurt') {
        // Pain sound - sharp impact
        osc.type = 'square';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.25);

        // Heartbeat thump
        const heartOsc = actx.createOscillator();
        const heartGain = actx.createGain();
        heartOsc.connect(heartGain); heartGain.connect(dryGain);
        heartOsc.type = 'sine';
        heartOsc.frequency.value = 40;
        heartGain.gain.setValueAtTime(0.4, now + 0.1);
        heartGain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        heartOsc.start(now + 0.1); heartOsc.stop(now + 0.3);

    } else if (type === 'waveComplete') {
        // Victory fanfare - rising tones
        const freqs = [400, 500, 600, 800];
        freqs.forEach((freq, i) => {
            const victoryOsc = actx.createOscillator();
            const victoryGain = actx.createGain();
            victoryOsc.connect(victoryGain); victoryGain.connect(dryGain); victoryGain.connect(convolver);
            victoryOsc.type = 'sine';
            victoryOsc.frequency.value = freq;
            victoryGain.gain.setValueAtTime(0.2, now + i * 0.1);
            victoryGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.1 + 0.3);
            victoryOsc.start(now + i * 0.1); victoryOsc.stop(now + i * 0.1 + 0.35);
        });
        // Don't start the main osc for this sound type
        return;

    } else if (type === 'empty') {
        osc.type = 'square'; osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.2, now); gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    } else if (type === 'mag_out') {
        // Magazine release click
        osc.type = 'square';
        osc.frequency.setValueAtTime(2500, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.02);
        filter.type = 'highpass';
        filter.frequency.value = 1000;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.03);
        osc.start(now); osc.stop(now + 0.04);

        // Metal slide sound
        const slideOsc = actx.createOscillator();
        const slideGain = actx.createGain();
        const slideFilter = actx.createBiquadFilter();
        slideOsc.connect(slideFilter); slideFilter.connect(slideGain);
        slideGain.connect(dryGain); slideGain.connect(convolver);
        slideOsc.type = 'sawtooth';
        slideOsc.frequency.setValueAtTime(400, now + 0.02);
        slideOsc.frequency.linearRampToValueAtTime(150, now + 0.12);
        slideFilter.type = 'bandpass';
        slideFilter.frequency.value = 800;
        slideFilter.Q.value = 2;
        slideGain.gain.setValueAtTime(0.25, now + 0.02);
        slideGain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        slideOsc.start(now + 0.02); slideOsc.stop(now + 0.15);

        // Metallic rattle noise
        const rattleBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const rattleOut = rattleBuf.getChannelData(0);
        for (let i = 0; i < rattleBuf.length; i++) {
            rattleOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.03)) * Math.sin(i * 0.3);
        }
        const rattleN = actx.createBufferSource(); rattleN.buffer = rattleBuf;
        const rattleFilter = actx.createBiquadFilter();
        rattleFilter.type = 'highpass';
        rattleFilter.frequency.value = 2000;
        const rattleG = actx.createGain();
        rattleG.gain.setValueAtTime(0.2, now + 0.03);
        rattleN.connect(rattleFilter); rattleFilter.connect(rattleG);
        rattleG.connect(dryGain);
        rattleN.start(now + 0.03);

    } else if (type === 'mag_in') {
        // Heavy metallic clunk - magazine seating

        // Initial impact
        osc.type = 'sine';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(60, now + 0.08);
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        gain.gain.setValueAtTime(0.6, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Sharp click
        const clickOsc = actx.createOscillator();
        const clickGain = actx.createGain();
        clickOsc.connect(clickGain); clickGain.connect(dryGain);
        clickOsc.type = 'square';
        clickOsc.frequency.setValueAtTime(3000, now);
        clickOsc.frequency.exponentialRampToValueAtTime(1500, now + 0.015);
        clickGain.gain.setValueAtTime(0.4, now);
        clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
        clickOsc.start(now); clickOsc.stop(now + 0.03);

        // Metal resonance
        const resOsc = actx.createOscillator();
        const resGain = actx.createGain();
        const resFilter = actx.createBiquadFilter();
        resOsc.connect(resFilter); resFilter.connect(resGain);
        resGain.connect(dryGain); resGain.connect(convolver);
        resOsc.type = 'triangle';
        resOsc.frequency.setValueAtTime(450, now);
        resOsc.frequency.exponentialRampToValueAtTime(200, now + 0.15);
        resFilter.type = 'bandpass';
        resFilter.frequency.value = 600;
        resFilter.Q.value = 8;
        resGain.gain.setValueAtTime(0.2, now + 0.01);
        resGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        resOsc.start(now + 0.01); resOsc.stop(now + 0.18);

        // Latch snap
        const snapBuf = actx.createBuffer(1, actx.sampleRate * 0.03, actx.sampleRate);
        const snapOut = snapBuf.getChannelData(0);
        for (let i = 0; i < snapBuf.length; i++) snapOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.005));
        const snapN = actx.createBufferSource(); snapN.buffer = snapBuf;
        const snapFilter = actx.createBiquadFilter();
        snapFilter.type = 'highpass'; snapFilter.frequency.value = 3000;
        const snapG = actx.createGain();
        snapG.gain.setValueAtTime(0.35, now);
        snapN.connect(snapFilter); snapFilter.connect(snapG); snapG.connect(dryGain);
        snapN.start(now);

    } else if (type === 'rack') {
        // Bolt/charging handle - metallic slide and slam

        // Slide back - scraping metal
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.08);
        filter.type = 'bandpass';
        filter.frequency.value = 1200;
        filter.Q.value = 3;
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.12);

        // Metal scrape noise
        const scrapeBuf = actx.createBuffer(1, actx.sampleRate * 0.1, actx.sampleRate);
        const scrapeOut = scrapeBuf.getChannelData(0);
        for (let i = 0; i < scrapeBuf.length; i++) {
            const env = Math.exp(-i / (actx.sampleRate * 0.04));
            scrapeOut[i] = (Math.random() * 2 - 1) * env * (0.5 + 0.5 * Math.sin(i * 0.05));
        }
        const scrapeN = actx.createBufferSource(); scrapeN.buffer = scrapeBuf;
        const scrapeFilter = actx.createBiquadFilter();
        scrapeFilter.type = 'bandpass'; scrapeFilter.frequency.value = 2500; scrapeFilter.Q.value = 2;
        const scrapeG = actx.createGain();
        scrapeG.gain.setValueAtTime(0.25, now);
        scrapeN.connect(scrapeFilter); scrapeFilter.connect(scrapeG);
        scrapeG.connect(dryGain); scrapeG.connect(convolver);
        scrapeN.start(now);

        // Bolt slam forward
        const slamOsc = actx.createOscillator();
        const slamGain = actx.createGain();
        slamOsc.connect(slamGain); slamGain.connect(dryGain); slamGain.connect(convolver);
        slamOsc.type = 'square';
        slamOsc.frequency.setValueAtTime(120, now + 0.1);
        slamOsc.frequency.exponentialRampToValueAtTime(40, now + 0.18);
        slamGain.gain.setValueAtTime(0.5, now + 0.1);
        slamGain.gain.exponentialRampToValueAtTime(0.01, now + 0.18);
        slamOsc.start(now + 0.1); slamOsc.stop(now + 0.2);

        // Sharp impact click
        const impactOsc = actx.createOscillator();
        const impactGain = actx.createGain();
        impactOsc.connect(impactGain); impactGain.connect(dryGain);
        impactOsc.type = 'square';
        impactOsc.frequency.setValueAtTime(4000, now + 0.1);
        impactOsc.frequency.exponentialRampToValueAtTime(1000, now + 0.12);
        impactGain.gain.setValueAtTime(0.35, now + 0.1);
        impactGain.gain.exponentialRampToValueAtTime(0.01, now + 0.13);
        impactOsc.start(now + 0.1); impactOsc.stop(now + 0.15);

        // Metal ring after slam
        const ringOsc = actx.createOscillator();
        const ringGain = actx.createGain();
        const ringFilter = actx.createBiquadFilter();
        ringOsc.connect(ringFilter); ringFilter.connect(ringGain);
        ringGain.connect(dryGain); ringGain.connect(convolver);
        ringOsc.type = 'sine';
        ringOsc.frequency.setValueAtTime(800, now + 0.11);
        ringFilter.type = 'bandpass'; ringFilter.frequency.value = 800; ringFilter.Q.value = 15;
        ringGain.gain.setValueAtTime(0.15, now + 0.11);
        ringGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        ringOsc.start(now + 0.11); ringOsc.stop(now + 0.4);

    } else if (type === 'pickup') {
        // Satisfying pickup chime
        const freqs = [600, 800, 1000];
        freqs.forEach((freq, i) => {
            const chimeOsc = actx.createOscillator();
            const chimeGain = actx.createGain();
            chimeOsc.connect(chimeGain); chimeGain.connect(dryGain); chimeGain.connect(convolver);
            chimeOsc.type = 'sine';
            chimeOsc.frequency.value = freq;
            chimeGain.gain.setValueAtTime(0.2, now + i * 0.05);
            chimeGain.gain.exponentialRampToValueAtTime(0.01, now + i * 0.05 + 0.2);
            chimeOsc.start(now + i * 0.05); chimeOsc.stop(now + i * 0.05 + 0.25);
        });
        return;

    } else if (type === 'nuke') {
        // Massive explosion
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, now);
        osc.frequency.exponentialRampToValueAtTime(15, now + 0.8);
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(400, now);
        filter.frequency.exponentialRampToValueAtTime(50, now + 0.5);
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1.0);
        osc.start(now); osc.stop(now + 1.2);

        // Massive noise burst
        const nukeBuf = actx.createBuffer(1, actx.sampleRate * 0.5, actx.sampleRate);
        const nukeOut = nukeBuf.getChannelData(0);
        for (let i = 0; i < nukeBuf.length; i++) {
            nukeOut[i] = (Math.random() * 2 - 1) * Math.exp(-i / (actx.sampleRate * 0.2));
        }
        const nukeN = actx.createBufferSource(); nukeN.buffer = nukeBuf;
        const nukeFilter = actx.createBiquadFilter();
        nukeFilter.type = 'lowpass'; nukeFilter.frequency.value = 600;
        const nukeG = actx.createGain();
        nukeG.gain.setValueAtTime(0.7, now);
        nukeG.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        nukeN.connect(nukeFilter); nukeFilter.connect(nukeG);
        nukeG.connect(dryGain); nukeG.connect(convolver);
        nukeN.start(now);

        // High frequency sizzle
        const sizzleOsc = actx.createOscillator();
        const sizzleGain = actx.createGain();
        sizzleOsc.connect(sizzleGain); sizzleGain.connect(dryGain);
        sizzleOsc.type = 'sawtooth';
        sizzleOsc.frequency.setValueAtTime(2000, now);
        sizzleOsc.frequency.exponentialRampToValueAtTime(100, now + 0.3);
        sizzleGain.gain.setValueAtTime(0.3, now);
        sizzleGain.gain.exponentialRampToValueAtTime(0.01, now + 0.35);
        sizzleOsc.start(now); sizzleOsc.stop(now + 0.4);
    }
}

/**
 * SCENE SETUP
 */
const scene = new THREE.Scene();
// ENHANCED Procedural Skybox - Epic Sunset with Volumetric Clouds
const skyVertexShader = `
varying vec3 vWorldPosition;
varying vec3 vDirection;
void main() {
    vec4 worldPosition = modelMatrix * vec4(position, 1.0);
    vWorldPosition = worldPosition.xyz;
    vDirection = normalize(position);
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`;

const skyFragmentShader = `
uniform vec3 topColor;
uniform vec3 midColor;
uniform vec3 bottomColor;
uniform vec3 sunColor;
uniform vec3 sunDirection;
uniform float time;
varying vec3 vWorldPosition;
varying vec3 vDirection;

// Simplex noise functions for procedural clouds
vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

float snoise(vec3 v) {
    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

    vec3 i  = floor(v + dot(v, C.yyy));
    vec3 x0 = v - i + dot(i, C.xxx);

    vec3 g = step(x0.yzx, x0.xyz);
    vec3 l = 1.0 - g;
    vec3 i1 = min(g.xyz, l.zxy);
    vec3 i2 = max(g.xyz, l.zxy);

    vec3 x1 = x0 - i1 + C.xxx;
    vec3 x2 = x0 - i2 + C.yyy;
    vec3 x3 = x0 - D.yyy;

    i = mod289(i);
    vec4 p = permute(permute(permute(
        i.z + vec4(0.0, i1.z, i2.z, 1.0))
        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

    float n_ = 0.142857142857;
    vec3 ns = n_ * D.wyz - D.xzx;

    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
    vec4 x_ = floor(j * ns.z);
    vec4 y_ = floor(j - 7.0 * x_);
    vec4 x = x_ *ns.x + ns.yyyy;
    vec4 y = y_ *ns.x + ns.yyyy;
    vec4 h = 1.0 - abs(x) - abs(y);
    vec4 b0 = vec4(x.xy, y.xy);
    vec4 b1 = vec4(x.zw, y.zw);
    vec4 s0 = floor(b0)*2.0 + 1.0;
    vec4 s1 = floor(b1)*2.0 + 1.0;
    vec4 sh = -step(h, vec4(0.0));
    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
    vec3 p0 = vec3(a0.xy, h.x);
    vec3 p1 = vec3(a0.zw, h.y);
    vec3 p2 = vec3(a1.xy, h.z);
    vec3 p3 = vec3(a1.zw, h.w);
    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
    m = m * m;
    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
}

float fbm(vec3 p) {
    float f = 0.0;
    float amplitude = 0.5;
    for (int i = 0; i < 5; i++) {
        f += amplitude * snoise(p);
        p *= 2.0;
        amplitude *= 0.5;
    }
    return f;
}

void main() {
    vec3 dir = normalize(vDirection);
    float h = dir.y;

    // More natural sunset gradient
    vec3 horizonColor = vec3(0.95, 0.5, 0.2);   // Warm orange at horizon
    vec3 lowerSkyColor = vec3(0.6, 0.35, 0.25); // Muted pink-orange

    vec3 skyColor;
    if (h < 0.0) {
        // Below horizon - dark
        skyColor = mix(vec3(0.03, 0.02, 0.02), bottomColor * 0.3, smoothstep(-0.2, 0.0, h));
    } else if (h < 0.15) {
        // Horizon band
        skyColor = mix(horizonColor, lowerSkyColor, smoothstep(0.0, 0.15, h));
    } else if (h < 0.4) {
        // Lower sky
        skyColor = mix(lowerSkyColor, midColor, smoothstep(0.15, 0.4, h));
    } else {
        // Upper sky fading to darker blue-purple
        skyColor = mix(midColor, topColor, smoothstep(0.4, 0.85, h));
    }

    // Sun glow - more natural
    float sunDot = dot(dir, normalize(sunDirection));
    float sunGlow = pow(max(sunDot, 0.0), 80.0);
    float sunHalo = pow(max(sunDot, 0.0), 12.0) * 0.3;
    float sunDisk = smoothstep(0.997, 0.999, sunDot);

    skyColor += sunColor * sunGlow * 1.5;
    skyColor += sunColor * sunHalo * 0.4;
    skyColor += sunColor * sunDisk * 2.0;

    // Subtle procedural clouds
    if (h > 0.0 && h < 0.5) {
        vec3 cloudPos = dir * 2.0 + vec3(time * 0.005, 0.0, time * 0.003);
        float cloud = fbm(cloudPos * 1.5);
        cloud = smoothstep(0.1, 0.5, cloud);

        // Clouds lit by sunset - muted colors
        vec3 cloudColor = mix(vec3(0.8, 0.5, 0.35), vec3(0.5, 0.3, 0.25), 1.0 - h * 2.0);

        // Light the clouds from sun direction
        float cloudLight = max(0.0, dot(dir, normalize(sunDirection)));
        cloudColor = mix(cloudColor * 0.5, cloudColor * 1.2, cloudLight);

        // Cloud density varies by height - less dense overall
        float cloudMask = smoothstep(0.0, 0.1, h) * smoothstep(0.5, 0.2, h);
        cloud *= cloudMask * 0.4; // Much less cloud coverage

        skyColor = mix(skyColor, cloudColor, cloud);
    }

    // Subtle atmospheric scattering
    float scatter = 1.0 - abs(h);
    scatter = pow(scatter, 4.0);
    skyColor = mix(skyColor, horizonColor * 0.8, scatter * 0.15);

    gl_FragColor = vec4(skyColor, 1.0);
}`;

const skyUniforms = {
    topColor: { value: new THREE.Color(0x1a1535) },     // Dark blue-purple night sky
    midColor: { value: new THREE.Color(0x4a3055) },     // Muted purple
    bottomColor: { value: new THREE.Color(0xdd6030) },  // Warm orange horizon
    sunColor: { value: new THREE.Color(0xffcc55) },     // Golden sun
    sunDirection: { value: new THREE.Vector3(-0.5, 0.12, -0.85).normalize() },
    time: { value: 0.0 }
};
const skyGeo = new THREE.SphereGeometry(500, 64, 32);
const skyMat = new THREE.ShaderMaterial({
    vertexShader: skyVertexShader,
    fragmentShader: skyFragmentShader,
    uniforms: skyUniforms,
    side: THREE.BackSide
});
const sky = new THREE.Mesh(skyGeo, skyMat);
scene.add(sky);

// Sunset clouds - scattered wispy shapes
const cloudGroup = new THREE.Group();
for (let i = 0; i < 25; i++) {
    const cloudGeo = new THREE.PlaneGeometry(80 + Math.random() * 60, 15 + Math.random() * 20);
    const cloudMat = new THREE.MeshBasicMaterial({
        color: new THREE.Color().lerpColors(
            new THREE.Color(0xff4020),
            new THREE.Color(0xff8040),
            Math.random()
        ),
        transparent: true,
        opacity: 0.3 + Math.random() * 0.3,
        side: THREE.DoubleSide
    });
    const cloud = new THREE.Mesh(cloudGeo, cloudMat);
    const angle = Math.random() * Math.PI * 2;
    const height = 80 + Math.random() * 100;
    const dist = 200 + Math.random() * 200;
    cloud.position.set(
        Math.cos(angle) * dist,
        height,
        Math.sin(angle) * dist
    );
    cloud.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.3;
    cloud.rotation.z = Math.random() * Math.PI;
    cloud.lookAt(0, height, 0);
    cloudGroup.add(cloud);
}
scene.add(cloudGroup);

// Setting sun
const sunGeo = new THREE.SphereGeometry(25, 32, 32);
const sunMat = new THREE.MeshBasicMaterial({ color: 0xffdd44 });
const sun = new THREE.Mesh(sunGeo, sunMat);
sun.position.set(-200, 40, -350);
scene.add(sun);

// Sun glow - large orange halo
const sunGlowGeo = new THREE.SphereGeometry(60, 32, 32);
const sunGlowMat = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.25
});
const sunGlow = new THREE.Mesh(sunGlowGeo, sunGlowMat);
sunGlow.position.copy(sun.position);
scene.add(sunGlow);

// Outer sun glow
const sunGlow2Geo = new THREE.SphereGeometry(100, 32, 32);
const sunGlow2Mat = new THREE.MeshBasicMaterial({
    color: 0xff4400,
    transparent: true,
    opacity: 0.1
});
const sunGlow2 = new THREE.Mesh(sunGlow2Geo, sunGlow2Mat);
sunGlow2.position.copy(sun.position);
scene.add(sunGlow2);

// Warm sunset fog
scene.fog = new THREE.FogExp2(0x442020, 0.008);

const camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true, powerPreference: "high-performance" });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2.0)); // Higher quality
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap; // Soft shadows for better quality
renderer.shadowMap.autoUpdate = false; // Manual shadow update
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.0; // Natural exposure
renderer.physicallyCorrectLights = true; // PBR lighting
document.body.appendChild(renderer.domElement);

// POST-PROCESSING SETUP - ENHANCED GRAPHICS PIPELINE
const composer = new THREE.EffectComposer(renderer);

// Depth texture for depth-based effects
const depthTexture = new THREE.DepthTexture(window.innerWidth, window.innerHeight);
depthTexture.type = THREE.UnsignedShortType;
const depthRenderTarget = new THREE.WebGLRenderTarget(window.innerWidth, window.innerHeight, {
    minFilter: THREE.NearestFilter,
    magFilter: THREE.NearestFilter,
    format: THREE.RGBAFormat,
    depthTexture: depthTexture
});

const renderPass = new THREE.RenderPass(scene, camera);
composer.addPass(renderPass);

// God Rays - SUBTLE light shafts from sun
const godRaysPass = new THREE.ShaderPass(GodRaysShader);
godRaysPass.uniforms.exposure.value = 0.12;
godRaysPass.uniforms.decay.value = 0.94;
godRaysPass.uniforms.density.value = 0.4;
godRaysPass.uniforms.weight.value = 0.3;
godRaysPass.uniforms.samples.value = 40;
composer.addPass(godRaysPass);

// Lens Flare - SUBTLE
const lensFlarePass = new THREE.ShaderPass(LensFlareShader);
lensFlarePass.uniforms.flareStrength.value = 0.15;
lensFlarePass.uniforms.ghostStrength.value = 0.08;
lensFlarePass.uniforms.haloStrength.value = 0.05;
composer.addPass(lensFlarePass);

// Heat Distortion - VERY SUBTLE
const heatPass = new THREE.ShaderPass(HeatDistortionShader);
heatPass.uniforms.distortionStrength.value = 0.0008;
heatPass.uniforms.heatLine.value = 0.15;
composer.addPass(heatPass);

// Bloom for muzzle flash glow
const bloomPass = new THREE.UnrealBloomPass(
    new THREE.Vector2(window.innerWidth / 2, window.innerHeight / 2),
    0.15,  // strength - subtle
    0.4,   // radius
    0.85   // threshold
);
composer.addPass(bloomPass);

// Color Grading - DISABLED (was causing blue tint)
// const colorGradingPass = new THREE.ShaderPass(ColorGradingShader);
// composer.addPass(colorGradingPass);

// Motion Blur
const motionBlurPass = new THREE.ShaderPass(MotionBlurShader);
composer.addPass(motionBlurPass);

// Chromatic Aberration - SUBTLE
const chromaticPass = new THREE.ShaderPass(ChromaticAberrationShader);
chromaticPass.uniforms.amount.value = 0.0003;
composer.addPass(chromaticPass);

// Film Grain - SUBTLE
const grainPass = new THREE.ShaderPass(FilmGrainShader);
grainPass.uniforms.intensity.value = 0.025;
composer.addPass(grainPass);

// Vignette - DISABLED
// const vignettePass = new THREE.ShaderPass(VignetteShader);
// vignettePass.uniforms.intensity.value = 0.35;
// vignettePass.uniforms.smoothness.value = 0.5;
// composer.addPass(vignettePass);

// Sun screen position for god rays and lens flare (updated in animate loop)
let sunScreenPos = new THREE.Vector2(0.3, 0.7);
let sunVisible = 1.0;

// Create sunset environment map for reflections
const envMapSize = 256;
const envMapCanvas = document.createElement('canvas');
envMapCanvas.width = envMapCanvas.height = envMapSize;
const envCtx = envMapCanvas.getContext('2d');
const envGrad = envCtx.createLinearGradient(0, 0, 0, envMapSize);
envGrad.addColorStop(0, '#2a1030');   // Purple top
envGrad.addColorStop(0.4, '#ff6040'); // Orange mid
envGrad.addColorStop(1, '#ffaa60');   // Warm bottom
envCtx.fillStyle = envGrad;
envCtx.fillRect(0, 0, envMapSize, envMapSize);
const envMapTex = new THREE.CanvasTexture(envMapCanvas);
envMapTex.mapping = THREE.EquirectangularReflectionMapping;

// Warm ambient for sunset
const ambientLight = new THREE.AmbientLight(0xff9966, 0.5);
scene.add(ambientLight);

// Hemisphere light - orange sky, warm ground
const hemiLight = new THREE.HemisphereLight(0xff8844, 0x553322, 0.4);
scene.add(hemiLight);

// Sunlight - warm golden, coming from sun position
const dirLight = new THREE.DirectionalLight(0xffcc66, 1.5);
dirLight.position.set(-200, 40, -350); // Same as sun position
dirLight.castShadow = true;
dirLight.shadow.mapSize.width = 2048; dirLight.shadow.mapSize.height = 2048; // Higher resolution shadows
dirLight.shadow.bias = -0.0002;
dirLight.shadow.normalBias = 0.02;
dirLight.shadow.radius = 2; // Soft shadow blur
dirLight.shadow.camera.left = -100;
dirLight.shadow.camera.right = 100;
dirLight.shadow.camera.top = 100;
dirLight.shadow.camera.bottom = -100;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 600;
scene.add(dirLight);

// Purple-ish rim light from opposite side for contrast
// Subtle cool rim light for contrast (very low intensity)
const rimLight = new THREE.DirectionalLight(0x8888aa, 0.15);
rimLight.position.set(5, 2, 5);
scene.add(rimLight);

// Muzzle flash light
const muzzleLight = new THREE.PointLight(0xffaa00, 0, 30);
muzzleLight.castShadow = false;
scene.add(muzzleLight);

// Secondary fill light that follows camera for gun visibility (warm tint)
const gunFillLight = new THREE.PointLight(0xffaa77, 0.4, 15);
gunFillLight.position.set(0, -0.3, 0.5);
camera.add(gunFillLight);

// Initialize textures FIRST so they are available for everything
const concreteTex = TextureFactory.concrete();
const brickTex = TextureFactory.brick();
const woodTex = TextureFactory.wood();
const metalTexDark = TextureFactory.metal(true);
const metalTexLight = TextureFactory.metal(false);

// Concrete Floor (Bright)
const floorMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, 
    color: 0xdddddd, // Light grey
    roughness: 0.8, 
    metalness: 0.1,
    bumpMap: concreteTex,
    bumpScale: 0.05
});
const floor = new THREE.Mesh(new THREE.PlaneGeometry(400, 400), floorMat);
floor.rotation.x = -Math.PI / 2; floor.position.y = -5; floor.receiveShadow = true;
scene.add(floor);

// Walls (Concrete/Light Brick)
const wallMat = new THREE.MeshStandardMaterial({ 
    map: concreteTex, // Switched to concrete to match photo style
    color: 0xbbbbbb,
    roughness: 0.9, 
    bumpMap: concreteTex, 
    bumpScale: 0.1 
});
const wallGeo = new THREE.PlaneGeometry(400, 50);
const wall1 = new THREE.Mesh(wallGeo, wallMat); wall1.position.set(0, 20, -200); wall1.receiveShadow = true; scene.add(wall1);
const wall2 = new THREE.Mesh(wallGeo, wallMat); wall2.position.set(0, 20, 200); wall2.rotation.y = Math.PI; wall2.receiveShadow = true; scene.add(wall2);
const wall3 = new THREE.Mesh(wallGeo, wallMat); wall3.position.set(-200, 20, 0); wall3.rotation.y = Math.PI/2; wall3.receiveShadow = true; scene.add(wall3);
const wall4 = new THREE.Mesh(wallGeo, wallMat); wall4.position.set(200, 20, 0); wall4.rotation.y = -Math.PI/2; wall4.receiveShadow = true; scene.add(wall4);

const targets = [];
targets.push(floor, wall1, wall2, wall3, wall4);

// Better Obstacles
const barrierMat = new THREE.MeshStandardMaterial({ map: concreteTex, roughness: 0.8, color: 0xaaaaaa });
const drumMat = new THREE.MeshStandardMaterial({ map: metalTexDark, roughness: 0.4, metalness: 0.8, color: 0x553333 });
// Wood crates like the photo
const crateMat = new THREE.MeshStandardMaterial({ map: woodTex, color: 0x886644, roughness: 0.7 });
const obstacles = []; // Store obstacle references for target placement

for(let i=0; i<30; i++) {
    let mesh;
    const r = Math.random();
    if(r > 0.6) {
        // Wooden Crate
        mesh = new THREE.Mesh(new THREE.BoxGeometry(3, 3, 3), crateMat);
        mesh.position.y = -3.5;
    } else if (r > 0.3) {
        // Concrete Jersey Barrier
        mesh = new THREE.Mesh(new THREE.BoxGeometry(6, 2.5, 1), barrierMat);
        mesh.position.y = -3.75;
    } else {
        // Steel Drum
        mesh = new THREE.Mesh(new THREE.CylinderGeometry(1, 1, 3, 16), drumMat);
        mesh.position.y = -3.5;
    }
    mesh.position.x = (Math.random() - 0.5) * 150;
    mesh.position.z = (Math.random() - 0.5) * 150;
    mesh.rotation.y = Math.random() * Math.PI;
    mesh.castShadow = true; mesh.receiveShadow = true;
    scene.add(mesh);
    targets.push(mesh);
    obstacles.push(mesh); // Store for target placement
}

// SHOOTING TARGETS
const shootingTargets = [];

// Create target geometry (silhouette shape)
function createTargetMesh() {
    const group = new THREE.Group();

    // Head
    const headGeo = new THREE.CircleGeometry(0.8, 16);
    const targetMat = new THREE.MeshStandardMaterial({
        color: 0xff4444,
        roughness: 0.8,
        side: THREE.DoubleSide
    });
    const head = new THREE.Mesh(headGeo, targetMat);
    head.position.y = 3.2;
    group.add(head);

    // Body (torso)
    const bodyGeo = new THREE.PlaneGeometry(1.6, 2.4);
    const body = new THREE.Mesh(bodyGeo, targetMat);
    body.position.y = 1.6;
    group.add(body);

    // Base/stand
    const standMat = new THREE.MeshStandardMaterial({ color: 0x444444, roughness: 0.6 });
    const standGeo = new THREE.BoxGeometry(0.15, 4.4, 0.15);
    const stand = new THREE.Mesh(standGeo, standMat);
    stand.position.y = 2.0;
    stand.position.z = 0.15;
    group.add(stand);

    const baseGeo = new THREE.BoxGeometry(1.2, 0.15, 0.8);
    const base = new THREE.Mesh(baseGeo, standMat);
    base.position.y = -0.05;
    group.add(base);

    return group;
}

// Target class
class ShootingTarget {
    constructor(position) {
        this.mesh = createTargetMesh();
        this.mesh.position.copy(position);
        this.mesh.position.y = -5; // Ground level

        this.pivotPoint = new THREE.Group();
        this.pivotPoint.position.copy(this.mesh.position);
        this.pivotPoint.add(this.mesh);
        this.mesh.position.set(0, 0, 0);

        scene.add(this.pivotPoint);

        this.isUp = false;
        this.isAnimating = false;
        this.rotation = 0;
        this.targetRotation = Math.PI / 2; // Fallen state

        // Add hitbox to raycast targets
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4, 0.5),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2;
        this.pivotPoint.add(this.hitbox);
        this.hitbox.userData.isTarget = true;
        this.hitbox.userData.targetRef = this;
        targets.push(this.hitbox);
    }

    popup(obstacle) {
        if (this.isAnimating) return;
        this.isAnimating = true;

        // Position behind obstacle
        const pos = obstacle.position.clone();
        pos.x += (Math.random() - 0.5) * 2;
        pos.z += (Math.random() > 0.5 ? 2 : -2);
        this.pivotPoint.position.set(pos.x, -5, pos.z);
        this.pivotPoint.rotation.y = Math.atan2(
            camera.position.x - pos.x,
            camera.position.z - pos.z
        );

        // Animate up
        this.targetRotation = 0;
        this.isUp = true;
    }

    knockDown() {
        if (!this.isUp || this.isAnimating) return;
        this.isAnimating = true;
        this.targetRotation = Math.PI / 2;
        this.isUp = false;

        // Schedule popup at new location
        setTimeout(() => {
            if (obstacles.length > 0) {
                const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
                this.popup(randomObstacle);
            }
        }, 1500 + Math.random() * 2000);
    }

    update(dt) {
        // Smooth rotation animation
        const diff = this.targetRotation - this.rotation;
        if (Math.abs(diff) > 0.01) {
            this.rotation += diff * 8 * dt;
            this.pivotPoint.rotation.x = -this.rotation;
        } else {
            this.rotation = this.targetRotation;
            this.isAnimating = false;
        }
    }
}

// Create shooting targets
for (let i = 0; i < 8; i++) {
    const target = new ShootingTarget(new THREE.Vector3(0, -5, 0));
    shootingTargets.push(target);

    // Spawn at random obstacle after delay
    setTimeout(() => {
        if (obstacles.length > 0) {
            const randomObstacle = obstacles[Math.floor(Math.random() * obstacles.length)];
            target.popup(randomObstacle);
        }
    }, 1000 + i * 500);
}

// ZOMBIES
const zombies = [];

// Zombie materials - decayed greenish-grey skin
const zombieSkinMat = new THREE.MeshStandardMaterial({ color: 0x5a6b4a, roughness: 0.9 });
const zombieSkinDarkMat = new THREE.MeshStandardMaterial({ color: 0x3d4a35, roughness: 0.9 });

// Create tattered shirt texture
const shirtTexCanvas = document.createElement('canvas');
shirtTexCanvas.width = 256; shirtTexCanvas.height = 256;
const shirtTexCtx = shirtTexCanvas.getContext('2d');
// Base dirty brown/grey color
shirtTexCtx.fillStyle = '#3a3530';
shirtTexCtx.fillRect(0, 0, 256, 256);
// Add blood stains
shirtTexCtx.fillStyle = '#4a1515';
for (let i = 0; i < 8; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.arc(Math.random() * 256, Math.random() * 256, 15 + Math.random() * 30, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add tears/holes (dark spots)
shirtTexCtx.fillStyle = '#1a1a1a';
for (let i = 0; i < 5; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.ellipse(Math.random() * 256, Math.random() * 256, 8 + Math.random() * 15, 4 + Math.random() * 10, Math.random() * Math.PI, 0, Math.PI * 2);
    shirtTexCtx.fill();
}
// Add dirt streaks
shirtTexCtx.strokeStyle = '#2a2520';
shirtTexCtx.lineWidth = 3;
for (let i = 0; i < 10; i++) {
    shirtTexCtx.beginPath();
    shirtTexCtx.moveTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.lineTo(Math.random() * 256, Math.random() * 256);
    shirtTexCtx.stroke();
}
const shirtTex = new THREE.CanvasTexture(shirtTexCanvas);

const zombieShirtMat = new THREE.MeshStandardMaterial({ map: shirtTex, roughness: 0.8 });
const zombiePantsMat = new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.8 });

function createZombieMesh() {
    const group = new THREE.Group();
    const scale = 2.0;

    // Head - decayed zombie skin
    const head = new THREE.Mesh(new THREE.SphereGeometry(0.35 * scale, 12, 8), zombieSkinMat);
    head.position.y = 1.85 * scale;
    head.castShadow = true;
    group.add(head);

    // Torso - tattered bloody shirt
    const torso = new THREE.Mesh(new THREE.BoxGeometry(0.7 * scale, 0.9 * scale, 0.4 * scale), zombieShirtMat);
    torso.position.y = 1.1 * scale;
    torso.castShadow = true;
    group.add(torso);

    // Arms - zombie skin, arms extended forward
    const armGeo = new THREE.BoxGeometry(0.2 * scale, 0.7 * scale, 0.2 * scale);
    const leftArm = new THREE.Mesh(armGeo, zombieSkinMat);
    leftArm.position.set(-0.45 * scale, 1.3 * scale, 0.4 * scale);
    leftArm.rotation.x = -Math.PI / 3; // Arms reaching forward
    leftArm.castShadow = true;
    group.add(leftArm);

    const rightArm = new THREE.Mesh(armGeo, zombieSkinDarkMat);
    rightArm.position.set(0.45 * scale, 1.3 * scale, 0.4 * scale);
    rightArm.rotation.x = -Math.PI / 3;
    rightArm.castShadow = true;
    group.add(rightArm);

    // Legs - dirty dark pants
    const legGeo = new THREE.BoxGeometry(0.25 * scale, 0.8 * scale, 0.25 * scale);
    const leftLeg = new THREE.Mesh(legGeo, zombiePantsMat);
    leftLeg.position.set(-0.2 * scale, 0.4 * scale, 0);
    leftLeg.castShadow = true;
    group.add(leftLeg);

    const rightLeg = new THREE.Mesh(legGeo, zombiePantsMat);
    rightLeg.position.set(0.2 * scale, 0.4 * scale, 0);
    rightLeg.castShadow = true;
    group.add(rightLeg);

    return group;
}

class Zombie {
    constructor(x, z, waveNum = 1) {
        this.mesh = createZombieMesh();
        this.mesh.position.set(x, -5, z);
        scene.add(this.mesh);

        // Scale health and speed with wave
        const waveMod = 1 + (waveNum - 1) * 0.1;
        this.health = Math.floor(2 + Math.random() * 2 * waveMod);
        this.maxHealth = this.health;
        this.speed = 3 + Math.random() * 2 + waveNum * 0.3; // Faster each wave

        // State
        this.isDead = false;
        this.deathTime = 0;
        this.attackCooldown = 0;
        this.attackRange = 3.5; // Distance to damage player
        this.attackDamage = 10 + Math.floor(waveNum / 2) * 5; // More damage later waves

        // FLUID Animation state
        this.walkCycle = Math.random() * Math.PI * 2;
        this.swayOffset = Math.random() * Math.PI * 2;
        this.bobOffset = Math.random() * Math.PI * 2;
        this.limbPhase = Math.random() * Math.PI * 2;
        this.headBob = 0;
        this.bodyLean = 0;
        this.armSwing = 0;

        // Ragdoll parts (populated on death)
        this.ragdollParts = [];

        // Hitbox for raycasting
        this.hitbox = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 4.4, 1.0),
            new THREE.MeshBasicMaterial({ visible: false })
        );
        this.hitbox.position.y = 2.2;
        this.mesh.add(this.hitbox);
        this.hitbox.userData.isBot = true;
        this.hitbox.userData.botRef = this;
        targets.push(this.hitbox);
    }

    hit(hitPoint) {
        if (this.isDead) return;

        // Apply damage (boosted if power-up active)
        const damage = damageBoostTimer > 0 ? damageBoostMultiplier : 1;
        this.health -= damage;
        playSound('zombieHit');

        // Flinch reaction
        this.mesh.rotation.x = -0.2;

        // VIOLENT blood spray from hit point
        const bloodPos = hitPoint || this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        const bloodDir = new THREE.Vector3();
        bloodDir.subVectors(this.mesh.position, camera.position).normalize();
        spawnBloodSpray(bloodPos, bloodDir, this.health <= 0 ? 4 : 2); // More blood on every hit
        if (Math.random() > 0.5) {
            spawnGoreChunks(bloodPos, bloodDir); // Chance for gore on hits too
        }

        if (this.health <= 0) {
            this.die();
        }
    }

    die() {
        this.isDead = true;
        this.deathTime = performance.now();
        playSound('zombieDeath');

        // Award score
        addScore(100);
        zombiesKilledThisWave++;

        // Drops disabled for now
        // if (Math.random() < 0.2) {
        //     const dropTypes = ['ammo', 'ammo', 'ammo', 'health', 'speed', 'damage'];
        //     const dropType = dropTypes[Math.floor(Math.random() * dropTypes.length)];
        //     spawnPickup(dropType, this.mesh.position.x, this.mesh.position.z);
        // }

        // Remove hitbox from targets
        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);

        // Get direction from camera to zombie for death impulse
        const deathDir = new THREE.Vector3();
        deathDir.subVectors(this.mesh.position, camera.position).normalize();

        // VIOLENT Gore effects - extra blood and chunks
        const centerPos = this.mesh.position.clone().add(new THREE.Vector3(0, 2, 0));
        spawnGoreChunks(centerPos, deathDir);
        spawnGoreChunks(centerPos, deathDir); // Double gore
        spawnBloodSpray(centerPos, deathDir, 4); // Much more blood
        spawnBloodSpray(centerPos.clone().add(new THREE.Vector3(0, -0.5, 0)), deathDir, 3);
        spawnBloodPool(this.mesh.position.clone());
        spawnBloodPool(this.mesh.position.clone().add(new THREE.Vector3(Math.random() - 0.5, 0, Math.random() - 0.5)));

        // Detach each body part (skip hitbox at index 6)
        for (let i = 0; i < 6; i++) {
            const part = this.mesh.children[0];
            if (!part) continue;

            const partWorldPos = new THREE.Vector3();
            part.getWorldPosition(partWorldPos);

            this.mesh.remove(part);
            scene.add(part);
            part.position.copy(partWorldPos);

            // VIOLENT ragdoll - much more force
            const vel = new THREE.Vector3(
                (Math.random() - 0.5) * 15 + deathDir.x * 12,
                Math.random() * 10 + 5,
                (Math.random() - 0.5) * 15 + deathDir.z * 12
            );

            const rotVel = new THREE.Vector3(
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25,
                (Math.random() - 0.5) * 25
            );

            this.ragdollParts.push({
                mesh: part,
                velocity: vel,
                rotVelocity: rotVel,
                grounded: false,
                bleedTimer: 0,
                canBleed: true
            });
        }

        this.mesh.visible = false;
    }

    cleanup() {
        // Remove from scene completely
        for (const part of this.ragdollParts) {
            scene.remove(part.mesh);
        }
        this.ragdollParts = [];
        scene.remove(this.mesh);

        const idx = targets.indexOf(this.hitbox);
        if (idx > -1) targets.splice(idx, 1);
    }

    update(dt, time) {
        if (this.isDead) {
            // Update ragdoll physics
            const groundY = -4.8;
            const friction = 0.85;
            const bounciness = 0.3;

            for (const part of this.ragdollParts) {
                if (!part.grounded) {
                    part.velocity.y -= 25 * dt;
                    part.mesh.position.addScaledVector(part.velocity, dt);
                    part.mesh.rotation.x += part.rotVelocity.x * dt;
                    part.mesh.rotation.y += part.rotVelocity.y * dt;
                    part.mesh.rotation.z += part.rotVelocity.z * dt;

                    if (part.mesh.position.y < groundY) {
                        part.mesh.position.y = groundY;
                        if (Math.abs(part.velocity.y) > 1) {
                            part.velocity.y *= -bounciness;
                            part.velocity.x *= friction;
                            part.velocity.z *= friction;
                            part.rotVelocity.multiplyScalar(0.7);
                        } else {
                            part.velocity.set(0, 0, 0);
                            part.rotVelocity.multiplyScalar(0.9);
                            if (part.rotVelocity.length() < 0.1) {
                                part.grounded = true;
                            }
                        }
                    }
                    part.velocity.multiplyScalar(0.995);

                    if (part.canBleed) {
                        part.bleedTimer += dt;
                        if (part.bleedTimer > 0.08) {
                            part.bleedTimer = 0;
                            const dropMat = new THREE.SpriteMaterial({
                                map: bloodSpriteTex,
                                color: 0x880000,
                                transparent: true,
                                opacity: 0.9
                            });
                            const drop = new THREE.Sprite(dropMat);
                            drop.position.copy(part.mesh.position);
                            drop.scale.setScalar(0.1 + Math.random() * 0.1);
                            scene.add(drop);
                            bloodParticles.push({
                                mesh: drop,
                                velocity: new THREE.Vector3(
                                    (Math.random() - 0.5) * 0.5,
                                    -1,
                                    (Math.random() - 0.5) * 0.5
                                ),
                                life: 0.8,
                                gravity: 20,
                                type: 'droplet'
                            });
                        }
                    }
                } else if (part.canBleed) {
                    part.bleedTimer += dt;
                    if (part.bleedTimer > 2) {
                        part.canBleed = false;
                    }
                }
            }
            return;
        }

        // Recover from flinch
        this.mesh.rotation.x *= 0.9;

        // CHASE THE PLAYER
        const playerPos = camera.position;
        const dx = playerPos.x - this.mesh.position.x;
        const dz = playerPos.z - this.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        // Attack cooldown
        if (this.attackCooldown > 0) {
            this.attackCooldown -= dt;
        }

        // Attack if close enough
        if (dist < this.attackRange && this.attackCooldown <= 0) {
            this.attackCooldown = 1.0; // 1 second between attacks
            damagePlayer(this.attackDamage);
            playSound('zombieAttack');
        }

        // Move towards player
        if (dist > 1.5) {
            const moveX = (dx / dist) * this.speed * dt;
            const moveZ = (dz / dist) * this.speed * dt;
            this.mesh.position.x += moveX;
            this.mesh.position.z += moveZ;

            // Smooth face towards player
            const targetRot = Math.atan2(dx, dz);
            const rotDiff = targetRot - this.mesh.rotation.y;
            // Normalize angle difference
            const normalizedDiff = Math.atan2(Math.sin(rotDiff), Math.cos(rotDiff));
            this.mesh.rotation.y += normalizedDiff * 5 * dt; // Smooth turn

            // FLUID shambling walk animation
            const walkSpeed = this.speed * 1.2;
            this.walkCycle += dt * walkSpeed;
            this.limbPhase += dt * walkSpeed * 0.8; // Slightly offset phase

            const head = this.mesh.children[0];
            const torso = this.mesh.children[1];
            const leftArm = this.mesh.children[2];
            const rightArm = this.mesh.children[3];
            const leftLeg = this.mesh.children[4];
            const rightLeg = this.mesh.children[5];

            // Organic body vertical bob
            this.headBob = THREE.MathUtils.lerp(this.headBob, Math.sin(this.walkCycle * 2) * 0.08, 0.15);
            this.mesh.position.y = -5 + this.headBob;

            // Body lean into movement
            this.bodyLean = THREE.MathUtils.lerp(this.bodyLean, 0.15, 0.05);
            if (torso) {
                torso.rotation.x = this.bodyLean + Math.sin(this.walkCycle) * 0.05;
                torso.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.08;
            }

            // Head wobble
            if (head) {
                head.rotation.x = Math.sin(this.walkCycle * 2 + 0.5) * 0.1;
                head.rotation.z = Math.sin(this.walkCycle + this.swayOffset) * 0.12;
                head.rotation.y = Math.sin(this.walkCycle * 0.3) * 0.15;
            }

            // Fluid leg animation - bent knee shamble
            if (leftLeg && rightLeg) {
                const legSwing = 0.5;
                leftLeg.rotation.x = Math.sin(this.walkCycle) * legSwing;
                leftLeg.rotation.z = Math.sin(this.walkCycle * 0.5) * 0.1;
                rightLeg.rotation.x = Math.sin(this.walkCycle + Math.PI) * legSwing;
                rightLeg.rotation.z = Math.sin(this.walkCycle * 0.5 + Math.PI) * 0.1;
            }

            // Arms - reaching forward with organic sway
            this.armSwing = THREE.MathUtils.lerp(this.armSwing, Math.sin(this.limbPhase) * 0.2, 0.1);
            if (leftArm && rightArm) {
                // Base reaching pose with fluid motion
                leftArm.rotation.x = -Math.PI / 3 + this.armSwing + Math.sin(this.walkCycle * 0.7) * 0.15;
                leftArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.2 - 0.1;
                rightArm.rotation.x = -Math.PI / 3 - this.armSwing + Math.sin(this.walkCycle * 0.7 + Math.PI) * 0.15;
                rightArm.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset + Math.PI) * 0.2 + 0.1;
            }

            // Fluid body sway (drunk shamble)
            this.mesh.rotation.z = Math.sin(this.walkCycle * 0.5 + this.swayOffset) * 0.1;
            this.mesh.rotation.x = Math.sin(this.walkCycle + this.bobOffset) * 0.03;
        } else {
            // Idle sway when close
            this.mesh.rotation.z = Math.sin(time * 0.002 + this.swayOffset) * 0.05;
        }

        // Keep within bounds
        this.mesh.position.x = Math.max(-180, Math.min(180, this.mesh.position.x));
        this.mesh.position.z = Math.max(-180, Math.min(180, this.mesh.position.z));
    }
}

// WAVE SYSTEM
let currentWave = 0;
let zombiesThisWave = 0;
let zombiesKilledThisWave = 0;
let zombiesSpawnedThisWave = 0;
let waveInProgress = false;
let waveStartTime = 0;
let betweenWaves = true;
let nextWaveCountdown = 1; // Start fast

function startWave(waveNum) {
    currentWave = waveNum;
    zombiesThisWave = 8 + waveNum * 4; // More zombies: 12, 16, 20, 24...
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = true;
    betweenWaves = false;
    waveStartTime = performance.now();

    // Clear any remaining dead zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    updateHUD();
}

function spawnZombie() {
    if (zombiesSpawnedThisWave >= zombiesThisWave) return;

    // Spawn from edges, away from player
    const angle = Math.random() * Math.PI * 2;
    const distance = 60 + Math.random() * 40;
    const x = camera.position.x + Math.cos(angle) * distance;
    const z = camera.position.z + Math.sin(angle) * distance;

    // Clamp to arena bounds
    const clampedX = Math.max(-170, Math.min(170, x));
    const clampedZ = Math.max(-170, Math.min(170, z));

    zombies.push(new Zombie(clampedX, clampedZ, currentWave));
    zombiesSpawnedThisWave++;
}

function updateWaveSystem(dt) {
    if (betweenWaves) {
        nextWaveCountdown -= dt;
        if (nextWaveCountdown <= 0) {
            startWave(currentWave + 1);
        }
        return;
    }

    if (!waveInProgress) return;

    // Spawn zombies rapidly
    const timeSinceWaveStart = (performance.now() - waveStartTime) / 1000;
    const spawnInterval = Math.max(0.2, 0.8 - currentWave * 0.05); // Much faster spawns
    const shouldHaveSpawned = Math.floor(timeSinceWaveStart / spawnInterval) + 1;

    while (zombiesSpawnedThisWave < shouldHaveSpawned && zombiesSpawnedThisWave < zombiesThisWave) {
        spawnZombie();
    }

    // Check wave completion
    if (zombiesKilledThisWave >= zombiesThisWave) {
        waveInProgress = false;
        betweenWaves = true;
        nextWaveCountdown = 2; // Quick 2 seconds between waves

        // Bonus points for wave clear
        addScore(currentWave * 500);
        playSound('waveComplete');

        // Pickups disabled for now
    }
}

// PICKUP SYSTEM
const pickups = [];

// Power-up state
let speedBoostTimer = 0;
let damageBoostTimer = 0;
const speedBoostMultiplier = 1.8;
const damageBoostMultiplier = 2;

// Pickup types configuration
const PICKUP_TYPES = {
    ammo: { color: 0xffaa00, glowColor: 0xffcc00, height: 0.4, label: 'AMMO' },
    health: { color: 0x00ff00, glowColor: 0x44ff44, height: 0.5, label: '+HEALTH' },
    speed: { color: 0x00ffff, glowColor: 0x44ffff, height: 0.5, label: 'SPEED!' },
    damage: { color: 0xff0000, glowColor: 0xff4444, height: 0.5, label: '2X DAMAGE!' },
    nuke: { color: 0xff00ff, glowColor: 0xff44ff, height: 0.6, label: 'NUKE!' }
};

function createPickupMesh(type) {
    const config = PICKUP_TYPES[type];
    const group = new THREE.Group();

    if (type === 'ammo') {
        // Ammo box
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.8, 0.5, 0.5),
            new THREE.MeshStandardMaterial({ color: 0x4a3520, roughness: 0.6 })
        );
        box.castShadow = true;
        group.add(box);

        // Bullets on top
        for (let i = 0; i < 3; i++) {
            const bullet = new THREE.Mesh(
                new THREE.CylinderGeometry(0.05, 0.05, 0.25, 8),
                new THREE.MeshStandardMaterial({ color: 0xd4af37, metalness: 0.8, roughness: 0.2 })
            );
            bullet.position.set(-0.2 + i * 0.2, 0.35, 0);
            bullet.rotation.x = Math.PI / 2;
            group.add(bullet);
        }
    } else if (type === 'health') {
        // Medical box with cross
        const box = new THREE.Mesh(
            new THREE.BoxGeometry(0.7, 0.5, 0.7),
            new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
        );
        box.castShadow = true;
        group.add(box);

        // Red cross
        const crossH = new THREE.Mesh(
            new THREE.BoxGeometry(0.4, 0.1, 0.15),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossH.position.set(0, 0.26, 0);
        group.add(crossH);

        const crossV = new THREE.Mesh(
            new THREE.BoxGeometry(0.15, 0.1, 0.4),
            new THREE.MeshStandardMaterial({ color: 0xff0000, emissive: 0x440000 })
        );
        crossV.position.set(0, 0.26, 0);
        group.add(crossV);
    } else if (type === 'speed') {
        // Lightning bolt shape
        const shape = new THREE.Shape();
        shape.moveTo(0, 0.4);
        shape.lineTo(0.15, 0.1);
        shape.lineTo(0.05, 0.1);
        shape.lineTo(0.15, -0.4);
        shape.lineTo(-0.05, 0);
        shape.lineTo(0.05, 0);
        shape.lineTo(-0.1, 0.4);

        const extrudeSettings = { depth: 0.1, bevelEnabled: false };
        const boltGeo = new THREE.ExtrudeGeometry(shape, extrudeSettings);
        const bolt = new THREE.Mesh(
            boltGeo,
            new THREE.MeshStandardMaterial({ color: 0x00ffff, emissive: 0x004444, metalness: 0.5 })
        );
        bolt.rotation.y = Math.PI / 2;
        bolt.position.x = -0.05;
        group.add(bolt);
    } else if (type === 'damage') {
        // Skull shape (simplified)
        const skull = new THREE.Mesh(
            new THREE.SphereGeometry(0.3, 12, 10),
            new THREE.MeshStandardMaterial({ color: 0xff2200, emissive: 0x440000 })
        );
        skull.scale.y = 1.2;
        group.add(skull);

        // Eye sockets
        const eyeMat = new THREE.MeshStandardMaterial({ color: 0x000000 });
        const leftEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        leftEye.position.set(-0.1, 0.05, 0.25);
        group.add(leftEye);

        const rightEye = new THREE.Mesh(new THREE.SphereGeometry(0.08, 8, 8), eyeMat);
        rightEye.position.set(0.1, 0.05, 0.25);
        group.add(rightEye);
    } else if (type === 'nuke') {
        // Bomb/nuke shape
        const body = new THREE.Mesh(
            new THREE.SphereGeometry(0.35, 16, 12),
            new THREE.MeshStandardMaterial({ color: 0x222222, metalness: 0.8, roughness: 0.3 })
        );
        body.scale.y = 1.3;
        group.add(body);

        // Radiation symbol
        const symbolMat = new THREE.MeshStandardMaterial({ color: 0xff00ff, emissive: 0x440044 });
        const center = new THREE.Mesh(new THREE.CircleGeometry(0.08, 16), symbolMat);
        center.position.z = 0.36;
        group.add(center);

        // Fins
        for (let i = 0; i < 4; i++) {
            const fin = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.3, 0.02),
                new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.6 })
            );
            fin.position.set(0, -0.35, 0);
            fin.rotation.y = (i / 4) * Math.PI * 2;
            fin.position.x = Math.sin(fin.rotation.y) * 0.2;
            fin.position.z = Math.cos(fin.rotation.y) * 0.2;
            group.add(fin);
        }
    }

    return group;
}

class Pickup {
    constructor(type, x, z) {
        this.type = type;
        this.config = PICKUP_TYPES[type];
        this.mesh = createPickupMesh(type);
        this.mesh.position.set(x, -4.5 + this.config.height, z);
        scene.add(this.mesh);

        // Glow effect
        const glowGeo = new THREE.SphereGeometry(0.8, 16, 16);
        const glowMat = new THREE.MeshBasicMaterial({
            color: this.config.glowColor,
            transparent: true,
            opacity: 0.15
        });
        this.glow = new THREE.Mesh(glowGeo, glowMat);
        this.mesh.add(this.glow);

        // Point light for visibility in the dark
        this.light = new THREE.PointLight(this.config.glowColor, 0.8, 8);
        this.light.position.set(0, 0.5, 0);
        this.mesh.add(this.light);

        this.bobOffset = Math.random() * Math.PI * 2;
        this.lifeTime = 30; // Despawn after 30 seconds
        this.collected = false;
    }

    update(dt, time) {
        if (this.collected) return true;

        // Bob and rotate
        this.mesh.position.y = -4.5 + this.config.height + Math.sin(time * 0.003 + this.bobOffset) * 0.15;
        this.mesh.rotation.y += dt * 2;

        // Pulse glow
        this.glow.material.opacity = 0.1 + Math.sin(time * 0.005) * 0.05;
        this.light.intensity = 0.6 + Math.sin(time * 0.005) * 0.3;

        // Check pickup collision with player
        const dx = camera.position.x - this.mesh.position.x;
        const dz = camera.position.z - this.mesh.position.z;
        const dist = Math.sqrt(dx * dx + dz * dz);

        if (dist < 2.5) {
            this.collect();
            return true;
        }

        // Lifetime
        this.lifeTime -= dt;
        if (this.lifeTime <= 0) {
            this.remove();
            return true;
        }

        // Flicker when about to despawn
        if (this.lifeTime < 5) {
            this.mesh.visible = Math.sin(time * 0.02) > 0;
        }

        return false;
    }

    collect() {
        this.collected = true;
        playSound('pickup');

        // Show floating text
        showPickupText(this.config.label, this.config.color);

        // Apply effect based on type
        switch (this.type) {
            case 'ammo':
                reserve = Math.min(reserve + 60, 300);
                addScore(50);
                break;

            case 'health':
                playerHealth = Math.min(playerHealth + 50, maxPlayerHealth);
                addScore(50);
                break;

            case 'speed':
                speedBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'damage':
                damageBoostTimer = 10; // 10 seconds
                addScore(100);
                break;

            case 'nuke':
                // Kill all zombies!
                for (const zombie of zombies) {
                    if (!zombie.isDead) {
                        zombie.die();
                    }
                }
                addScore(500);
                playSound('nuke');
                // Screen flash
                damageFlashIntensity = 1.0;
                document.getElementById('damage-flash').style.background =
                    'radial-gradient(ellipse at center, rgba(255,255,255,0.8) 0%, rgba(255,0,255,0.4) 100%)';
                setTimeout(() => {
                    document.getElementById('damage-flash').style.background =
                        'radial-gradient(ellipse at center, transparent 0%, rgba(255,0,0,0.4) 100%)';
                }, 300);
                break;
        }

        updateHUD();
        this.remove();
    }

    remove() {
        scene.remove(this.mesh);
    }
}

function spawnPickup(type, x, z) {
    // Clamp to arena
    x = Math.max(-170, Math.min(170, x));
    z = Math.max(-170, Math.min(170, z));
    pickups.push(new Pickup(type, x, z));
}

function updatePickups(dt, time) {
    // Update existing pickups
    for (let i = pickups.length - 1; i >= 0; i--) {
        if (pickups[i].update(dt, time)) {
            pickups.splice(i, 1);
        }
    }

    // Pickups disabled for now
    // if (waveInProgress && Math.random() < 0.001) {
    //     const types = ['ammo', 'ammo', 'health', 'speed', 'damage'];
    //     const type = types[Math.floor(Math.random() * types.length)];
    //     const angle = Math.random() * Math.PI * 2;
    //     const dist = 20 + Math.random() * 40;
    //     spawnPickup(type, camera.position.x + Math.cos(angle) * dist, camera.position.z + Math.sin(angle) * dist);
    // }
}

// Floating pickup text
let pickupTextTimeout = null;
function showPickupText(text, color) {
    let textEl = document.getElementById('pickup-text');
    if (!textEl) {
        textEl = document.createElement('div');
        textEl.id = 'pickup-text';
        textEl.style.cssText = `
            position: absolute; top: 40%; left: 50%; transform: translateX(-50%);
            font-size: 32px; font-weight: bold; pointer-events: none;
            text-shadow: 0 0 10px currentColor, 0 0 20px currentColor;
            transition: opacity 0.3s, top 0.5s;
        `;
        document.body.appendChild(textEl);
    }

    textEl.textContent = text;
    textEl.style.color = '#' + color.toString(16).padStart(6, '0');
    textEl.style.opacity = '1';
    textEl.style.top = '40%';

    if (pickupTextTimeout) clearTimeout(pickupTextTimeout);
    pickupTextTimeout = setTimeout(() => {
        textEl.style.opacity = '0';
        textEl.style.top = '35%';
    }, 1000);
}

// BLOOD & GORE SYSTEM
const bloodParticles = [];
const goreChunks = [];
const bloodDecals = [];
const bloodPools = [];

// Blood splatter texture (procedural)
const bloodTexCanvas = document.createElement('canvas');
bloodTexCanvas.width = 64; bloodTexCanvas.height = 64;
const bloodCtx = bloodTexCanvas.getContext('2d');
const bloodGrad = bloodCtx.createRadialGradient(32, 32, 0, 32, 32, 32);
bloodGrad.addColorStop(0, 'rgba(180, 0, 0, 1)');
bloodGrad.addColorStop(0.3, 'rgba(120, 0, 0, 0.8)');
bloodGrad.addColorStop(0.7, 'rgba(80, 0, 0, 0.4)');
bloodGrad.addColorStop(1, 'rgba(40, 0, 0, 0)');
bloodCtx.fillStyle = bloodGrad;
bloodCtx.fillRect(0, 0, 64, 64);
const bloodSpriteTex = new THREE.CanvasTexture(bloodTexCanvas);

// Blood mist texture
const mistTexCanvas = document.createElement('canvas');
mistTexCanvas.width = 128; mistTexCanvas.height = 128;
const mistCtx = mistTexCanvas.getContext('2d');
const mistGrad = mistCtx.createRadialGradient(64, 64, 0, 64, 64, 64);
mistGrad.addColorStop(0, 'rgba(150, 0, 0, 0.6)');
mistGrad.addColorStop(0.5, 'rgba(100, 0, 0, 0.3)');
mistGrad.addColorStop(1, 'rgba(60, 0, 0, 0)');
mistCtx.fillStyle = mistGrad;
mistCtx.fillRect(0, 0, 128, 128);
const bloodMistTex = new THREE.CanvasTexture(mistTexCanvas);

// Blood decal texture (splatter pattern)
const bloodDecalCanvas = document.createElement('canvas');
bloodDecalCanvas.width = 256; bloodDecalCanvas.height = 256;
const decalCtx = bloodDecalCanvas.getContext('2d');
decalCtx.fillStyle = 'rgba(0,0,0,0)';
decalCtx.fillRect(0, 0, 256, 256);
// Main splat
decalCtx.beginPath();
decalCtx.arc(128, 128, 60 + Math.random() * 20, 0, Math.PI * 2);
decalCtx.fillStyle = 'rgba(100, 0, 0, 0.9)';
decalCtx.fill();
// Splatter droplets
for (let i = 0; i < 30; i++) {
    const angle = Math.random() * Math.PI * 2;
    const dist = 40 + Math.random() * 80;
    const x = 128 + Math.cos(angle) * dist;
    const y = 128 + Math.sin(angle) * dist;
    const r = 3 + Math.random() * 12;
    decalCtx.beginPath();
    decalCtx.arc(x, y, r, 0, Math.PI * 2);
    decalCtx.fillStyle = `rgba(${80 + Math.random() * 40}, 0, 0, ${0.6 + Math.random() * 0.4})`;
    decalCtx.fill();
}
// Streaks
for (let i = 0; i < 15; i++) {
    const angle = Math.random() * Math.PI * 2;
    decalCtx.beginPath();
    decalCtx.moveTo(128, 128);
    const len = 50 + Math.random() * 70;
    decalCtx.lineTo(128 + Math.cos(angle) * len, 128 + Math.sin(angle) * len);
    decalCtx.strokeStyle = `rgba(90, 0, 0, ${0.5 + Math.random() * 0.3})`;
    decalCtx.lineWidth = 2 + Math.random() * 4;
    decalCtx.stroke();
}
const bloodDecalTex = new THREE.CanvasTexture(bloodDecalCanvas);

// Gore materials
const goreMat = new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.6 });
const boneMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.4 });
const organMat = new THREE.MeshStandardMaterial({ color: 0x4a0000, roughness: 0.7 });

// Pre-create blood sprite materials (avoid runtime allocation)
const bloodSpriteMats = [];
for (let i = 0; i < 40; i++) {
    bloodSpriteMats.push(new THREE.SpriteMaterial({
        map: bloodSpriteTex,
        color: new THREE.Color(0.5 + Math.random() * 0.3, 0, 0),
        transparent: true,
        opacity: 0.8,
        depthWrite: false
    }));
}
let bloodMatIdx = 0;

// Blood sprite pool
const bloodSpritePool = new ObjectPool(
    () => { const s = new THREE.Sprite(bloodSpriteMats[0]); s.visible = false; return s; },
    (s) => { s.visible = false; },
    MAX_BLOOD_PARTICLES
);

// Reusable vector for blood spray
const _bloodVel = new THREE.Vector3();

// Blood spray on hit - VIOLENT
function spawnBloodSpray(position, direction, intensity = 1) {
    const count = Math.floor(10 * intensity); // More blood

    // Blood droplets
    for (let i = 0; i < count; i++) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.1 + Math.random() * 0.15);
        sprite.visible = true;

        // VIOLENT blood spray velocity
        _bloodVel.copy(direction).multiplyScalar(6 + Math.random() * 10);
        _bloodVel.x += (Math.random() - 0.5) * 8;
        _bloodVel.y += Math.random() * 6;
        _bloodVel.z += (Math.random() - 0.5) * 8;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: _bloodVel.clone(),
            life: 1.0 + Math.random() * 0.5,
            gravity: 15,
            type: 'droplet'
        });
    }

    // Light blood mist (only on major hits, reuse material)
    if (intensity > 1.5) {
        const sprite = bloodSpritePool.get();
        sprite.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
        sprite.position.copy(position);
        sprite.scale.setScalar(0.5);
        sprite.visible = true;

        scene.add(sprite);
        bloodParticles.push({
            mesh: sprite,
            velocity: direction.clone().multiplyScalar(2),
            life: 0.4,
            gravity: 0,
            type: 'mist',
            initialScale: 0.5
        });
    }
}

// Spawn gore chunks on death - VIOLENT
function spawnGoreChunks(position, direction) {
    const chunkCount = 6 + Math.floor(Math.random() * 4); // More chunks

    for (let i = 0; i < chunkCount; i++) {
        let geo, mat;
        const type = Math.random();

        if (type < 0.6) {
            // Small meat chunk
            geo = new THREE.DodecahedronGeometry(0.08 + Math.random() * 0.08);
            mat = goreMat.clone();
        } else {
            // Bone fragment
            geo = new THREE.BoxGeometry(0.04, 0.12, 0.04);
            mat = boneMat.clone();
        }

        const chunk = new THREE.Mesh(geo, mat);
        chunk.position.copy(position);
        chunk.position.add(new THREE.Vector3(
            (Math.random() - 0.5) * 0.5,
            Math.random() * 0.5,
            (Math.random() - 0.5) * 0.5
        ));
        chunk.castShadow = true;

        // VIOLENT - explosive chunk velocity
        const vel = direction.clone().multiplyScalar(8 + Math.random() * 10);
        vel.add(new THREE.Vector3(
            (Math.random() - 0.5) * 12,
            Math.random() * 8 + 4,
            (Math.random() - 0.5) * 12
        ));

        const rotVel = new THREE.Vector3(
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30,
            (Math.random() - 0.5) * 30
        );

        scene.add(chunk);
        goreChunks.push({
            mesh: chunk,
            velocity: vel,
            rotVelocity: rotVel,
            life: 6 + Math.random() * 3,
            grounded: false,
            canBleed: Math.random() > 0.7,
            bleedTimer: 0
        });
    }
}

// Spawn blood decal on surface
function spawnBloodDecal(position, normal, size = 1) {
    const decalMat = new THREE.MeshBasicMaterial({
        map: bloodDecalTex,
        transparent: true,
        opacity: 0.85,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -2
    });

    const decalSize = (1.5 + Math.random() * 1.5) * size;
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(decalSize, decalSize), decalMat);
    decal.position.copy(position);
    decal.position.y = -4.95; // Just above floor
    decal.rotation.x = -Math.PI / 2;
    decal.rotation.z = Math.random() * Math.PI * 2;

    scene.add(decal);
    bloodDecals.push({
        mesh: decal,
        life: 600 + Math.random() * 300
    });
}

// Spawn expanding blood pool under body
function spawnBloodPool(position) {
    const poolMat = new THREE.MeshBasicMaterial({
        color: 0x3a0000,
        transparent: true,
        opacity: 0.9,
        depthWrite: false,
        polygonOffset: true,
        polygonOffsetFactor: -1
    });

    const pool = new THREE.Mesh(new THREE.CircleGeometry(0.1, 16), poolMat);
    pool.position.copy(position);
    pool.position.y = -4.98;
    pool.rotation.x = -Math.PI / 2;

    scene.add(pool);
    bloodPools.push({
        mesh: pool,
        targetSize: 2.0 + Math.random() * 1.5, // Bigger pools
        currentSize: 0.1,
        growthRate: 1.0 + Math.random() * 0.5, // Faster growth
        life: 500 + Math.random() * 300
    });
}

// Reusable normal vector for decals
const _upNormal = new THREE.Vector3(0, 1, 0);

// Update blood particle systems (optimized with swap-and-pop)
function updateBloodEffects(dt) {
    // Update blood particles
    for (let i = bloodParticles.length - 1; i >= 0; i--) {
        const p = bloodParticles[i];
        p.life -= dt;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodSpritePool.release(p.mesh);
            bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
            bloodParticles.pop();
            continue;
        }

        if (p.type === 'droplet') {
            p.velocity.y -= p.gravity * dt;
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.mesh.material.opacity = Math.min(1, p.life);

            // Hit ground
            if (p.mesh.position.y < -4.8) {
                if (Math.random() > 0.8) { // Reduced decal spawns
                    spawnBloodDecal(p.mesh.position.clone(), _upNormal, 0.3);
                }
                scene.remove(p.mesh);
                bloodSpritePool.release(p.mesh);
                bloodParticles[i] = bloodParticles[bloodParticles.length - 1];
                bloodParticles.pop();
            }
        } else if (p.type === 'mist') {
            p.mesh.position.addScaledVector(p.velocity, dt);
            p.velocity.multiplyScalar(0.95);
            p.mesh.scale.setScalar(p.initialScale * (1 + (1 - p.life) * 3));
            p.mesh.material.opacity = p.life * 0.5;
        }
    }

    // Update gore chunks
    for (let i = goreChunks.length - 1; i >= 0; i--) {
        const g = goreChunks[i];
        g.life -= dt;

        if (g.life <= 0) {
            scene.remove(g.mesh);
            goreChunks[i] = goreChunks[goreChunks.length - 1];
            goreChunks.pop();
            continue;
        }

        if (!g.grounded) {
            g.velocity.y -= 20 * dt;
            g.mesh.position.addScaledVector(g.velocity, dt);
            g.mesh.rotation.x += g.rotVelocity.x * dt;
            g.mesh.rotation.y += g.rotVelocity.y * dt;
            g.mesh.rotation.z += g.rotVelocity.z * dt;

            if (g.mesh.position.y < -4.7) {
                g.mesh.position.y = -4.7;
                if (Math.abs(g.velocity.y) > 2) {
                    g.velocity.y *= -0.3;
                    g.velocity.x *= 0.7;
                    g.velocity.z *= 0.7;
                    g.rotVelocity.multiplyScalar(0.5);
                    if (Math.random() > 0.5) { // Reduced decal spawns
                        spawnBloodDecal(g.mesh.position.clone(), _upNormal, 0.4);
                    }
                } else {
                    g.grounded = true;
                    g.velocity.set(0, 0, 0);
                }
            }
        }

        // Bleeding effect (reduced frequency, uses pooled sprites)
        if (g.canBleed && !g.grounded) {
            g.bleedTimer += dt;
            if (g.bleedTimer > 0.1) { // Reduced from 0.05
                g.bleedTimer = 0;
                const drop = bloodSpritePool.get();
                drop.material = bloodSpriteMats[bloodMatIdx++ % bloodSpriteMats.length];
                drop.position.copy(g.mesh.position);
                drop.scale.setScalar(0.08);
                drop.visible = true;
                scene.add(drop);
                bloodParticles.push({
                    mesh: drop,
                    velocity: new THREE.Vector3(0, 0, 0),
                    life: 0.6,
                    gravity: 25,
                    type: 'droplet'
                });
            }
        }

        if (g.life < 2) {
            g.mesh.material.opacity = g.life / 2;
            g.mesh.material.transparent = true;
        }
    }

    // Update blood pools
    for (let i = bloodPools.length - 1; i >= 0; i--) {
        const p = bloodPools[i];
        p.life -= 1;

        if (p.life <= 0) {
            scene.remove(p.mesh);
            bloodPools[i] = bloodPools[bloodPools.length - 1];
            bloodPools.pop();
            continue;
        }

        if (p.currentSize < p.targetSize) {
            p.currentSize += p.growthRate * dt;
            p.mesh.scale.setScalar(p.currentSize);
        }

        if (p.life < 100) {
            p.mesh.material.opacity = (p.life / 100) * 0.9;
        }
    }

    // Update blood decals
    for (let i = bloodDecals.length - 1; i >= 0; i--) {
        const d = bloodDecals[i];
        d.life -= 1;

        if (d.life <= 0) {
            scene.remove(d.mesh);
            bloodDecals[i] = bloodDecals[bloodDecals.length - 1];
            bloodDecals.pop();
            continue;
        }

        if (d.life < 100) {
            d.mesh.material.opacity = (d.life / 100) * 0.85;
        }
    }
}

// ATMOSPHERIC DUST PARTICLES (reduced for performance)
const dustParticles = [];
const dustGeo = new THREE.BufferGeometry();
const dustCount = 200; // Reduced from 500
const dustPositions = new Float32Array(dustCount * 3);
for(let i = 0; i < dustCount; i++) {
    dustPositions[i * 3] = (Math.random() - 0.5) * 200;
    dustPositions[i * 3 + 1] = Math.random() * 30 - 5;
    dustPositions[i * 3 + 2] = (Math.random() - 0.5) * 200;
}
dustGeo.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));
const dustMat = new THREE.PointsMaterial({
    color: 0xeebb88, // Warm dust
    size: 0.12,
    transparent: true,
    opacity: 0.3,
    blending: THREE.AdditiveBlending,
    depthWrite: false,
    sizeAttenuation: true
});
const dustCloud = new THREE.Points(dustGeo, dustMat);
scene.add(dustCloud);

/**
 * GUN CONSTRUCTION
 */
const gunGroup = new THREE.Group();
const recoilGroup = new THREE.Group();
recoilGroup.add(gunGroup);

// Enhanced gun materials with environment reflections
const woodMat = new THREE.MeshStandardMaterial({
    map: woodTex,
    roughness: 0.45,
    metalness: 0.05,
    bumpMap: woodTex,
    bumpScale: 0.03,
    envMap: envMapTex,
    envMapIntensity: 0.15
});

const metalMat = new THREE.MeshStandardMaterial({
    map: metalTexLight,
    color: 0xdddddd,
    roughness: 0.25,
    metalness: 0.95,
    bumpMap: metalTexLight,
    bumpScale: 0.008,
    envMap: envMapTex,
    envMapIntensity: 0.6
});

const darkMetalMat = new THREE.MeshStandardMaterial({
    map: metalTexDark,
    color: 0x1a1a1a,
    roughness: 0.5,
    metalness: 0.7,
    bumpMap: metalTexDark,
    bumpScale: 0.01,
    envMap: envMapTex,
    envMapIntensity: 0.3
});

const receiver = new THREE.Mesh(new THREE.BoxGeometry(0.8, 1, 4), darkMetalMat);
receiver.castShadow = true; gunGroup.add(receiver);

const dustCover = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.4, 4, 16, 1, false, 0, Math.PI), darkMetalMat);
dustCover.rotation.set(Math.PI/2, Math.PI/2, 0); dustCover.position.y = 0.5; dustCover.castShadow = true; gunGroup.add(dustCover);

const stock = new THREE.Mesh(new THREE.BoxGeometry(0.7, 1.2, 3), woodMat);
stock.position.set(0, -0.5, 3.5); stock.rotation.x = 0.2; stock.castShadow = true; gunGroup.add(stock);

const barrel = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.12, 6, 12), metalMat);
barrel.rotation.x = Math.PI / 2; barrel.position.set(0, 0.3, -4); barrel.castShadow = true; gunGroup.add(barrel);

const gasTube = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 3, 12), metalMat);
gasTube.rotation.x = Math.PI / 2; gasTube.position.set(0, 0.7, -3); gunGroup.add(gasTube);

const handguard = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.8, 2.5), woodMat);
handguard.position.set(0, 0.2, -3); handguard.castShadow = true; gunGroup.add(handguard);

const grip = new THREE.Mesh(new THREE.BoxGeometry(0.6, 1.5, 0.8), woodMat);
grip.position.set(0, -1, 0.5); grip.rotation.x = -0.3; grip.castShadow = true; gunGroup.add(grip);

// Sights
const frontSight = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.8, 0.2), darkMetalMat);
frontSight.position.set(0, 0.8, -6.5); frontSight.castShadow = true; gunGroup.add(frontSight);

const rearSightBase = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.3, 0.8), darkMetalMat);
rearSightBase.position.set(0, 0.9, -1.0); gunGroup.add(rearSightBase);
const rearSightL = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightL.position.set(-0.15, 1.1, -1.0); gunGroup.add(rearSightL);
const rearSightR = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.3, 0.1), darkMetalMat);
rearSightR.position.set(0.15, 1.1, -1.0); gunGroup.add(rearSightR);

const bolt = new THREE.Mesh(new THREE.BoxGeometry(0.25, 0.25, 0.6), metalMat);
bolt.position.set(0.5, 0.4, -0.5); bolt.castShadow = true; gunGroup.add(bolt);

// Magazine Pivot Group (For cooler reloading arcs)
const magPivot = new THREE.Group();
magPivot.position.set(0, -0.5, -1);
gunGroup.add(magPivot);

const magGeo = new THREE.BoxGeometry(0.6, 2.5, 1.2);
const magCurve = new THREE.Mesh(magGeo, metalMat);
magCurve.rotation.x = 0.4; magCurve.position.y = -1.2; magCurve.castShadow = true;
magPivot.add(magCurve);

// ENHANCED MUZZLE FLASH VFX
const flashGroup = new THREE.Group();

// Core flash (bright white center)
const flashCoreMat = new THREE.MeshBasicMaterial({
    color: 0xffffff, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
const flashCore = new THREE.Mesh(new THREE.PlaneGeometry(0.8, 0.8), flashCoreMat);
flashGroup.add(flashCore);

// Mid flash (orange/yellow)
const flashMidMat = new THREE.MeshBasicMaterial({
    color: 0xffaa44, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<4; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.5), flashMidMat);
    f.rotation.z = (Math.PI / 4) * i;
    flashGroup.add(f);
}

// Outer flash (red/orange glow)
const flashOuterMat = new THREE.MeshBasicMaterial({
    color: 0xff6622, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<6; i++) {
    const f = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 2.5), flashOuterMat);
    f.rotation.z = (Math.PI / 3) * i;
    flashGroup.add(f);
}

// Flash streaks (elongated for directional feel)
const flashStreakMat = new THREE.MeshBasicMaterial({
    color: 0xffcc66, transparent: true, opacity: 0,
    depthWrite: false, blending: THREE.AdditiveBlending
});
for(let i=0; i<3; i++) {
    const streak = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 3.0), flashStreakMat);
    streak.rotation.z = (Math.PI / 3) * i + Math.PI/6;
    streak.position.z = -0.5;
    flashGroup.add(streak);
}

flashGroup.position.set(0, 0.3, -7.2);
gunGroup.add(flashGroup);

// Legacy reference for compatibility
const flashMat = flashMidMat;

// Camera Rig
const hipPos = new THREE.Vector3(0.9, -1.1, -1.8);
const aimPos = new THREE.Vector3(0.0, -1.22, -0.5);
recoilGroup.position.copy(hipPos);
recoilGroup.rotation.y = Math.PI; 
camera.add(recoilGroup);
scene.add(camera);

/**
 * ENHANCED PARTICLE SYSTEMS
 */

// Improved Smoke with object pooling
const smokeParticles = [];
const smokeTexCanvas = document.createElement('canvas'); smokeTexCanvas.width = 64; smokeTexCanvas.height = 64; // Reduced size
const stx = smokeTexCanvas.getContext('2d');
const sGrad = stx.createRadialGradient(32,32,0,32,32,32);
sGrad.addColorStop(0, 'rgba(200,200,200,0.6)');
sGrad.addColorStop(0.4, 'rgba(150,150,150,0.3)');
sGrad.addColorStop(1, 'rgba(100,100,100,0)');
stx.fillStyle = sGrad; stx.fillRect(0,0,64,64);
const smokeSpriteTex = new THREE.CanvasTexture(smokeTexCanvas);

// Pre-create smoke sprite materials (no cloning needed)
const smokeMats = [];
const hotSmokeMats = [];
for (let i = 0; i < 20; i++) {
    smokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0x888888, transparent: true,
        blending: THREE.NormalBlending, depthWrite: false
    }));
    hotSmokeMats.push(new THREE.SpriteMaterial({
        map: smokeSpriteTex, color: 0xffaa66, transparent: true,
        blending: THREE.AdditiveBlending, depthWrite: false
    }));
}
let smokeMatIdx = 0;
let hotSmokeMatIdx = 0;

// Object pool for smoke sprites
const smokePool = new ObjectPool(
    () => new THREE.Sprite(smokeMats[0]),
    (s) => { s.visible = false; s.scale.setScalar(0.4); }
);

// Reusable vectors for smoke spawning
const _smokeSpawnPos = new THREE.Vector3(0, 0.3, -7.5);
const _smokeVel = new THREE.Vector3();
const _smokeQuat = new THREE.Quaternion();

function spawnSmoke() {
    const basePos = _smokeSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    gunGroup.getWorldQuaternion(_smokeQuat);

    // Hot smoke near muzzle (reduced count)
    for(let i=0; i<1; i++) {
        const s = smokePool.get();
        s.material = hotSmokeMats[hotSmokeMatIdx++ % hotSmokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.3 + Math.random() * 0.3);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.5; _smokeVel.y += Math.random()*0.3; _smokeVel.z += (Math.random()-0.5)*0.5;
        _smokeVel.multiplyScalar(3 + Math.random()*2);
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 0.4 + Math.random()*0.3, hot: true });
    }
    // Regular smoke (reduced count)
    for(let i=0; i<2; i++) {
        const s = smokePool.get();
        s.material = smokeMats[smokeMatIdx++ % smokeMats.length];
        s.position.copy(basePos);
        s.scale.setScalar(0.4 + Math.random() * 0.4);
        s.visible = true;
        _smokeVel.set(0, 0, -1).applyQuaternion(_smokeQuat);
        _smokeVel.x += (Math.random()-0.5)*0.4; _smokeVel.y += Math.random()*0.6; _smokeVel.z += (Math.random()-0.5)*0.4;
        _smokeVel.multiplyScalar(1.5 + Math.random());
        scene.add(s);
        smokeParticles.push({ mesh: s, velocity: _smokeVel.clone(), age: 0, life: 1.0 + Math.random()*0.5, hot: false });
    }
}

// SPARK PARTICLES - pooled for performance
const sparks = [];
const sparkGeo = new THREE.SphereGeometry(0.02, 3, 3); // Reduced geometry complexity
const sparkBaseMat = new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending });

// Pre-create spark materials
const sparkMats = [];
for (let i = 0; i < 30; i++) {
    sparkMats.push(new THREE.MeshBasicMaterial({ color: 0xffdd44, transparent: true, blending: THREE.AdditiveBlending }));
}
let sparkMatIdx = 0;

// Object pool for sparks
const sparkPool = new ObjectPool(
    () => { const m = new THREE.Mesh(sparkGeo, sparkMats[0]); m.visible = false; return m; },
    (s) => { s.visible = false; },
    MAX_SPARKS
);

const _sparkSpawnPos = new THREE.Vector3(0, 0.3, -7.5);

function spawnMuzzleSparks() {
    const basePos = _sparkSpawnPos.clone().applyMatrix4(gunGroup.matrixWorld);
    for(let i=0; i<5; i++) { // Reduced from 8
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(basePos);
        spark.visible = true;
        _tempVec3.set((Math.random()-0.5) * 8, Math.random() * 4, -Math.random() * 15);
        _tempVec3.applyQuaternion(camera.quaternion);
        spark.userData = { velocity: _tempVec3.clone(), life: 0.15 + Math.random()*0.2 };
        scene.add(spark);
        sparks.push(spark);
    }
}

function spawnImpactSparks(point, normal) {
    for(let i=0; i<8; i++) { // Reduced from 12
        const spark = sparkPool.get();
        spark.material = sparkMats[sparkMatIdx++ % sparkMats.length];
        spark.position.copy(point);
        spark.visible = true;
        _tempVec3.copy(normal).multiplyScalar(5 + Math.random()*10);
        _tempVec3.x += (Math.random()-0.5) * 8;
        _tempVec3.y += Math.random() * 5;
        _tempVec3.z += (Math.random()-0.5) * 8;
        spark.userData = { velocity: _tempVec3.clone(), life: 0.2 + Math.random()*0.3 };
        scene.add(spark);
        sparks.push(spark);
    }
}

// DEBRIS PARTICLES - pooled
const debris = [];
const debrisGeo = new THREE.BoxGeometry(0.05, 0.05, 0.05);
const debrisMat = new THREE.MeshStandardMaterial({ color: 0x666666, roughness: 0.9 });

const debrisPool = new ObjectPool(
    () => { const d = new THREE.Mesh(debrisGeo, debrisMat); d.visible = false; return d; },
    (d) => { d.visible = false; },
    MAX_DEBRIS
);

function spawnDebris(point, normal) {
    for(let i=0; i<3; i++) { // Reduced from 5
        const d = debrisPool.get();
        d.position.copy(point);
        d.visible = true;
        _tempVec3.copy(normal).multiplyScalar(2 + Math.random()*4);
        _tempVec3.x += (Math.random()-0.5) * 4;
        _tempVec3.y += Math.random() * 3;
        _tempVec3.z += (Math.random()-0.5) * 4;
        d.userData = {
            velocity: _tempVec3.clone(),
            rotVel: new THREE.Vector3(Math.random()*10, Math.random()*10, Math.random()*10),
            life: 60 + Math.random()*60
        };
        scene.add(d);
        debris.push(d);
    }
}

const shells = [];
const mags = [];
const tracers = [];
const decals = [];
const decalTex = TextureFactory.impact();
const decalMat = new THREE.MeshBasicMaterial({ map: decalTex, transparent: true, polygonOffset: true, polygonOffsetFactor: -1 });
const shellGeo = new THREE.CylinderGeometry(0.04, 0.04, 0.25, 8);
const shellMat = new THREE.MeshStandardMaterial({
    color: 0xd4af37,
    metalness: 1.0,
    roughness: 0.15,
    envMap: envMapTex,
    envMapIntensity: 0.8
});

const raycaster = new THREE.Raycaster();

function ejectShell() {
    const shell = new THREE.Mesh(shellGeo, shellMat);
    shell.position.copy(new THREE.Vector3(0.5, 0.4, 0).applyMatrix4(gunGroup.matrixWorld));
    shell.quaternion.copy(gunGroup.quaternion); shell.rotation.z = Math.PI/2;
    const velocity = new THREE.Vector3(0.1 + Math.random()*0.1, 0.2 + Math.random()*0.1, 0).applyQuaternion(camera.quaternion);
    shell.userData = { velocity: velocity, life: 150 };
    scene.add(shell); shells.push(shell);
}

function spawnTracer(start, end) {
    // Main tracer line
    const points = [start, end];
    const geo = new THREE.BufferGeometry().setFromPoints(points);
    const mat = new THREE.LineBasicMaterial({
        color: 0xffff88,
        transparent: true,
        opacity: 1.0,
        blending: THREE.AdditiveBlending
    });
    const line = new THREE.Line(geo, mat);
    scene.add(line);
    tracers.push({ mesh: line, life: 4 });

    // Glow tracer (wider, softer)
    const glowMat = new THREE.LineBasicMaterial({
        color: 0xffaa44,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending
    });
    const glowLine = new THREE.Line(geo.clone(), glowMat);
    scene.add(glowLine);
    tracers.push({ mesh: glowLine, life: 3 });
}

function spawnDecal(point, normal) {
    const decal = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.4), decalMat);
    decal.position.copy(point);
    decal.position.addScaledVector(normal, 0.01);
    decal.lookAt(point.clone().add(normal));
    decal.rotation.z = Math.random() * Math.PI * 2;
    scene.add(decal);
    decals.push({ mesh: decal, life: 600 });

    // Spawn impact effects
    spawnImpactSparks(point, normal);
    spawnDebris(point, normal);
}

/**
 * LOGIC & STATE
 */
let ammo = 30;
let reserve = 90;
let isReloading = false;
let isFiring = false;
let isAiming = false;
let lastShotTime = 0;
const fireRate = 0.1;

// PLAYER HEALTH & GAME STATE
let playerHealth = 100;
let maxPlayerHealth = 100;
let score = 0;
let isGameOver = false;
let lastDamageTime = 0;
let damageFlashIntensity = 0;

function damagePlayer(amount) {
    if (isGameOver) return;

    playerHealth -= amount;
    lastDamageTime = performance.now();
    damageFlashIntensity = 0.5;
    playSound('playerHurt');

    // Screen shake
    Springs.shakeX.impulse((Math.random() - 0.5) * 20);
    Springs.shakeY.impulse((Math.random() - 0.5) * 20);

    if (playerHealth <= 0) {
        playerHealth = 0;
        gameOver();
    }
    updateHUD();
}

function addScore(points) {
    score += points;
    updateHUD();
}

function gameOver() {
    isGameOver = true;
    waveInProgress = false;
    document.getElementById('game-over').style.display = 'flex';
    document.getElementById('final-score').textContent = score;
    document.getElementById('final-wave').textContent = currentWave;
    document.exitPointerLock();
}

function restartGame() {
    // Reset all game state
    playerHealth = maxPlayerHealth;
    score = 0;
    ammo = 30;
    reserve = 90;
    currentWave = 0;
    zombiesThisWave = 0;
    zombiesKilledThisWave = 0;
    zombiesSpawnedThisWave = 0;
    waveInProgress = false;
    betweenWaves = true;
    nextWaveCountdown = 3;
    isGameOver = false;
    isReloading = false;

    // Clear all zombies
    for (const zombie of zombies) {
        zombie.cleanup();
    }
    zombies.length = 0;

    // Clear all pickups
    for (const pickup of pickups) {
        pickup.remove();
    }
    pickups.length = 0;

    // Reset power-up timers
    speedBoostTimer = 0;
    damageBoostTimer = 0;

    // Reset player position
    camera.position.set(0, 0, 0);

    // Hide game over screen
    document.getElementById('game-over').style.display = 'none';

    // Re-lock pointer
    document.body.requestPointerLock();

    updateHUD();
}

const moveState = { f: false, b: false, l: false, r: false, sprint: false };
const velocity = new THREE.Vector3();
const baseSpeed = 15.0;
const sprintMultiplier = 1.8;
let prevTime = performance.now();

// Jump physics
let verticalVelocity = 0;
let playerHeight = 0; // Offset from ground (-5)
const groundLevel = 0;
const gravity = 35;
const jumpForce = 12;
let isGrounded = true;
let canJump = true;

// Smooth landing spring
Springs.landing = new Spring(200, 15, 1);

// CAMERA STATE
let cameraPitch = 0;
let cameraYaw = 0;
let cameraRecoil = 0;
let currentFOV = 90;

const crosshair = document.getElementById('crosshair');
const hitmarker = document.getElementById('hitmarker');

let hitmarkerTimeout = null;
function showHitmarker() {
    hitmarker.classList.add('show');
    if (hitmarkerTimeout) clearTimeout(hitmarkerTimeout);
    hitmarkerTimeout = setTimeout(() => {
        hitmarker.classList.remove('show');
    }, 100);
}

// Power-up display element (created once)
let powerupsEl = null;
function ensurePowerupsEl() {
    if (!powerupsEl) {
        powerupsEl = document.createElement('div');
        powerupsEl.id = 'powerups-display';
        powerupsEl.style.cssText = `
            position: absolute; bottom: 60px; left: 20px;
            display: flex; gap: 10px; pointer-events: none;
        `;
        document.body.appendChild(powerupsEl);
    }
    return powerupsEl;
}

function updateHUD(force = false) {
    const dom = getCachedDOM();
    const remaining = zombiesThisWave - zombiesKilledThisWave;
    const healthPercent = Math.ceil(playerHealth);

    // Only update if values changed (or forced)
    if (force || lastHUDValues.ammo !== ammo || lastHUDValues.reserve !== reserve) {
        lastHUDValues.ammo = ammo;
        lastHUDValues.reserve = reserve;
        if (dom.ammoDisplay) {
            dom.ammoDisplay.innerText = `${isReloading ? 'RLD' : ammo} / `; // Infinite reserve
            dom.ammoDisplay.style.color = ammo <= 5 ? '#ff3333' : '#0f0';
        }
    }

    if (force || lastHUDValues.health !== healthPercent) {
        lastHUDValues.health = healthPercent;
        if (dom.healthFill) {
            const pct = (playerHealth / maxPlayerHealth) * 100;
            dom.healthFill.style.width = pct + '%';
            dom.healthFill.style.background = pct > 50 ? '#0f0' : pct > 25 ? '#ff0' : '#f00';
        }
        if (dom.healthText) {
            dom.healthText.textContent = healthPercent;
        }
    }

    if (force || lastHUDValues.wave !== currentWave || lastHUDValues.remaining !== remaining) {
        lastHUDValues.wave = currentWave;
        lastHUDValues.remaining = remaining;
        if (dom.waveDisplay) {
            if (betweenWaves && currentWave > 0) {
                dom.waveDisplay.textContent = `WAVE ${currentWave} COMPLETE`;
            } else if (betweenWaves) {
                dom.waveDisplay.textContent = `GET READY...`;
            } else {
                dom.waveDisplay.textContent = `WAVE ${currentWave}`;
            }
        }
        if (dom.zombieCount) {
            dom.zombieCount.textContent = `${remaining} ZOMBIES`;
        }
    }

    if (force || lastHUDValues.score !== score) {
        lastHUDValues.score = score;
        if (dom.scoreDisplay) {
            dom.scoreDisplay.textContent = score.toString().padStart(8, '0');
        }
    }

    // Power-ups (throttled to whole seconds)
    const speedSec = Math.ceil(speedBoostTimer);
    const damageSec = Math.ceil(damageBoostTimer);
    if (force || lastHUDValues.speedSec !== speedSec || lastHUDValues.damageSec !== damageSec) {
        lastHUDValues.speedSec = speedSec;
        lastHUDValues.damageSec = damageSec;
        const pEl = ensurePowerupsEl();
        let html = '';
        if (speedSec > 0) html += `<div style="color: #0ff; text-shadow: 0 0 10px #0ff; font-size: 16px;"> SPEED ${speedSec}s</div>`;
        if (damageSec > 0) html += `<div style="color: #f00; text-shadow: 0 0 10px #f00; font-size: 16px;"> 2X DMG ${damageSec}s</div>`;
        pEl.innerHTML = html;
    }
}

function shoot() {
    if (isGameOver) return;
    if (isReloading || ammo <= 0) {
        if (ammo <= 0 && !isReloading) playSound('empty');
        return;
    }
    const now = performance.now() / 1000;
    if (now - lastShotTime < fireRate) return;
    
    lastShotTime = now;
    ammo--; // Still decrement for reload mechanic
    updateHUD();
    playSound('shoot');

    // ORGANIC RECOIL IMPULSE PHYSICS
    const aimMod = isAiming ? 0.35 : 1.0;

    // Randomize recoil slightly for organic feel (no two shots identical)
    const recoilVariance = 0.85 + Math.random() * 0.3;
    const horizontalBias = (Math.random() - 0.5) * 0.4; // Slight random horizontal pull

    // Z: Backward kick into shoulder - primary recoil
    Springs.recoilZ.impulse(-14 * aimMod * recoilVariance);

    // X: Muzzle climb (negative = up) - with variance
    Springs.recoilX.impulse(-3.5 * aimMod * recoilVariance);

    // Y: Vertical physical rise
    Springs.recoilY.impulse(0.6 * aimMod * recoilVariance);

    // Roll: Rotational torque - asymmetric for realism
    Springs.recoilRoll.impulse((horizontalBias + (Math.random() - 0.5) * 0.3) * 0.8 * aimMod);
    Springs.roll.impulse(horizontalBias * 0.4 * aimMod);

    // Horizontal sway from recoil
    Springs.swayX.impulse(horizontalBias * 0.15 * aimMod);

    // Camera recoil - gradual climb
    cameraRecoil += 0.025 * aimMod * recoilVariance;

    // Subtle forward jolt
    Springs.bobZ.impulse(-0.8 * aimMod);

    // Crosshair pop with smooth animation
    if(!isAiming) {
        crosshair.style.width = '45px'; crosshair.style.height = '45px';
        crosshair.style.transition = 'width 0.05s, height 0.05s';
        setTimeout(() => {
            crosshair.style.width = '20px'; crosshair.style.height = '20px';
            crosshair.style.transition = 'width 0.15s ease-out, height 0.15s ease-out';
        }, 50);
    }

    // ENHANCED FLASH with variance
    const flashIntensity = 0.9 + Math.random() * 0.2;
    flashCoreMat.opacity = flashIntensity;
    flashMidMat.opacity = flashIntensity * 0.9;
    flashOuterMat.opacity = flashIntensity * 0.7;
    flashStreakMat.opacity = flashIntensity * 0.8;
    flashGroup.rotation.z = Math.random() * Math.PI;
    flashGroup.scale.setScalar(0.75 + Math.random() * 0.5);
    muzzleLight.position.copy(new THREE.Vector3(0, 0.3, -7.5).applyMatrix4(gunGroup.matrixWorld));
    muzzleLight.intensity = 25 + Math.random() * 10;
    muzzleLight.color.setHex(0xffaa44);

    // Spawn muzzle sparks
    spawnMuzzleSparks();

    // Dynamic post-processing punch
    bloomIntensity = 0.4 + Math.random() * 0.15;
    chromaticAmount = 0.0015 + Math.random() * 0.001;

    // Screen shake - organic variance
    const shakeIntensity = aimMod * recoilVariance;
    Springs.shakeX.impulse((Math.random() - 0.5) * 2.5 * shakeIntensity);
    Springs.shakeY.impulse((Math.random() - 0.3) * 2 * shakeIntensity); // Bias upward
    Springs.shakeRoll.impulse((Math.random() - 0.5) * 1.5 * shakeIntensity);

    // Bolt snap
    bolt.position.z = 0.5; 
    
    ejectShell();
    spawnSmoke();

    // RAYCAST
    raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
    const intersects = raycaster.intersectObjects(targets);
    const muzzlePos = new THREE.Vector3(0, 0.3, -6.5).applyMatrix4(gunGroup.matrixWorld);
    let hitPoint;
    if (intersects.length > 0) {
        hitPoint = intersects[0].point;

        // Check if we hit a shooting target
        if (intersects[0].object.userData.isTarget) {
            const target = intersects[0].object.userData.targetRef;
            if (target && target.isUp) {
                target.knockDown();
                playSound('targetHit');
            }
        } else if (intersects[0].object.userData.isBot) {
            // Hit a bot
            const bot = intersects[0].object.userData.botRef;
            if (bot && !bot.isDead) {
                bot.hit(intersects[0].point.clone());
                showHitmarker();
            }
        } else if (intersects[0].face) {
            spawnDecal(intersects[0].point, intersects[0].face.normal);
        }
    } else {
        hitPoint = raycaster.ray.origin.clone().add(raycaster.ray.direction.multiplyScalar(100));
    }
    spawnTracer(muzzlePos, hitPoint);
}

function dropMag() {
    const dMag = magPivot.clone(); // Clone pivot to preserve rotation
    scene.add(dMag);
    const wp = new THREE.Vector3(); const wq = new THREE.Quaternion();
    magPivot.getWorldPosition(wp); magPivot.getWorldQuaternion(wq);
    dMag.position.copy(wp); dMag.quaternion.copy(wq);
    // Inherit some velocity?
    dMag.userData = { vel: new THREE.Vector3(0, -2, 0), rot: new THREE.Vector3(1, 0, 0), life: 200 };
    mags.push(dMag);
}

/**
 * HIGH-END RELOAD SEQUENCE (Tween.js)
 */
function reload() {
    if (isGameOver) return;
    if (isReloading || ammo === 30) return; // Infinite reserve, always can reload
    if (isAiming) isAiming = false;
    isReloading = true;
    updateHUD();

    // ANIMATION TWEENS
    // 1. Tilt Gun
    new TWEEN.Tween(recoilGroup.rotation)
        .to({ z: 0.8, x: 0.3 }, 300)
        .easing(TWEEN.Easing.Cubic.Out)
        .start();

    // 2. Unlatch Mag (Fast)
    setTimeout(() => {
        playSound('mag_out');
        new TWEEN.Tween(magPivot.rotation)
            .to({ x: 1.5 }, 200)
            .easing(TWEEN.Easing.Back.In)
            .onComplete(() => {
                // 3. Drop
                dropMag();
                magPivot.visible = false;
                Springs.bobY.impulse(-2);
            })
            .start();

        // 4. Insert New Mag
        setTimeout(() => {
            magPivot.visible = true;
            magPivot.rotation.x = 0;
            magPivot.position.y = -4;

            new TWEEN.Tween(magPivot.position)
                .to({ y: -0.5 }, 300)
                .easing(TWEEN.Easing.Quadratic.Out)
                .onComplete(() => {
                    // 5. Lock In
                    playSound('mag_in');
                    Springs.recoilX.impulse(-2);
                    Springs.roll.impulse(-0.2);

                    // 6. Rack Bolt
                    setTimeout(() => {
                        playSound('rack');
                        new TWEEN.Tween(bolt.position).to({ z: 0.5 }, 100).easing(TWEEN.Easing.Cubic.Out).start();
                        Springs.recoilZ.impulse(2);

                        setTimeout(() => {
                            new TWEEN.Tween(bolt.position).to({ z: -0.5 }, 80).easing(TWEEN.Easing.Exponential.In).start();
                            Springs.recoilZ.impulse(-5);

                            // 7. Return to Idle
                            new TWEEN.Tween(recoilGroup.rotation)
                                .to({ z: 0, x: 0 }, 400)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();

                            ammo = 30; // Infinite reserve, always full reload
                            isReloading = false;
                            updateHUD();
                        }, 150);
                    }, 200);
                })
                .start();
        }, 300);
    }, 250);
}

// Input
const keys = {};
document.addEventListener('keydown', (e) => {
    keys[e.code] = true;
    if (e.code === 'KeyR') reload();
    if (e.code === 'KeyW') moveState.f = true;
    if (e.code === 'KeyS') moveState.b = true;
    if (e.code === 'KeyA') moveState.l = true;
    if (e.code === 'KeyD') moveState.r = true;
    if (e.code === 'ShiftLeft') moveState.sprint = true;
    if (e.code === 'Space' && isGrounded && canJump) {
        verticalVelocity = jumpForce;
        isGrounded = false;
        canJump = false;
        // Slight upward weapon motion on jump
        Springs.bobY.impulse(-1.5);
    }
});
document.addEventListener('keyup', (e) => {
    keys[e.code] = false;
    if (e.code === 'KeyW') moveState.f = false;
    if (e.code === 'KeyS') moveState.b = false;
    if (e.code === 'KeyA') moveState.l = false;
    if (e.code === 'KeyD') moveState.r = false;
    if (e.code === 'ShiftLeft') moveState.sprint = false;
    if (e.code === 'Space') canJump = true;
});
document.addEventListener('mousedown', (e) => {
    if (document.pointerLockElement !== document.body) {
        document.body.requestPointerLock();
        document.getElementById('blocker').style.display = 'none';
    } else {
        if(e.button === 0) isFiring = true;
        if(e.button === 2) isAiming = true;
    }
});
document.addEventListener('mouseup', (e) => {
    if(e.button === 0) isFiring = false;
    if(e.button === 2) isAiming = false;
});

document.addEventListener('mousemove', (e) => {
    if (document.pointerLockElement === document.body) {
        const sens = isAiming ? 0.001 : 0.002;
        cameraYaw -= e.movementX * sens;
        cameraPitch -= e.movementY * sens;
        cameraPitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraPitch));

        // ULTRA FLUID Procedural Sway - multi-layered organic response
        const adsReduction = isAiming ? 0.4 : 1.0;

        // Primary sway - immediate response
        const swayAmount = 0.0025 * adsReduction;
        Springs.swayX.target = -e.movementX * swayAmount;
        Springs.swayY.target = -e.movementY * swayAmount;

        // Roll with horizontal look - weapon tilts into turns
        const rollAmount = 0.005 * adsReduction;
        Springs.roll.target = -e.movementX * rollAmount;

        // Tilt on vertical look - weapon dips/rises with view
        Springs.tilt.target += e.movementY * 0.0004 * adsReduction;

        // Secondary lag layers get impulses for organic trailing
        const moveSpeed = Math.sqrt(e.movementX * e.movementX + e.movementY * e.movementY);
        if (moveSpeed > 2) {
            Springs.swayLagX.impulse(-e.movementX * 0.0008 * adsReduction);
            Springs.swayLagY.impulse(-e.movementY * 0.0008 * adsReduction);
            Springs.swayLag2X.impulse(-e.movementX * 0.0004 * adsReduction);
            Springs.swayLag2Y.impulse(-e.movementY * 0.0004 * adsReduction);
        }

        // Fast movements add extra roll momentum
        if (Math.abs(e.movementX) > 8) {
            Springs.roll.impulse(-e.movementX * 0.0003 * adsReduction);
        }

        // Motion blur from camera rotation - more subtle
        motionBlurX = Math.min(0.012, Math.abs(e.movementX) * 0.0004) * Math.sign(e.movementX);
        motionBlurY = Math.min(0.008, Math.abs(e.movementY) * 0.0004) * Math.sign(e.movementY);
    }
});

function animate(time) {
    requestAnimationFrame(animate);
    TWEEN.update(time);
    const dt = Math.min((time - prevTime) / 1000, 0.1); // Cap dt
    prevTime = time;
    frameCount++;

    // Throttled shadow updates
    if (frameCount % SHADOW_UPDATE_INTERVAL === 0) {
        renderer.shadowMap.needsUpdate = true;
    }

    // ADS Logic + Sprint FOV
    const targetPos = isAiming ? aimPos : hipPos;
    const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
    const targetFOV = isAiming ? 55 : (isSprinting ? 100 : 90);

    // Smooth transition for base position (Lerp is fine for macroscopic movements)
    recoilGroup.position.lerp(targetPos, 15 * dt);
    currentFOV = THREE.MathUtils.lerp(currentFOV, targetFOV, 8 * dt);
    camera.fov = currentFOV;
    camera.updateProjectionMatrix();

    // Hide crosshair when aiming
    crosshair.style.opacity = isAiming ? 0 : 1;

    // Track camera velocity for inertia
    camVelX = (cameraYaw - lastCamYaw) / Math.max(dt, 0.001);
    camVelY = (cameraPitch - lastCamPitch) / Math.max(dt, 0.001);
    lastCamYaw = cameraYaw;
    lastCamPitch = cameraPitch;

    // Update ALL Springs - Enhanced organic motion
    const recoilZ = Springs.recoilZ.update(dt);
    const recoilX = Springs.recoilX.update(dt);
    const recoilY = Springs.recoilY.update(dt);
    const recoilRoll = Springs.recoilRoll.update(dt);
    const recoilRecoverZ = Springs.recoilRecoverZ.update(dt);
    const recoilRecoverX = Springs.recoilRecoverX.update(dt);
    const swayX = Springs.swayX.update(dt);
    const swayY = Springs.swayY.update(dt);
    const swayLagX = Springs.swayLagX.update(dt);
    const swayLagY = Springs.swayLagY.update(dt);
    const swayLag2X = Springs.swayLag2X.update(dt);
    const swayLag2Y = Springs.swayLag2Y.update(dt);
    const bobY = Springs.bobY.update(dt);
    const bobX = Springs.bobX.update(dt);
    const bobZ = Springs.bobZ.update(dt);
    const roll = Springs.roll.update(dt);
    const tilt = Springs.tilt.update(dt);
    const breathe = Springs.breathe.update(dt);
    const idleSway = Springs.idleSway.update(dt);
    const heartbeat = Springs.heartbeat.update(dt);
    const momentumX = Springs.momentumX.update(dt);
    const momentumZ = Springs.momentumZ.update(dt);
    const shakeX = Springs.shakeX.update(dt);
    const shakeY = Springs.shakeY.update(dt);
    const shakeRoll = Springs.shakeRoll.update(dt);
    const camLagX = Springs.camLagX.update(dt);
    const camLagY = Springs.camLagY.update(dt);
    const adsTransition = Springs.adsTransition.update(dt);
    const sprintBob = Springs.sprintBob.update(dt);
    const sprintTilt = Springs.sprintTilt.update(dt);
    const sprintRoll = Springs.sprintRoll.update(dt);
    const landingTilt = Springs.landingTilt.update(dt);

    // Organic idle animations using layered noise
    const idleTime = time * 0.001;
    const breatheWave = organicNoise(idleTime, 0.8, 2) * 0.012;
    const idleSwayWave = organicNoise(idleTime + 100, 0.3, 3) * 0.008;
    const microTremor = organicNoise(idleTime * 3, 2.5, 2) * 0.002;

    Springs.breathe.target = breatheWave;
    Springs.idleSway.target = idleSwayWave;
    Springs.heartbeat.target = Math.sin(idleTime * 1.2) * 0.003; // Subtle pulse

    // Feed camera velocity into multi-layer lag springs for organic weapon inertia
    Springs.swayLagX.target = swayX * 0.7;
    Springs.swayLagY.target = swayY * 0.7;
    Springs.swayLag2X.target = swayLagX * 0.6;
    Springs.swayLag2Y.target = swayLagY * 0.6;
    Springs.camLagX.target = -camVelX * 0.00025;
    Springs.camLagY.target = -camVelY * 0.00025;

    // Track movement for momentum-based weapon lag
    moveVelX = THREE.MathUtils.lerp(moveVelX, velocity.x, 0.08);
    moveVelZ = THREE.MathUtils.lerp(moveVelZ, velocity.z, 0.08);
    Springs.momentumX.target = -moveVelX * 0.003;
    Springs.momentumZ.target = -moveVelZ * 0.002;

    // Recoil recovery feeds into slower springs for organic settle
    Springs.recoilRecoverZ.target = recoilZ * 0.3;
    Springs.recoilRecoverX.target = recoilX * 0.3;

    // ADS smoothing
    Springs.adsTransition.target = isAiming ? 1 : 0;
    const adsAmount = adsTransition;
    const adsMultiplier = 1 - adsAmount * 0.6; // Reduce motion when ADS

    // Apply Springs to Gun - ULTRA FLUID layered organic motion
    // Position: recoil + bob + breathing + momentum + micro tremors
    const combinedRecoilZ = recoilZ + recoilRecoverZ * 0.5;
    const combinedRecoilX = recoilX + recoilRecoverX * 0.5;

    gunGroup.position.z = combinedRecoilZ * adsMultiplier + bobZ * adsMultiplier + breathe * 0.4 + momentumZ;
    gunGroup.position.y = bobY * adsMultiplier + recoilY * adsMultiplier + breathe + heartbeat + microTremor;
    gunGroup.position.x = bobX * adsMultiplier + swayLag2X * 0.25 + momentumX + idleSway * 0.5;

    // Rotation: multi-layered sway + recoil + tilt + breathing + organic noise
    const totalSwayX = (swayX + swayLagX * 0.5 + swayLag2X * 0.3 + camLagX) * adsMultiplier;
    const totalSwayY = (swayY + swayLagY * 0.5 + swayLag2Y * 0.3 + camLagY) * adsMultiplier;

    gunGroup.rotation.x = combinedRecoilX * adsMultiplier + totalSwayY + tilt + breathe * 0.25 + landingTilt * 0.5 + sprintTilt;
    gunGroup.rotation.y = Math.PI + totalSwayX + idleSway * 0.3;
    gunGroup.rotation.z = (roll + recoilRoll) * adsMultiplier + totalSwayX * 0.35 + breathe * 0.15 + sprintRoll + microTremor * 2;

    // Reset Spring Targets (decay to neutral)
    Springs.swayX.target = 0;
    Springs.swayY.target = 0;
    Springs.roll.target = 0;
    Springs.tilt.target = 0;
    Springs.recoilZ.target = 0;
    Springs.recoilX.target = 0;
    Springs.recoilY.target = 0;
    Springs.recoilRoll.target = 0;
    Springs.bobX.target = 0;
    Springs.bobZ.target = 0;
    Springs.sprintBob.target = 0;
    Springs.sprintTilt.target = 0;
    Springs.sprintRoll.target = 0;
    Springs.landingTilt.target = 0;

    // Camera Recoil Recovery + Screen Shake - more organic
    cameraRecoil = THREE.MathUtils.lerp(cameraRecoil, 0, 0.08); // Slower recovery
    camera.rotation.set(
        cameraPitch + cameraRecoil + shakeY * 0.018 + breathe * 0.1,
        cameraYaw + shakeX * 0.018,
        (roll + shakeRoll) * 0.08,
        'YXZ'
    );

    // FLUID Movement (disabled during game over)
    if (document.pointerLockElement === document.body && !isGameOver) {
        // Smoother deceleration for fluid feel
        const friction = isGrounded ? 8.0 : 3.0;
        velocity.x -= velocity.x * friction * dt;
        velocity.z -= velocity.z * friction * dt;

        const fIn = Number(moveState.f) - Number(moveState.b);
        const rIn = Number(moveState.r) - Number(moveState.l);

        // Sprinting logic - only when moving forward and not aiming
        const isSprinting = moveState.sprint && moveState.f && !isAiming && isGrounded;
        const speedMultiplier = speedBoostTimer > 0 ? speedBoostMultiplier : 1;
        const currentSpeed = (isAiming ? baseSpeed * 0.5 : (isSprinting ? baseSpeed * sprintMultiplier : baseSpeed)) * speedMultiplier;

        // Smoother acceleration
        const accel = isGrounded ? 12.0 : 4.0;
        if (moveState.f || moveState.b) velocity.z += fIn * currentSpeed * accel * dt;
        if (moveState.l || moveState.r) velocity.x += rIn * currentSpeed * accel * dt;

        const fwd = new THREE.Vector3(); camera.getWorldDirection(fwd); fwd.y = 0; fwd.normalize();
        const rgt = new THREE.Vector3().crossVectors(fwd, new THREE.Vector3(0,1,0)).normalize();
        camera.position.addScaledVector(fwd, velocity.z * dt);
        camera.position.addScaledVector(rgt, velocity.x * dt);

        // ULTRA FLUID Jump physics
        if (!isGrounded) {
            verticalVelocity -= gravity * dt;
            playerHeight += verticalVelocity * dt;

            // Organic airborne weapon drift
            const airTime = Math.abs(verticalVelocity) / gravity; // Approximate time in air

            // Weapon tilts based on vertical velocity - rising vs falling feels different
            if (verticalVelocity > 0) {
                // Rising - weapon tips back slightly
                Springs.tilt.target = verticalVelocity * 0.008;
                Springs.bobY.target = -verticalVelocity * 0.004;
                Springs.bobZ.target = verticalVelocity * 0.003; // Weapon pulls back
            } else {
                // Falling - weapon tips forward, bracing for landing
                Springs.tilt.target = verticalVelocity * 0.012;
                Springs.bobY.target = -verticalVelocity * 0.006;
                Springs.bobZ.target = verticalVelocity * 0.002;
                // Pre-brace roll
                Springs.roll.target = Math.sin(playerHeight * 2) * 0.02;
            }

            // Subtle floating sway while airborne
            Springs.swayX.target += Math.sin(time * 0.003) * 0.005;
            Springs.idleSway.target = Math.cos(time * 0.002) * 0.01;

            // Landing
            if (playerHeight <= groundLevel) {
                playerHeight = groundLevel;
                const landingImpact = Math.abs(verticalVelocity);
                verticalVelocity = 0;
                isGrounded = true;

                // ORGANIC landing effect based on fall speed
                if (landingImpact > 2) {
                    const impactScale = Math.min(landingImpact / 15, 1); // Normalize

                    // Main landing dip
                    Springs.landing.impulse(landingImpact * 0.25);

                    // Weapon drops and recovers
                    Springs.bobY.impulse(-landingImpact * 0.15);
                    Springs.bobZ.impulse(landingImpact * 0.08); // Weapon punches forward

                    // Tilt forward on impact
                    Springs.landingTilt.impulse(landingImpact * 0.025);
                    Springs.tilt.impulse(landingImpact * 0.015);

                    // Asymmetric roll for organic feel
                    Springs.roll.impulse((Math.random() - 0.4) * landingImpact * 0.025);

                    // Recoil springs add to the chaos
                    Springs.recoilY.impulse(-landingImpact * 0.08);

                    // Screen shake on harder landings
                    if (landingImpact > 6) {
                        Springs.shakeY.impulse(-landingImpact * 0.5);
                        Springs.shakeX.impulse((Math.random() - 0.5) * landingImpact * 0.25);
                        Springs.shakeRoll.impulse((Math.random() - 0.5) * landingImpact * 0.15);
                    }
                }
            }
        }

        // Apply landing spring
        const landingOffset = Springs.landing.update(dt);
        Springs.landing.target = 0;

        // Set camera Y position (base + jump height - landing dip)
        camera.position.y = playerHeight - landingOffset * 0.1;

        // ULTRA FLUID Procedural Bobbing (Walking/Sprinting)
        const vLen = Math.sqrt(velocity.x*velocity.x + velocity.z*velocity.z);
        moveVelSmooth = THREE.MathUtils.lerp(moveVelSmooth, vLen, 0.08); // Smoother velocity tracking
        const bobSpeed = isSprinting ? 0.016 : 0.011;
        const bobIntensity = isSprinting ? 0.1 : 0.06;
        const velRatio = Math.min(moveVelSmooth / baseSpeed, 1.5);

        if(moveVelSmooth > 0.1 && !isReloading && isGrounded) {
            // Phase offset for more natural gait
            const phase = time * bobSpeed;
            const phase2 = phase * 0.5;

            // Vertical bob - asymmetric for natural feel (footsteps aren't perfectly symmetric)
            const vertBob = Math.sin(phase) * 0.7 + Math.sin(phase * 2) * 0.3;
            Springs.bobY.target = vertBob * bobIntensity * velRatio;

            // Horizontal bob (side-to-side sway) - slower frequency
            const horizBob = Math.cos(phase2) + Math.sin(phase2 * 1.5) * 0.2;
            Springs.bobX.target = horizBob * bobIntensity * 0.35 * velRatio;

            // Forward/back bob - subtle push with each step
            Springs.bobZ.target = Math.sin(phase + 0.5) * bobIntensity * 0.2 * velRatio;

            // Hip sway rotation - figure-8 pattern for organic feel
            const hipSwayX = Math.cos(phase2) * 0.02 + Math.sin(phase * 0.7) * 0.008;
            Springs.swayX.target += hipSwayX * velRatio;

            // Roll with steps - asymmetric
            const stepRoll = Math.sin(phase) * 0.018 + Math.cos(phase * 1.3) * 0.006;
            Springs.roll.target += stepRoll * velRatio;

            // Forward tilt when moving - increases with speed
            Springs.tilt.target = -velRatio * 0.025;

            // Extra effects when sprinting - more dramatic
            if (isSprinting) {
                // Exaggerated sprint bob
                Springs.sprintBob.target = Math.sin(phase * 1.2) * 0.08;
                Springs.bobY.target += Springs.sprintBob.position;

                // More aggressive roll
                Springs.sprintRoll.target = Math.sin(phase) * 0.035;

                // Strong forward lean
                Springs.sprintTilt.target = -0.055;
                Springs.tilt.target = -0.04;

                // Weapon pulls back slightly when sprinting
                Springs.bobZ.target -= 0.15;
            }
        } else if (isGrounded) {
            // Smooth return to idle
            Springs.bobY.target = 0;
            Springs.bobX.target = 0;
            Springs.bobZ.target = 0;
            Springs.tilt.target = 0;
        }
    }

    if (isFiring) shoot();

    // Decay Enhanced Flash
    if (flashCoreMat.opacity > 0.01) {
        flashCoreMat.opacity = Math.max(0, flashCoreMat.opacity - 0.25);
        flashMidMat.opacity = Math.max(0, flashMidMat.opacity - 0.2);
        flashOuterMat.opacity = Math.max(0, flashOuterMat.opacity - 0.15);
        flashStreakMat.opacity = Math.max(0, flashStreakMat.opacity - 0.2);
        muzzleLight.intensity = Math.max(0, muzzleLight.intensity - 4);
    } else {
        flashCoreMat.opacity = 0;
        flashMidMat.opacity = 0;
        flashOuterMat.opacity = 0;
        flashStreakMat.opacity = 0;
        muzzleLight.intensity = 0;
    }

    // Decay dynamic post-processing
    bloomIntensity = THREE.MathUtils.lerp(bloomIntensity, 0.12, 0.15);
    chromaticAmount = THREE.MathUtils.lerp(chromaticAmount, 0.0005, 0.1);
    bloomPass.strength = bloomIntensity;
    chromaticPass.uniforms.amount.value = chromaticAmount;

    // Update motion blur based on camera rotation velocity
    motionBlurX = THREE.MathUtils.lerp(motionBlurX, 0, 0.2);
    motionBlurY = THREE.MathUtils.lerp(motionBlurY, 0, 0.2);
    motionBlurPass.uniforms.velocityX.value = motionBlurX;
    motionBlurPass.uniforms.velocityY.value = motionBlurY;

    // Update film grain time
    grainPass.uniforms.time.value = time * 0.001;

    // Update heat distortion time
    heatPass.uniforms.time.value = time * 0.001;

    // Update sky shader time for animated clouds
    skyUniforms.time.value = time * 0.001;

    // Calculate sun screen position for god rays and lens flare
    const sunWorldPos = sun.position.clone();
    const sunScreenPosTemp = sunWorldPos.project(camera);
    sunScreenPos.set(
        (sunScreenPosTemp.x + 1) / 2,
        (sunScreenPosTemp.y + 1) / 2
    );

    // Check if sun is visible (in front of camera and on screen)
    const sunDir = sunWorldPos.clone().sub(camera.position).normalize();
    const camDir = new THREE.Vector3();
    camera.getWorldDirection(camDir);
    const sunDot = sunDir.dot(camDir);

    // Sun visibility based on angle and screen bounds
    sunVisible = sunDot > 0 &&
                 sunScreenPos.x > -0.3 && sunScreenPos.x < 1.3 &&
                 sunScreenPos.y > -0.3 && sunScreenPos.y < 1.3 ?
                 Math.pow(sunDot, 2) : 0;

    // Update god rays uniforms
    godRaysPass.uniforms.lightPositionOnScreen.value.copy(sunScreenPos);

    // Update lens flare uniforms
    lensFlarePass.uniforms.sunPosition.value.copy(sunScreenPos);
    lensFlarePass.uniforms.sunVisible.value = sunVisible;

    // Reset screen shake targets
    Springs.shakeX.target = 0;
    Springs.shakeY.target = 0;
    
    // Bolt Recovery (Spring-ish)
    if (!isReloading && bolt.position.z < -0.5) bolt.position.z += 0.1;

    // Entity Updates - using swap-and-pop for O(1) removal
    // Shells
    for(let i = shells.length - 1; i >= 0; i--) {
        const s = shells[i];
        s.position.addScaledVector(s.userData.velocity, dt * 60);
        s.userData.velocity.y -= 0.02; s.rotation.x += 0.2;
        if(s.position.y < -5) { s.position.y = -5; s.userData.velocity.set(0,0,0); }
        if(--s.userData.life <= 0) {
            scene.remove(s);
            shells[i] = shells[shells.length - 1];
            shells.pop();
        }
    }
    // Mags
    for(let i = mags.length - 1; i >= 0; i--) {
        const m = mags[i];
        m.position.addScaledVector(m.userData.vel, dt * 60);
        m.rotation.x += m.userData.rot.x * 0.1;
        m.userData.vel.y -= 0.02;
        if(m.position.y < -5) { m.position.y = -5; m.userData.vel.set(0,0,0); }
        if(--m.userData.life <= 0) {
            scene.remove(m);
            mags[i] = mags[mags.length - 1];
            mags.pop();
        }
    }
    // Smoke particles with pooling
    for(let i = smokeParticles.length - 1; i >= 0; i--) {
        const s = smokeParticles[i];
        s.age += dt;
        const r = s.age / s.life;
        if(r >= 1) {
            scene.remove(s.mesh);
            smokePool.release(s.mesh);
            smokeParticles[i] = smokeParticles[smokeParticles.length - 1];
            smokeParticles.pop();
            continue;
        }
        s.mesh.position.addScaledVector(s.velocity, dt);
        if(s.hot) {
            s.mesh.scale.setScalar(0.3 + r * 1.5);
            s.mesh.material.opacity = 0.6 * (1 - r);
        } else {
            s.mesh.scale.setScalar(0.5 + r * 4);
            s.mesh.material.opacity = 0.5 * (1 - r);
        }
        s.velocity.y += 1.5 * dt;
        s.velocity.multiplyScalar(0.99);
    }

    // Sparks with pooling
    for(let i = sparks.length - 1; i >= 0; i--) {
        const sp = sparks[i];
        sp.userData.life -= dt;
        if(sp.userData.life <= 0) {
            scene.remove(sp);
            sparkPool.release(sp);
            sparks[i] = sparks[sparks.length - 1];
            sparks.pop();
            continue;
        }
        sp.position.addScaledVector(sp.userData.velocity, dt);
        sp.userData.velocity.y -= 20 * dt;
        sp.material.opacity = sp.userData.life * 3;
    }

    // Debris with pooling
    for(let i = debris.length - 1; i >= 0; i--) {
        const d = debris[i];
        d.userData.life--;
        if(d.userData.life <= 0) {
            scene.remove(d);
            debrisPool.release(d);
            debris[i] = debris[debris.length - 1];
            debris.pop();
            continue;
        }
        d.position.addScaledVector(d.userData.velocity, dt);
        d.userData.velocity.y -= 15 * dt;
        d.rotation.x += d.userData.rotVel.x * dt;
        d.rotation.y += d.userData.rotVel.y * dt;
        d.rotation.z += d.userData.rotVel.z * dt;
        if(d.position.y < -4.9) {
            d.position.y = -4.9;
            d.userData.velocity.set(0, 0, 0);
            d.userData.rotVel.multiplyScalar(0.9);
        }
    }
    // Tracers
    for(let i = tracers.length - 1; i >= 0; i--) {
        const t = tracers[i];
        t.life--;
        t.mesh.material.opacity = t.life / 3;
        if(t.life <= 0) {
            scene.remove(t.mesh);
            tracers[i] = tracers[tracers.length - 1];
            tracers.pop();
        }
    }
    // Decals
    for(let i = decals.length - 1; i >= 0; i--) {
        const d = decals[i];
        d.life--;
        if(d.life < 60) d.mesh.material.opacity = d.life / 60;
        if(d.life <= 0) {
            scene.remove(d.mesh);
            decals[i] = decals[decals.length - 1];
            decals.pop();
        }
    }

    // Update shooting targets
    for (const target of shootingTargets) {
        target.update(dt);
    }

    // Update wave system (only if game is active)
    if (!isGameOver) {
        updateWaveSystem(dt);
        updatePickups(dt, time);

        // Update power-up timers
        if (speedBoostTimer > 0) {
            speedBoostTimer -= dt;
            if (speedBoostTimer <= 0) speedBoostTimer = 0;
        }
        if (damageBoostTimer > 0) {
            damageBoostTimer -= dt;
            if (damageBoostTimer <= 0) damageBoostTimer = 0;
        }

        // Throttled HUD update (only updates when values change)
        if (frameCount % HUD_UPDATE_INTERVAL === 0) {
            updateHUD();
        }
    }

    // Update zombies
    for (const zombie of zombies) {
        zombie.update(dt, time);
    }

    // Update blood and gore effects
    updateBloodEffects(dt);

    // Update damage flash
    if (damageFlashIntensity > 0) {
        damageFlashIntensity -= dt * 2;
        if (damageFlashIntensity < 0) damageFlashIntensity = 0;
        document.getElementById('damage-flash').style.opacity = damageFlashIntensity;
    }

    // Animate dust particles (throttled to every 3 frames)
    if (frameCount % 3 === 0) {
        const dustPos = dustGeo.attributes.position.array;
        for(let i = 0; i < dustCount; i++) {
            dustPos[i * 3 + 1] += Math.sin(time * 0.0005 + i) * 0.006;
            const dx = dustPos[i * 3] - camera.position.x;
            const dz = dustPos[i * 3 + 2] - camera.position.z;
            if(Math.abs(dx) > 100) dustPos[i * 3] = camera.position.x + (Math.random() - 0.5) * 200;
            if(Math.abs(dz) > 100) dustPos[i * 3 + 2] = camera.position.z + (Math.random() - 0.5) * 200;
        }
        dustGeo.attributes.position.needsUpdate = true;
    }

    // Render with post-processing
    composer.render();
}

window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
    composer.setSize(window.innerWidth, window.innerHeight);
    bloomPass.setSize(window.innerWidth / 2, window.innerHeight / 2); // Half resolution for performance
    outlinePass.uniforms.resolution.value.set(window.innerWidth, window.innerHeight);
});

// Initialize HUD (force update all values)
updateHUD(true);

animate(performance.now());
</script>
</body>
</html>